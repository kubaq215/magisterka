===== build.c =====

#include "ogs-pfcp.h"

ogs_pkbuf_t *ogs_pfcp_build_heartbeat_request(uint8_t type)
{
    ogs_pfcp_message_t *pfcp_message = NULL;
    ogs_pfcp_heartbeat_request_t *req = NULL;
    ogs_pkbuf_t *pkbuf = NULL;

    ogs_debug("Heartbeat Request");

    pfcp_message = ogs_calloc(1, sizeof(*pfcp_message));
    if (!pfcp_message) {
        ogs_error("ogs_calloc() failed");
        return NULL;
    }

    req = &pfcp_message->pfcp_heartbeat_request;

    req->recovery_time_stamp.presence = 1;
    req->recovery_time_stamp.u32 = ogs_pfcp_self()->local_recovery;

    pfcp_message->h.type = type;
    pkbuf = ogs_pfcp_build_msg(pfcp_message);
    ogs_expect(pkbuf);

    ogs_free(pfcp_message);

    return pkbuf;
}

ogs_pkbuf_t *ogs_pfcp_build_heartbeat_response(uint8_t type)
{
    ogs_pfcp_message_t *pfcp_message = NULL;
    ogs_pfcp_heartbeat_response_t *rsp = NULL;
    ogs_pkbuf_t *pkbuf = NULL;

    ogs_debug("Heartbeat Response");

    pfcp_message = ogs_calloc(1, sizeof(*pfcp_message));
    if (!pfcp_message) {
        ogs_error("ogs_calloc() failed");
        return NULL;
    }

    rsp = &pfcp_message->pfcp_heartbeat_response;

    rsp->recovery_time_stamp.presence = 1;
    rsp->recovery_time_stamp.u32 = ogs_pfcp_self()->local_recovery;

    pfcp_message->h.type = type;
    pkbuf = ogs_pfcp_build_msg(pfcp_message);
    ogs_expect(pkbuf);

    ogs_free(pfcp_message);

    return pkbuf;
}

ogs_pkbuf_t *ogs_pfcp_cp_build_association_setup_request(uint8_t type)
{
    ogs_pfcp_message_t *pfcp_message = NULL;
    ogs_pfcp_association_setup_request_t *req = NULL;
    ogs_pkbuf_t *pkbuf = NULL;

    ogs_pfcp_node_id_t node_id;
    int node_id_len = 0, rv;

    ogs_debug("Association Setup Request");

    pfcp_message = ogs_calloc(1, sizeof(*pfcp_message));
    if (!pfcp_message) {
        ogs_error("ogs_calloc() failed");
        return NULL;
    }

    req = &pfcp_message->pfcp_association_setup_request;

    rv = ogs_pfcp_sockaddr_to_node_id(&node_id, &node_id_len);
    if (rv != OGS_OK) {
        ogs_error("ogs_pfcp_sockaddr_to_node_id() failed");
        ogs_free(pfcp_message);
        return NULL;
    }
    req->node_id.presence = 1;
    req->node_id.data = &node_id;
    req->node_id.len = node_id_len;

    req->recovery_time_stamp.presence = 1;
    req->recovery_time_stamp.u32 = ogs_pfcp_self()->local_recovery;

    req->cp_function_features.presence = 1;
    req->cp_function_features.u8 = ogs_pfcp_self()->cp_function_features.octet5;

    pfcp_message->h.type = type;
    pkbuf = ogs_pfcp_build_msg(pfcp_message);
    ogs_expect(pkbuf);

    ogs_free(pfcp_message);

    return pkbuf;
}

ogs_pkbuf_t *ogs_pfcp_cp_build_association_setup_response(uint8_t type,
        uint8_t cause)
{
    ogs_pfcp_message_t *pfcp_message = NULL;
    ogs_pfcp_association_setup_response_t *rsp = NULL;
    ogs_pkbuf_t *pkbuf = NULL;

    ogs_pfcp_node_id_t node_id;
    int node_id_len = 0, rv;

    ogs_debug("Association Setup Response");

    pfcp_message = ogs_calloc(1, sizeof(*pfcp_message));
    if (!pfcp_message) {
        ogs_error("ogs_calloc() failed");
        return NULL;
    }

    rsp = &pfcp_message->pfcp_association_setup_response;

    rv = ogs_pfcp_sockaddr_to_node_id(&node_id, &node_id_len);
    if (rv != OGS_OK) {
        ogs_error("ogs_pfcp_sockaddr_to_node_id() failed");
        ogs_free(pfcp_message);
        return NULL;
    }
    rsp->node_id.presence = 1;
    rsp->node_id.data = &node_id;
    rsp->node_id.len = node_id_len;

    rsp->cause.presence = 1;
    rsp->cause.u8 = cause;

    rsp->recovery_time_stamp.presence = 1;
    rsp->recovery_time_stamp.u32 = ogs_pfcp_self()->local_recovery;

    rsp->cp_function_features.presence = 1;
    rsp->cp_function_features.u8 = ogs_pfcp_self()->cp_function_features.octet5;

    pfcp_message->h.type = type;
    pkbuf = ogs_pfcp_build_msg(pfcp_message);
    ogs_expect(pkbuf);

    ogs_free(pfcp_message);

    return pkbuf;
}

ogs_pkbuf_t *ogs_pfcp_up_build_association_setup_request(uint8_t type)
{
    ogs_pfcp_message_t *pfcp_message = NULL;
    ogs_pfcp_association_setup_request_t *req = NULL;
    ogs_pkbuf_t *pkbuf = NULL;

    ogs_pfcp_node_id_t node_id;
    int node_id_len = 0;

    ogs_gtpu_resource_t *resource = NULL;
    char infobuf[OGS_MAX_NUM_OF_GTPU_RESOURCE]
                [OGS_MAX_USER_PLANE_IP_RESOURCE_INFO_LEN];
    int i = 0, rv;

    ogs_debug("Association Setup Request");

    pfcp_message = ogs_calloc(1, sizeof(*pfcp_message));
    if (!pfcp_message) {
        ogs_error("ogs_calloc() failed");
        return NULL;
    }

    req = &pfcp_message->pfcp_association_setup_request;

    rv = ogs_pfcp_sockaddr_to_node_id(&node_id, &node_id_len);
    if (rv != OGS_OK) {
        ogs_error("ogs_pfcp_sockaddr_to_node_id() failed");
        ogs_free(pfcp_message);
        return NULL;
    }
    req->node_id.presence = 1;
    req->node_id.data = &node_id;
    req->node_id.len = node_id_len;

    req->recovery_time_stamp.presence = 1;
    req->recovery_time_stamp.u32 = ogs_pfcp_self()->local_recovery;

    ogs_assert(ogs_pfcp_self()->up_function_features_len);
    req->up_function_features.presence = 1;
    req->up_function_features.data = &ogs_pfcp_self()->up_function_features;
    req->up_function_features.len = ogs_pfcp_self()->up_function_features_len;

    if (ogs_pfcp_self()->up_function_features.ftup == 0) {
        i = 0;
        ogs_list_for_each(&ogs_gtp_self()->gtpu_resource_list, resource) {
            ogs_assert(i < OGS_MAX_NUM_OF_GTPU_RESOURCE);
            ogs_pfcp_tlv_user_plane_ip_resource_information_t *message =
                &req->user_plane_ip_resource_information[i];
            ogs_assert(message);

            message->presence = 1;
            ogs_pfcp_build_user_plane_ip_resource_info(
                message, &resource->info, infobuf[i],
                OGS_MAX_USER_PLANE_IP_RESOURCE_INFO_LEN);
            i++;
        }
    }

    pfcp_message->h.type = type;
    pkbuf = ogs_pfcp_build_msg(pfcp_message);
    ogs_expect(pkbuf);

    ogs_free(pfcp_message);

    return pkbuf;
}

ogs_pkbuf_t *ogs_pfcp_up_build_association_setup_response(uint8_t type,
        uint8_t cause)
{
    ogs_pfcp_message_t *pfcp_message = NULL;
    ogs_pfcp_association_setup_response_t *rsp = NULL;
    ogs_pkbuf_t *pkbuf = NULL;

    ogs_pfcp_node_id_t node_id;
    int node_id_len = 0;

    ogs_gtpu_resource_t *resource = NULL;
    char infobuf[OGS_MAX_NUM_OF_GTPU_RESOURCE]
                [OGS_MAX_USER_PLANE_IP_RESOURCE_INFO_LEN];
    int i = 0, rv;

    ogs_debug("Association Setup Response");

    pfcp_message = ogs_calloc(1, sizeof(*pfcp_message));
    if (!pfcp_message) {
        ogs_error("ogs_calloc() failed");
        return NULL;
    }

    rsp = &pfcp_message->pfcp_association_setup_response;

    rv = ogs_pfcp_sockaddr_to_node_id(&node_id, &node_id_len);
    if (rv != OGS_OK) {
        ogs_error("ogs_pfcp_sockaddr_to_node_id() failed");
        ogs_free(pfcp_message);
        return NULL;
    }
    rsp->node_id.presence = 1;
    rsp->node_id.data = &node_id;
    rsp->node_id.len = node_id_len;

    rsp->cause.presence = 1;
    rsp->cause.u8 = cause;

    rsp->recovery_time_stamp.presence = 1;
    rsp->recovery_time_stamp.u32 = ogs_pfcp_self()->local_recovery;

    ogs_assert(ogs_pfcp_self()->up_function_features_len);
    rsp->up_function_features.presence = 1;
    rsp->up_function_features.data = &ogs_pfcp_self()->up_function_features;
    rsp->up_function_features.len = ogs_pfcp_self()->up_function_features_len;

    if (ogs_pfcp_self()->up_function_features.ftup == 0) {
        i = 0;
        ogs_list_for_each(&ogs_gtp_self()->gtpu_resource_list, resource) {
            ogs_assert(i < OGS_MAX_NUM_OF_GTPU_RESOURCE);
            ogs_pfcp_tlv_user_plane_ip_resource_information_t *message =
                &rsp->user_plane_ip_resource_information[i];
            ogs_assert(message);

            message->presence = 1;
            ogs_pfcp_build_user_plane_ip_resource_info(
                message, &resource->info, infobuf[i],
                OGS_MAX_USER_PLANE_IP_RESOURCE_INFO_LEN);
            i++;
        }
    }

    pfcp_message->h.type = type;
    pkbuf = ogs_pfcp_build_msg(pfcp_message);
    ogs_expect(pkbuf);

    ogs_free(pfcp_message);

    return pkbuf;
}

static struct {
    ogs_pfcp_f_teid_t f_teid;
    char dnn[OGS_MAX_DNN_LEN+1];
    char *sdf_filter[OGS_MAX_NUM_OF_FLOW_IN_PDR];
} pdrbuf[OGS_MAX_NUM_OF_PDR];

void ogs_pfcp_pdrbuf_init(void)
{
    memset(pdrbuf, 0, sizeof(pdrbuf));
}

void ogs_pfcp_pdrbuf_clear(void)
{
    int i, j;
    for (i = 0; i < OGS_MAX_NUM_OF_PDR; i++) {
        for (j = 0; j < OGS_MAX_NUM_OF_FLOW_IN_PDR; j++) {
            if (pdrbuf[i].sdf_filter[j])
                ogs_free(pdrbuf[i].sdf_filter[j]);
        }
    }
}

void ogs_pfcp_build_create_pdr(
    ogs_pfcp_tlv_create_pdr_t *message, int i, ogs_pfcp_pdr_t *pdr)
{
    ogs_pfcp_far_t *far = NULL;
    ogs_pfcp_sdf_filter_t pfcp_sdf_filter[OGS_MAX_NUM_OF_FLOW_IN_PDR];
    int j = 0;
    int len = 0;

    ogs_assert(message);

    ogs_assert(pdr);

    far = pdr->far;
    ogs_assert(far);

    message->presence = 1;
    message->pdr_id.presence = 1;
    message->pdr_id.u16 = pdr->id;

    if (pdr->precedence) { /* No precedence in Sxa */
        message->precedence.presence = 1;
        message->precedence.u32 = pdr->precedence;
    }

    message->pdi.presence = 1;
    message->pdi.source_interface.presence = 1;
    message->pdi.source_interface.u8 = pdr->src_if;

    if (pdr->src_if_type_presence) {
        message->pdi.source_interface_type.presence = 1;
        message->pdi.source_interface_type.u8 = pdr->src_if_type;
    }

    if (pdr->dnn) {
        message->pdi.network_instance.presence = 1;
        message->pdi.network_instance.len = ogs_fqdn_build(
            pdrbuf[i].dnn, pdr->dnn, strlen(pdr->dnn));
        message->pdi.network_instance.data = pdrbuf[i].dnn;
    }

    memset(pfcp_sdf_filter, 0, sizeof(pfcp_sdf_filter));
    for (j = 0; j < pdr->num_of_flow && j < OGS_MAX_NUM_OF_FLOW_IN_PDR; j++) {
        ogs_assert(pdr->flow[j].fd || pdr->flow[j].bid);

        if (pdr->flow[j].fd) {
            pfcp_sdf_filter[j].fd = 1;
            pfcp_sdf_filter[j].flow_description_len =
                    strlen(pdr->flow[j].description);
            pfcp_sdf_filter[j].flow_description = pdr->flow[j].description;
        }
        if (pdr->flow[j].bid) {
            pfcp_sdf_filter[j].bid = 1;
            pfcp_sdf_filter[j].sdf_filter_id = pdr->flow[j].sdf_filter_id;
        }

        len = sizeof(ogs_pfcp_sdf_filter_t) +
                pfcp_sdf_filter[j].flow_description_len;

        message->pdi.sdf_filter[j].presence = 1;
        pdrbuf[i].sdf_filter[j] = ogs_calloc(1, len);
        ogs_assert(pdrbuf[i].sdf_filter[j]);
        ogs_pfcp_build_sdf_filter(&message->pdi.sdf_filter[j],
                &pfcp_sdf_filter[j], pdrbuf[i].sdf_filter[j], len);
    }

    if (pdr->ue_ip_addr_len) {
        message->pdi.ue_ip_address.presence = 1;
        message->pdi.ue_ip_address.data = &pdr->ue_ip_addr;
        message->pdi.ue_ip_address.len = pdr->ue_ip_addr_len;
    }

    for (j = 0; j < OGS_MAX_NUM_OF_FRAMED_ROUTES_IN_PDI; j++) {
        if (!pdr->ipv4_framed_routes || !pdr->ipv4_framed_routes[j])
            break;
        message->pdi.framed_route[j].presence = 1;
        message->pdi.framed_route[j].data = pdr->ipv4_framed_routes[j];
        message->pdi.framed_route[j].len = strlen(pdr->ipv4_framed_routes[j]);
    }

    for (j = 0; j < OGS_MAX_NUM_OF_FRAMED_ROUTES_IN_PDI; j++) {
        if (!pdr->ipv6_framed_routes || !pdr->ipv6_framed_routes[j])
            break;
        message->pdi.framed_ipv6_route[j].presence = 1;
        message->pdi.framed_ipv6_route[j].data = pdr->ipv6_framed_routes[j];
        message->pdi.framed_ipv6_route[j].len = strlen(pdr->ipv6_framed_routes[j]);
    }

    if (pdr->f_teid_len) {
        memcpy(&pdrbuf[i].f_teid, &pdr->f_teid, pdr->f_teid_len);
        pdrbuf[i].f_teid.teid = htobe32(pdr->f_teid.teid);

        message->pdi.local_f_teid.presence = 1;
        message->pdi.local_f_teid.data = &pdrbuf[i].f_teid;
        message->pdi.local_f_teid.len = pdr->f_teid_len;
    }

    if (pdr->qfi) {
        message->pdi.qfi.presence = 1;
        message->pdi.qfi.u8 = pdr->qfi;
    }

    if (pdr->outer_header_removal_len) {
        message->outer_header_removal.presence = 1;
        message->outer_header_removal.data = &pdr->outer_header_removal;
        message->outer_header_removal.len = pdr->outer_header_removal_len;
    }

    if (pdr->far) {
        message->far_id.presence = 1;
        message->far_id.u32 = pdr->far->id;
    }

    ogs_assert(pdr->num_of_urr <= OGS_ARRAY_SIZE(message->urr_id));
    for (i = 0; i < pdr->num_of_urr; i++) {
        message->urr_id[i].presence = 1;
        message->urr_id[i].u32 = pdr->urr[i]->id;
    }

    if (pdr->qer) {
        message->qer_id.presence = 1;
        message->qer_id.u32 = pdr->qer->id;
    }
}

bool ogs_pfcp_build_created_pdr(
    ogs_pfcp_tlv_created_pdr_t *message, int i, ogs_pfcp_pdr_t *pdr)
{
    bool pdr_presence = false;

    ogs_assert(message);

    ogs_assert(pdr);

    if (pdr->f_teid_len) {
        memcpy(&pdrbuf[i].f_teid, &pdr->f_teid, pdr->f_teid_len);
        pdrbuf[i].f_teid.teid = htobe32(pdr->f_teid.teid);

        message->local_f_teid.presence = 1;
        message->local_f_teid.data = &pdrbuf[i].f_teid;
        message->local_f_teid.len = pdr->f_teid_len;

        pdr_presence = true;
    }

    if (pdr_presence == true) {
        message->presence = 1;
        message->pdr_id.presence = 1;
        message->pdr_id.u16 = pdr->id;
    }

    return pdr_presence;
}

void ogs_pfcp_build_update_pdr(
    ogs_pfcp_tlv_update_pdr_t *message, int i,
    ogs_pfcp_pdr_t *pdr, uint64_t modify_flags)
{
    ogs_pfcp_sdf_filter_t pfcp_sdf_filter[OGS_MAX_NUM_OF_FLOW_IN_PDR];
    int j = 0;
    int len = 0;

    ogs_assert(message);
    ogs_assert(pdr);

    ogs_assert(modify_flags &
            (OGS_PFCP_MODIFY_TFT_NEW|OGS_PFCP_MODIFY_TFT_ADD|
             OGS_PFCP_MODIFY_TFT_REPLACE|OGS_PFCP_MODIFY_TFT_DELETE|
             OGS_PFCP_MODIFY_EPC_TFT_UPDATE|
             OGS_PFCP_MODIFY_OUTER_HEADER_REMOVAL));

    message->presence = 1;
    message->pdr_id.presence = 1;
    message->pdr_id.u16 = pdr->id;

    if (modify_flags &
            (OGS_PFCP_MODIFY_TFT_NEW|OGS_PFCP_MODIFY_TFT_ADD|
             OGS_PFCP_MODIFY_TFT_REPLACE|OGS_PFCP_MODIFY_TFT_DELETE|
             OGS_PFCP_MODIFY_EPC_TFT_UPDATE)) {
        message->pdi.presence = 1;
        message->pdi.source_interface.presence = 1;
        message->pdi.source_interface.u8 = pdr->src_if;

        if (pdr->src_if_type_presence) {
            message->pdi.source_interface_type.presence = 1;
            message->pdi.source_interface_type.u8 = pdr->src_if_type;
        }

        memset(pfcp_sdf_filter, 0, sizeof(pfcp_sdf_filter));
        for (j = 0; j < pdr->num_of_flow && j < OGS_MAX_NUM_OF_FLOW_IN_PDR; j++) {
            ogs_assert(pdr->flow[j].fd || pdr->flow[j].bid);

            if (pdr->flow[j].fd) {
                pfcp_sdf_filter[j].fd = 1;
                pfcp_sdf_filter[j].flow_description_len =
                        strlen(pdr->flow[j].description);
                pfcp_sdf_filter[j].flow_description = pdr->flow[j].description;
            }
            if (pdr->flow[j].bid) {
                pfcp_sdf_filter[j].bid = 1;
                pfcp_sdf_filter[j].sdf_filter_id = pdr->flow[j].sdf_filter_id;
            }

            len = sizeof(ogs_pfcp_sdf_filter_t) +
                    pfcp_sdf_filter[j].flow_description_len;

            message->pdi.sdf_filter[j].presence = 1;
            pdrbuf[i].sdf_filter[j] = ogs_calloc(1, len);
            ogs_assert(pdrbuf[i].sdf_filter[j]);
            ogs_pfcp_build_sdf_filter(&message->pdi.sdf_filter[j],
                    &pfcp_sdf_filter[j], pdrbuf[i].sdf_filter[j], len);
        }
    }
    if (modify_flags & OGS_PFCP_MODIFY_OUTER_HEADER_REMOVAL) {
        if (pdr->outer_header_removal_len) {
            message->outer_header_removal.presence = 1;
            message->outer_header_removal.data = &pdr->outer_header_removal;
            message->outer_header_removal.len = pdr->outer_header_removal_len;
        }
    }
}

static struct {
    ogs_pfcp_outer_header_creation_t outer_header_creation;
    char dnn[OGS_MAX_DNN_LEN+1];
} farbuf[OGS_MAX_NUM_OF_FAR];

void ogs_pfcp_build_create_far(
    ogs_pfcp_tlv_create_far_t *message, int i, ogs_pfcp_far_t *far)
{
    ogs_pfcp_sess_t *sess = NULL;

    ogs_assert(message);
    ogs_assert(far);
    sess = far->sess;
    ogs_assert(sess);

    message->presence = 1;
    message->far_id.presence = 1;
    message->far_id.u32 = far->id;

    message->apply_action.presence = 1;
    message->apply_action.u16 = far->apply_action;

    if (far->apply_action & OGS_PFCP_APPLY_ACTION_FORW) {
        message->forwarding_parameters.presence = 1;
        message->forwarding_parameters.destination_interface.presence = 1;
        message->forwarding_parameters.destination_interface.u8 =
            far->dst_if;

        if (far->dst_if_type_presence) {
            message->forwarding_parameters.destination_interface_type.
                presence = 1;
            message->forwarding_parameters.destination_interface_type.
                u8 = far->dst_if_type;
        }

        if (far->dnn) {
            message->forwarding_parameters.network_instance.presence = 1;
            message->forwarding_parameters.network_instance.len =
                ogs_fqdn_build(farbuf[i].dnn, far->dnn, strlen(far->dnn));
            message->forwarding_parameters.network_instance.data =
                farbuf[i].dnn;
        }

        if (far->outer_header_creation_len) {
            memcpy(&farbuf[i].outer_header_creation,
                &far->outer_header_creation, far->outer_header_creation_len);
            farbuf[i].outer_header_creation.teid =
                    htobe32(far->outer_header_creation.teid);

            message->forwarding_parameters.outer_header_creation.presence = 1;
            message->forwarding_parameters.outer_header_creation.data =
                    &farbuf[i].outer_header_creation;
            message->forwarding_parameters.outer_header_creation.len =
                    far->outer_header_creation_len;
        }
    } else if (far->apply_action & OGS_PFCP_APPLY_ACTION_BUFF) {
        ogs_assert(sess->bar);
        message->bar_id.presence = 1;
        message->bar_id.u8 = sess->bar->id;
    }
}

void ogs_pfcp_build_update_far_deactivate(
        ogs_pfcp_tlv_update_far_t *message, int i, ogs_pfcp_far_t *far)
{
    ogs_pfcp_sess_t *sess = NULL;

    ogs_assert(message);
    ogs_assert(far);
    sess = far->sess;
    ogs_assert(sess);

    message->presence = 1;
    message->far_id.presence = 1;
    message->far_id.u32 = far->id;

    far->apply_action =
        OGS_PFCP_APPLY_ACTION_BUFF | OGS_PFCP_APPLY_ACTION_NOCP;
    message->apply_action.presence = 1;
    message->apply_action.u16 = far->apply_action;

    ogs_assert(sess->bar);
    message->bar_id.presence = 1;
    message->bar_id.u8 = sess->bar->id;
}

void ogs_pfcp_build_update_far_activate(
        ogs_pfcp_tlv_update_far_t *message, int i, ogs_pfcp_far_t *far)
{
    ogs_assert(message);
    ogs_assert(far);

    message->presence = 1;
    message->far_id.presence = 1;
    message->far_id.u32 = far->id;

    ogs_assert(far->apply_action & OGS_PFCP_APPLY_ACTION_FORW);

    message->apply_action.presence = 1;
    message->apply_action.u16 = far->apply_action;

    message->update_forwarding_parameters.presence = 1;
    message->update_forwarding_parameters.destination_interface.presence = 1;
    message->update_forwarding_parameters.
        destination_interface.u8 = far->dst_if;

    if (far->dst_if_type_presence) {
        message->update_forwarding_parameters.destination_interface_type.
            presence = 1;
        message->update_forwarding_parameters.destination_interface_type.
            u8 = far->dst_if_type;
    }

    if (far->dnn) {
        message->update_forwarding_parameters.network_instance.presence = 1;
        message->update_forwarding_parameters.network_instance.len =
            ogs_fqdn_build(farbuf[i].dnn, far->dnn, strlen(far->dnn));
        message->update_forwarding_parameters.network_instance.data =
            farbuf[i].dnn;
    }

    if (far->outer_header_creation_len || far->smreq_flags.value) {

        if (far->outer_header_creation_len) {
            memcpy(&farbuf[i].outer_header_creation,
                &far->outer_header_creation, far->outer_header_creation_len);
            farbuf[i].outer_header_creation.teid =
                    htobe32(far->outer_header_creation.teid);

            message->update_forwarding_parameters.
                outer_header_creation.presence = 1;
            message->update_forwarding_parameters.
                outer_header_creation.data = &farbuf[i].outer_header_creation;
            message->update_forwarding_parameters.
                outer_header_creation.len = far->outer_header_creation_len;

        }

        if (far->smreq_flags.value) {
            message->update_forwarding_parameters.pfcpsmreq_flags.presence = 1;
            message->update_forwarding_parameters.pfcpsmreq_flags.u8 =
                far->smreq_flags.value;
        }
    }
}

static struct {
    ogs_pfcp_volume_threshold_t vol_threshold;
    ogs_pfcp_volume_quota_t vol_quota;
    ogs_pfcp_dropped_dl_traffic_threshold_t dropped_dl_traffic_threshold;
} urrbuf[OGS_MAX_NUM_OF_URR];

void ogs_pfcp_build_create_urr(
    ogs_pfcp_tlv_create_urr_t *message, int i, ogs_pfcp_urr_t *urr)
{
    ogs_assert(message);
    ogs_assert(urr);

    message->presence = 1;
    message->urr_id.presence = 1;
    message->urr_id.u32 = urr->id;
    message->measurement_method.presence = 1;
    message->measurement_method.u8 = urr->meas_method;
    message->reporting_triggers.presence = 1;
    message->reporting_triggers.u24 = (urr->rep_triggers.reptri_5 << 16)
                                    | (urr->rep_triggers.reptri_6 << 8)
                                    | (urr->rep_triggers.reptri_7);
    if (urr->meas_period) {
        message->measurement_period.presence = 1;
        message->measurement_period.u32 = urr->meas_period;
    }

    if (urr->vol_threshold.flags) {
        message->volume_threshold.presence = 1;
        ogs_pfcp_build_volume(
                &message->volume_threshold, &urr->vol_threshold,
                &urrbuf[i].vol_threshold, sizeof(urrbuf[i].vol_threshold));
    }

    if (urr->vol_quota.flags) {
        message->volume_quota.presence = 1;
        ogs_pfcp_build_volume(
                &message->volume_quota, &urr->vol_quota,
                &urrbuf[i].vol_quota, sizeof(urrbuf[i].vol_quota));
    }

    if (urr->event_threshold) {
        message->event_threshold.presence = 1;
        message->event_threshold.u32 = urr->event_threshold;
    }

    if (urr->event_quota) {
        message->event_quota.presence = 1;
        message->event_quota.u32 = urr->event_quota;
    }

    if (urr->time_threshold) {
        message->time_threshold.presence = 1;
        message->time_threshold.u32 = urr->time_threshold;
    }

    if (urr->time_quota) {
        message->time_quota.presence = 1;
        message->time_quota.u32 = urr->time_quota;
    }

    if (urr->quota_holding_time) {
        message->quota_holding_time.presence = 1;
        message->quota_holding_time.u32 = urr->quota_holding_time;
    }

    if (urr->dropped_dl_traffic_threshold.flags) {
        message->dropped_dl_traffic_threshold.presence = 1;
        ogs_pfcp_build_dropped_dl_traffic_threshold(
                &message->dropped_dl_traffic_threshold,
                &urr->dropped_dl_traffic_threshold,
                &urrbuf[i].dropped_dl_traffic_threshold,
                sizeof(urrbuf[i].dropped_dl_traffic_threshold));
    }

    if (urr->quota_validity_time) {
        message->quota_validity_time.presence = 1;
        message->quota_validity_time.u32 = urr->quota_validity_time;
    }

    if (urr->meas_info.octet5) {
        message->measurement_information.presence = 1;
        message->measurement_information.data = &urr->meas_info.octet5;
        message->measurement_information.len = 1;
    }
}

void ogs_pfcp_build_update_urr(
    ogs_pfcp_tlv_update_urr_t *message, int i, ogs_pfcp_urr_t *urr, uint64_t modify_flags)
{
    ogs_assert(message);
    ogs_assert(urr);

    /* No change requested, skip. */
    if (!(modify_flags & (OGS_PFCP_MODIFY_URR_MEAS_METHOD|
                          OGS_PFCP_MODIFY_URR_REPORT_TRIGGER|
                          OGS_PFCP_MODIFY_URR_VOLUME_THRESH|
                          OGS_PFCP_MODIFY_URR_VOLUME_QUOTA|
                          OGS_PFCP_MODIFY_URR_TIME_THRESH|
                          OGS_PFCP_MODIFY_URR_TIME_QUOTA|
                          OGS_PFCP_MODIFY_URR_QUOTA_VALIDITY_TIME)))
        return;

    /* Change request: Send only changed IEs */
    message->presence = 1;
    message->urr_id.presence = 1;
    message->urr_id.u32 = urr->id;

    if (modify_flags & OGS_PFCP_MODIFY_URR_MEAS_METHOD) {
        message->measurement_method.presence = 1;
        message->measurement_method.u8 = urr->meas_method;
    }

    if (modify_flags & OGS_PFCP_MODIFY_URR_REPORT_TRIGGER) {
        message->reporting_triggers.presence = 1;
        message->reporting_triggers.u24 = (urr->rep_triggers.reptri_5 << 16)
                                        | (urr->rep_triggers.reptri_6 << 8)
                                        | (urr->rep_triggers.reptri_7);
    }

    if (modify_flags & OGS_PFCP_MODIFY_URR_VOLUME_THRESH) {
        if (urr->vol_threshold.flags) {
            message->volume_threshold.presence = 1;
            ogs_pfcp_build_volume(
                    &message->volume_threshold, &urr->vol_threshold,
                    &urrbuf[i].vol_threshold, sizeof(urrbuf[i].vol_threshold));
        }
    }

    if (modify_flags & OGS_PFCP_MODIFY_URR_VOLUME_QUOTA) {
        if (urr->vol_quota.flags) {
            message->volume_quota.presence = 1;
            ogs_pfcp_build_volume(
                    &message->volume_quota, &urr->vol_quota,
                    &urrbuf[i].vol_quota, sizeof(urrbuf[i].vol_quota));
        }
    }

    if (modify_flags & OGS_PFCP_MODIFY_URR_TIME_THRESH) {
        if (urr->time_threshold) {
            message->time_threshold.presence = 1;
            message->time_threshold.u32 = urr->time_threshold;
        }
    }

    if (modify_flags & OGS_PFCP_MODIFY_URR_TIME_QUOTA) {
        if (urr->time_quota) {
            message->time_quota.presence = 1;
            message->time_quota.u32 = urr->time_quota;
        }
    }

    if (modify_flags & OGS_PFCP_MODIFY_URR_QUOTA_VALIDITY_TIME) {
        if (urr->quota_validity_time) {
            message->quota_validity_time.presence = 1;
            message->quota_validity_time.u32 = urr->quota_validity_time;
        }
    }
}

static struct {
    char mbr[OGS_PFCP_BITRATE_LEN];
    char gbr[OGS_PFCP_BITRATE_LEN];
} create_qer_buf[OGS_MAX_NUM_OF_QER], update_qer_buf[OGS_MAX_NUM_OF_QER];

void ogs_pfcp_build_create_qer(
    ogs_pfcp_tlv_create_qer_t *message, int i, ogs_pfcp_qer_t *qer)
{
    ogs_assert(message);
    ogs_assert(qer);

    message->presence = 1;
    message->qer_id.presence = 1;
    message->qer_id.u32 = qer->id;

    message->gate_status.presence = 1;
    message->gate_status.u8 = qer->gate_status.value;

    if (qer->mbr.uplink || qer->mbr.downlink) {
        message->maximum_bitrate.presence = 1;
        ogs_pfcp_build_bitrate(
                &message->maximum_bitrate,
                &qer->mbr, create_qer_buf[i].mbr, OGS_PFCP_BITRATE_LEN);
    }
    if (qer->gbr.uplink || qer->gbr.downlink) {
        message->guaranteed_bitrate.presence = 1;
        ogs_pfcp_build_bitrate(
                &message->guaranteed_bitrate,
                &qer->gbr, create_qer_buf[i].gbr, OGS_PFCP_BITRATE_LEN);
    }

    if (qer->qfi) {
        message->qos_flow_identifier.presence = 1;
        message->qos_flow_identifier.u8 = qer->qfi;
    }
}

void ogs_pfcp_build_update_qer(
    ogs_pfcp_tlv_update_qer_t *message, int i, ogs_pfcp_qer_t *qer)
{
    ogs_assert(message);
    ogs_assert(qer);

    message->presence = 1;
    message->qer_id.presence = 1;
    message->qer_id.u32 = qer->id;

    if (qer->mbr.uplink || qer->mbr.downlink) {
        message->maximum_bitrate.presence = 1;
        ogs_pfcp_build_bitrate(
                &message->maximum_bitrate,
                &qer->mbr, update_qer_buf[i].mbr, OGS_PFCP_BITRATE_LEN);
    }
    if (qer->gbr.uplink || qer->gbr.downlink) {
        message->guaranteed_bitrate.presence = 1;
        ogs_pfcp_build_bitrate(
                &message->guaranteed_bitrate,
                &qer->gbr, update_qer_buf[i].gbr, OGS_PFCP_BITRATE_LEN);
    }
}

void ogs_pfcp_build_create_bar(
    ogs_pfcp_tlv_create_bar_t *message, ogs_pfcp_bar_t *bar)
{
    ogs_assert(message);
    ogs_assert(bar);

    message->presence = 1;
    message->bar_id.presence = 1;
    message->bar_id.u8 = bar->id;
}

static struct {
    ogs_pfcp_volume_measurement_t vol_meas;
} usage_report_buf;

ogs_pkbuf_t *ogs_pfcp_build_session_report_request(
        uint8_t type, ogs_pfcp_user_plane_report_t *report)
{
    ogs_pfcp_message_t *pfcp_message = NULL;
    ogs_pfcp_session_report_request_t *req = NULL;
    ogs_pkbuf_t *pkbuf = NULL;
    ogs_pfcp_downlink_data_service_information_t info;
    unsigned int i;

    ogs_assert(report);

    ogs_debug("PFCP session report request");

    pfcp_message = ogs_calloc(1, sizeof(*pfcp_message));
    if (!pfcp_message) {
        ogs_error("ogs_calloc() failed");
        return NULL;
    }

    req = &pfcp_message->pfcp_session_report_request;

    req->report_type.presence = 1;
    req->report_type.u8 = report->type.value;

    if (report->type.downlink_data_report) {
        int info_len = 0;

        req->downlink_data_report.presence = 1;
        req->downlink_data_report.pdr_id.presence = 1;
        req->downlink_data_report.pdr_id.u16 = report->downlink_data.pdr_id;

        memset(&info, 0, sizeof(info));
        if (report->downlink_data.qfi &&
                report->downlink_data.paging_policy_indication_value) {

            info_len = 3;

            info.qfii = 1;
            info.qfi = report->downlink_data.qfi;
            info.ppi = 1;
            info.paging_policy_indication_value =
                report->downlink_data.paging_policy_indication_value;

        } else if (report->downlink_data.qfi) {

            info_len = 2;

            info.qfii = 1;
            info.qfi = report->downlink_data.qfi;
        } else if (report->downlink_data.paging_policy_indication_value) {

            info_len = 2;

            info.ppi = 1;
            info.paging_policy_indication_value =
                report->downlink_data.paging_policy_indication_value;
        }

        if (info_len) {
            req->downlink_data_report.
                downlink_data_service_information.presence = 1;
            req->downlink_data_report.
                downlink_data_service_information.data = &info;
            req->downlink_data_report.
                downlink_data_service_information.len = info_len;
        }
    }

    if (report->type.usage_report) {
        ogs_assert(report->num_of_usage_report > 0);
        for (i = 0; i < report->num_of_usage_report; i++) {
            req->usage_report[i].presence = 1;
            req->usage_report[i].urr_id.presence = 1;
            req->usage_report[i].urr_id.u32 = report->usage_report[i].id;
            req->usage_report[i].ur_seqn.presence = 1;
            req->usage_report[i].ur_seqn.u32 = report->usage_report[i].seqn;
            req->usage_report[i].usage_report_trigger.presence = 1;
            req->usage_report[i].usage_report_trigger.u24 =
                (report->usage_report[i].rep_trigger.reptri_5 << 16)
                | (report->usage_report[i].rep_trigger.reptri_6 << 8)
                | (report->usage_report[i].rep_trigger.reptri_7);

            if (report->usage_report[i].start_time) {
                req->usage_report[i].start_time.presence = 1;
                req->usage_report[i].start_time.u32 = report->usage_report[i].start_time;
            }

            if (report->usage_report[i].end_time) {
                req->usage_report[i].end_time.presence = 1;
                req->usage_report[i].end_time.u32 = report->usage_report[i].end_time;
            }

            if (report->usage_report[i].vol_measurement.flags) {
                req->usage_report[i].volume_measurement.presence = 1;
                ogs_pfcp_build_volume_measurement(
                        &req->usage_report[i].volume_measurement,
                        &report->usage_report[i].vol_measurement,
                        &usage_report_buf.vol_meas,
                        sizeof(usage_report_buf.vol_meas));
            }

            if (report->usage_report[i].dur_measurement) {
                req->usage_report[i].duration_measurement.presence = 1;
                req->usage_report[i].duration_measurement.u32 =
                    report->usage_report[i].dur_measurement;
            }

            if (report->usage_report[i].time_of_first_packet) {
                req->usage_report[i].time_of_first_packet.presence = 1;
                req->usage_report[i].time_of_first_packet.u32 =
                    report->usage_report[i].time_of_first_packet;
            }

            if (report->usage_report[i].time_of_last_packet) {
                req->usage_report[i].time_of_last_packet.presence = 1;
                req->usage_report[i].time_of_last_packet.u32 =
                    report->usage_report[i].time_of_last_packet;
            }
        }
    }

    if (report->error_indication.remote_f_teid_len) {
        req->error_indication_report.presence = 1;
        req->error_indication_report.remote_f_teid.presence = 1;
        req->error_indication_report.remote_f_teid.data =
            &report->error_indication.remote_f_teid;
        req->error_indication_report.remote_f_teid.len =
            report->error_indication.remote_f_teid_len;
    }

    pfcp_message->h.type = type;
    pkbuf = ogs_pfcp_build_msg(pfcp_message);
    ogs_expect(pkbuf);

    ogs_free(pfcp_message);

    return pkbuf;
}

ogs_pkbuf_t *ogs_pfcp_build_session_report_response(
        uint8_t type, uint8_t cause)
{
    ogs_pfcp_message_t *pfcp_message = NULL;
    ogs_pfcp_session_report_response_t *rsp = NULL;
    ogs_pkbuf_t *pkbuf = NULL;

    ogs_debug("PFCP session report response");

    pfcp_message = ogs_calloc(1, sizeof(*pfcp_message));
    if (!pfcp_message) {
        ogs_error("ogs_calloc() failed");
        return NULL;
    }

    rsp = &pfcp_message->pfcp_session_report_response;

    rsp->cause.presence = 1;
    rsp->cause.u8 = cause;

    pfcp_message->h.type = type;
    pkbuf = ogs_pfcp_build_msg(pfcp_message);
    ogs_expect(pkbuf);

    ogs_free(pfcp_message);

    return pkbuf;
}

ogs_pkbuf_t *ogs_pfcp_build_session_deletion_response( uint8_t type, uint8_t cause,
        ogs_pfcp_user_plane_report_t *report)
{
    ogs_pfcp_message_t *pfcp_message = NULL;
    ogs_pfcp_session_deletion_response_t *rsp = NULL;
    ogs_pkbuf_t *pkbuf = NULL;
    unsigned int i;

    ogs_debug("PFCP session deletion response");

    pfcp_message = ogs_calloc(1, sizeof(*pfcp_message));
    if (!pfcp_message) {
        ogs_error("ogs_calloc() failed");
        return NULL;
    }

    rsp = &pfcp_message->pfcp_session_deletion_response;

    rsp->cause.presence = 1;
    rsp->cause.u8 = cause;

    if (report->type.usage_report) {
        ogs_assert(report->num_of_usage_report > 0);
        for (i = 0; i < report->num_of_usage_report; i++) {
            rsp->usage_report[i].presence = 1;
            rsp->usage_report[i].urr_id.presence = 1;
            rsp->usage_report[i].urr_id.u32 = report->usage_report[i].id;
            rsp->usage_report[i].ur_seqn.presence = 1;
            rsp->usage_report[i].ur_seqn.u32 = report->usage_report[i].seqn;
            rsp->usage_report[i].usage_report_trigger.presence = 1;
            rsp->usage_report[i].usage_report_trigger.u24 =
                (report->usage_report[i].rep_trigger.reptri_5 << 16)
                | (report->usage_report[i].rep_trigger.reptri_6 << 8)
                | (report->usage_report[i].rep_trigger.reptri_7);

            if (report->usage_report[i].start_time) {
                rsp->usage_report[i].start_time.presence = 1;
                rsp->usage_report[i].start_time.u32 = report->usage_report[i].start_time;
            }

            if (report->usage_report[i].end_time) {
                rsp->usage_report[i].end_time.presence = 1;
                rsp->usage_report[i].end_time.u32 = report->usage_report[i].end_time;
            }

            if (report->usage_report[i].vol_measurement.flags) {
                rsp->usage_report[i].volume_measurement.presence = 1;
                ogs_pfcp_build_volume_measurement(
                        &rsp->usage_report[i].volume_measurement,
                        &report->usage_report[i].vol_measurement,
                        &usage_report_buf.vol_meas,
                        sizeof(usage_report_buf.vol_meas));
            }

            rsp->usage_report[i].duration_measurement.presence = 1;
            rsp->usage_report[i].duration_measurement.u32 =
                report->usage_report[i].dur_measurement;

            if (report->usage_report[i].time_of_first_packet) {
                rsp->usage_report[i].time_of_first_packet.presence = 1;
                rsp->usage_report[i].time_of_first_packet.u32 =
                    report->usage_report[i].time_of_first_packet;
            }

            if (report->usage_report[i].time_of_last_packet) {
                rsp->usage_report[i].time_of_last_packet.presence = 1;
                rsp->usage_report[i].time_of_last_packet.u32 =
                    report->usage_report[i].time_of_last_packet;
            }
        }
    }
    pfcp_message->h.type = type;
    pkbuf = ogs_pfcp_build_msg(pfcp_message);
    ogs_expect(pkbuf);

    ogs_free(pfcp_message);

    return pkbuf;
}
===== build.h =====

#ifndef OGS_PFCP_BUILD_H
#define OGS_PFCP_BUILD_H

#ifdef __cplusplus
extern "C" {
#endif

ogs_pkbuf_t *ogs_pfcp_build_heartbeat_request(uint8_t type);
ogs_pkbuf_t *ogs_pfcp_build_heartbeat_response(uint8_t type);

ogs_pkbuf_t *ogs_pfcp_cp_build_association_setup_request(uint8_t type);
ogs_pkbuf_t *ogs_pfcp_cp_build_association_setup_response(uint8_t type,
        uint8_t cause);

ogs_pkbuf_t *ogs_pfcp_up_build_association_setup_request(uint8_t type);
ogs_pkbuf_t *ogs_pfcp_up_build_association_setup_response(uint8_t type,
        uint8_t cause);

void ogs_pfcp_pdrbuf_init(void);
void ogs_pfcp_pdrbuf_clear(void);

void ogs_pfcp_build_create_pdr(
    ogs_pfcp_tlv_create_pdr_t *message, int i, ogs_pfcp_pdr_t *pdr);
bool ogs_pfcp_build_created_pdr(
    ogs_pfcp_tlv_created_pdr_t *message, int i, ogs_pfcp_pdr_t *pdr);
void ogs_pfcp_build_update_pdr(
    ogs_pfcp_tlv_update_pdr_t *message, int i,
    ogs_pfcp_pdr_t *pdr, uint64_t modify_flags);

void ogs_pfcp_build_create_far(
    ogs_pfcp_tlv_create_far_t *message, int i, ogs_pfcp_far_t *far);
void ogs_pfcp_build_update_far_deactivate(
    ogs_pfcp_tlv_update_far_t *message, int i, ogs_pfcp_far_t *far);
void ogs_pfcp_build_update_far_activate(
    ogs_pfcp_tlv_update_far_t *message, int i, ogs_pfcp_far_t *far);

void ogs_pfcp_build_create_qer(
    ogs_pfcp_tlv_create_qer_t *message, int i, ogs_pfcp_qer_t *qer);
void ogs_pfcp_build_update_qer(
    ogs_pfcp_tlv_update_qer_t *message, int i, ogs_pfcp_qer_t *qer);

void ogs_pfcp_build_create_urr(
    ogs_pfcp_tlv_create_urr_t *message, int i, ogs_pfcp_urr_t *urr);
void ogs_pfcp_build_update_urr(
    ogs_pfcp_tlv_update_urr_t *message, int i, ogs_pfcp_urr_t *urr, uint64_t modify_flags);

void ogs_pfcp_build_create_bar(
    ogs_pfcp_tlv_create_bar_t *message, ogs_pfcp_bar_t *bar);

ogs_pkbuf_t *ogs_pfcp_build_session_report_request(
        uint8_t type, ogs_pfcp_user_plane_report_t *report);
ogs_pkbuf_t *ogs_pfcp_build_session_report_response(
        uint8_t type, uint8_t cause);

ogs_pkbuf_t *ogs_pfcp_build_session_deletion_response( uint8_t type, uint8_t cause,
        ogs_pfcp_user_plane_report_t *report);


#ifdef __cplusplus
}
#endif

#endif /* OGS_PFCP_BUILD_H */
===== context.c =====

#include "app/ogs-app.h"
#include "ogs-pfcp.h"

int __ogs_pfcp_domain;
static ogs_pfcp_context_t self;
static int context_initialized = 0;

static OGS_POOL(ogs_pfcp_node_pool, ogs_pfcp_node_t);

static OGS_POOL(ogs_pfcp_far_pool, ogs_pfcp_far_t);
static OGS_POOL(ogs_pfcp_urr_pool, ogs_pfcp_urr_t);
static OGS_POOL(ogs_pfcp_qer_pool, ogs_pfcp_qer_t);
static OGS_POOL(ogs_pfcp_bar_pool, ogs_pfcp_bar_t);

static OGS_POOL(ogs_pfcp_pdr_pool, ogs_pfcp_pdr_t);
static OGS_POOL(ogs_pfcp_pdr_teid_pool, ogs_pool_id_t);
static ogs_pool_id_t *pdr_random_to_index;

static OGS_POOL(ogs_pfcp_rule_pool, ogs_pfcp_rule_t);

static OGS_POOL(ogs_pfcp_dev_pool, ogs_pfcp_dev_t);
static OGS_POOL(ogs_pfcp_subnet_pool, ogs_pfcp_subnet_t);

void ogs_pfcp_context_init(void)
{
    int i;
    ogs_assert(context_initialized == 0);

    /* Initialize SMF context */
    memset(&self, 0, sizeof(ogs_pfcp_context_t));

    self.local_recovery = ogs_time_ntp32_now();

    ogs_log_install_domain(&__ogs_pfcp_domain, "pfcp", ogs_core()->log.level);

    ogs_pool_init(&ogs_pfcp_node_pool, ogs_app()->pool.nf);

    ogs_pool_init(&ogs_pfcp_far_pool,
            ogs_app()->pool.sess * OGS_MAX_NUM_OF_FAR);
    ogs_pool_init(&ogs_pfcp_urr_pool,
            ogs_app()->pool.sess * OGS_MAX_NUM_OF_URR);
    ogs_pool_init(&ogs_pfcp_qer_pool,
            ogs_app()->pool.sess * OGS_MAX_NUM_OF_QER);
    ogs_pool_init(&ogs_pfcp_bar_pool,
            ogs_app()->pool.sess * OGS_MAX_NUM_OF_BAR);

    ogs_pool_init(&ogs_pfcp_pdr_pool,
            ogs_app()->pool.sess * OGS_MAX_NUM_OF_PDR);
    ogs_pool_init(&ogs_pfcp_pdr_teid_pool, ogs_pfcp_pdr_pool.size);
    ogs_pool_random_id_generate(&ogs_pfcp_pdr_teid_pool);

    pdr_random_to_index = ogs_calloc(
            sizeof(ogs_pool_id_t), ogs_pfcp_pdr_pool.size+1);
    ogs_assert(pdr_random_to_index);
    for (i = 0; i < ogs_pfcp_pdr_pool.size; i++)
        pdr_random_to_index[ogs_pfcp_pdr_teid_pool.array[i]] = i;

    ogs_pool_init(&ogs_pfcp_rule_pool,
            ogs_app()->pool.sess *
            OGS_MAX_NUM_OF_PDR * OGS_MAX_NUM_OF_FLOW_IN_PDR);

    ogs_pool_init(&ogs_pfcp_dev_pool, OGS_MAX_NUM_OF_DEV);
    ogs_pool_init(&ogs_pfcp_subnet_pool, OGS_MAX_NUM_OF_SUBNET);

    self.object_teid_hash = ogs_hash_make();
    ogs_assert(self.object_teid_hash);
    self.far_f_teid_hash = ogs_hash_make();
    ogs_assert(self.far_f_teid_hash);
    self.far_teid_hash = ogs_hash_make();
    ogs_assert(self.far_teid_hash);

    context_initialized = 1;
}

void ogs_pfcp_context_final(void)
{
    ogs_assert(context_initialized == 1);

    ogs_assert(self.object_teid_hash);
    ogs_hash_destroy(self.object_teid_hash);
    ogs_assert(self.far_f_teid_hash);
    ogs_hash_destroy(self.far_f_teid_hash);
    ogs_assert(self.far_teid_hash);
    ogs_hash_destroy(self.far_teid_hash);

    ogs_pfcp_dev_remove_all();
    ogs_pfcp_subnet_remove_all();

    ogs_pool_final(&ogs_pfcp_dev_pool);
    ogs_pool_final(&ogs_pfcp_subnet_pool);
    ogs_pool_final(&ogs_pfcp_rule_pool);

    ogs_pool_final(&ogs_pfcp_pdr_pool);
    ogs_pool_final(&ogs_pfcp_pdr_teid_pool);
    ogs_free(pdr_random_to_index);

    ogs_pool_final(&ogs_pfcp_far_pool);
    ogs_pool_final(&ogs_pfcp_urr_pool);
    ogs_pool_final(&ogs_pfcp_qer_pool);
    ogs_pool_final(&ogs_pfcp_bar_pool);

    ogs_pfcp_node_remove_all(&self.pfcp_peer_list);

    ogs_pool_final(&ogs_pfcp_node_pool);

    context_initialized = 0;
}

ogs_pfcp_context_t *ogs_pfcp_self(void)
{
    return &self;
}

static int ogs_pfcp_context_prepare(void)
{
    self.pfcp_port = OGS_PFCP_UDP_PORT;

    self.tun_ifname = "ogstun";

    return OGS_OK;
}

static int ogs_pfcp_check_subnet_overlapping(void)
{
    ogs_pfcp_subnet_t *subnet = NULL;
    ogs_pfcp_subnet_t *next_subnet = NULL;
    char buf1[OGS_ADDRSTRLEN];
    char buf2[OGS_ADDRSTRLEN];
    int rv = OGS_OK;

    ogs_list_for_each(&self.subnet_list, subnet){
        for (next_subnet = ogs_list_next(subnet); (next_subnet);
                next_subnet = ogs_list_next(next_subnet)) {
            if ((strlen(subnet->dnn) == 0 ||
                 strlen(next_subnet->dnn) == 0 ||
                (strcmp(subnet->dnn, next_subnet->dnn)) == 0) &&
                subnet->gw.family == next_subnet->gw.family) {
                uint32_t *addr1 = subnet->sub.sub;
                uint32_t *addr2 = next_subnet->sub.sub;
                uint32_t mask[4];
                int i;
                /* Get smaller subnet mask for IPv4 or IPv6 */
                for (i = 0; i < 4 ; i++) {
                    mask[i] = (subnet->sub.mask[i] & next_subnet->sub.mask[i]);
                }
                /* Compare masked subnets if they overlap */
                if (subnet->gw.family == AF_INET) {
                    if ((addr1[0] & mask[0]) == (addr2[0] & mask[0])) {
                        ogs_error("Overlapping subnets in SMF configuration file: %s/%d and %s/%d",
                                OGS_INET_NTOP(&subnet->gw.sub[0], buf1),
                                subnet->prefixlen,
                                OGS_INET_NTOP(&next_subnet->gw.sub[0], buf2),
                                next_subnet->prefixlen);
                        rv = OGS_ERROR;
                    }
                } else if (subnet->gw.family == AF_INET6) {
                    if (((addr1[0] & mask[0]) == (addr2[0] & mask[0])) &&
                        ((addr1[1] & mask[1]) == (addr2[1] & mask[1])) &&
                        ((addr1[2] & mask[2]) == (addr2[2] & mask[2])) &&
                        ((addr1[3] & mask[3]) == (addr2[3] & mask[3]))) {
                        ogs_error("Overlapping subnets in SMF configuration file: %s/%d and %s/%d",
                                OGS_INET6_NTOP(&subnet->gw.sub[0], buf1),
                                subnet->prefixlen,
                                OGS_INET6_NTOP(&next_subnet->gw.sub[0], buf2),
                                next_subnet->prefixlen);
                        rv = OGS_ERROR;
                    }
                } else {
                    ogs_error("Invalid family in subnet configuration [%d]",
                            subnet->gw.family);
                    rv = OGS_ERROR;
                    ogs_assert_if_reached();
                }
            }
        }
    }

    return rv;
}

static int ogs_pfcp_context_validation(const char *local)
{
    if (ogs_list_first(&self.pfcp_list) == NULL &&
        ogs_list_first(&self.pfcp_list6) == NULL) {
        ogs_error("No %s.pfcp.address: in '%s'", local, ogs_app()->file);
        return OGS_ERROR;
    }
    if (ogs_pfcp_check_subnet_overlapping() != OGS_OK)
        return OGS_ERROR;

    return OGS_OK;
}

int ogs_pfcp_context_parse_config(const char *local, const char *remote)
{
    int rv;
    yaml_document_t *document = NULL;
    ogs_yaml_iter_t root_iter;
    int idx = 0;

    document = ogs_app()->document;
    ogs_assert(document);

    rv = ogs_pfcp_context_prepare();
    if (rv != OGS_OK) return rv;

    ogs_yaml_iter_init(&root_iter, document);
    while (ogs_yaml_iter_next(&root_iter)) {
        const char *root_key = ogs_yaml_iter_key(&root_iter);
        ogs_assert(root_key);
        if ((!strcmp(root_key, local)) &&
            idx++ == ogs_app()->config_section_id) {
            ogs_yaml_iter_t local_iter;
            ogs_yaml_iter_recurse(&root_iter, &local_iter);
            while (ogs_yaml_iter_next(&local_iter)) {
                const char *local_key = ogs_yaml_iter_key(&local_iter);
                ogs_assert(local_key);
                if (!strcmp(local_key, "pfcp")) {
                    ogs_yaml_iter_t pfcp_iter;
                    ogs_yaml_iter_recurse(&local_iter, &pfcp_iter);
                    while (ogs_yaml_iter_next(&pfcp_iter)) {
                        const char *pfcp_key = ogs_yaml_iter_key(&pfcp_iter);
                        ogs_assert(pfcp_key);
                        if (!strcmp(pfcp_key, "server")) {
                            ogs_yaml_iter_t server_iter, server_array;
                            ogs_yaml_iter_recurse(&pfcp_iter, &server_array);
                            do {
                                int family = AF_UNSPEC;
                                int i, num = 0;
                                const char *hostname[OGS_MAX_NUM_OF_HOSTNAME];
                                int num_of_advertise = 0;
                                const char *advertise[OGS_MAX_NUM_OF_HOSTNAME];
                                uint16_t port = self.pfcp_port;
                                const char *dev = NULL;
                                ogs_sockaddr_t *addr = NULL;

                                ogs_sockopt_t option;
                                bool is_option = false;

                                if (ogs_yaml_iter_type(&server_array) ==
                                        YAML_MAPPING_NODE) {
                                    memcpy(&server_iter, &server_array,
                                            sizeof(ogs_yaml_iter_t));
                                } else if (ogs_yaml_iter_type(&server_array) ==
                                    YAML_SEQUENCE_NODE) {
                                    if (!ogs_yaml_iter_next(&server_array))
                                        break;
                                    ogs_yaml_iter_recurse(
                                            &server_array, &server_iter);
                                } else if (ogs_yaml_iter_type(&server_array) ==
                                    YAML_SCALAR_NODE) {
                                    break;
                                } else
                                    ogs_assert_if_reached();

                                while (ogs_yaml_iter_next(&server_iter)) {
                                    const char *server_key =
                                        ogs_yaml_iter_key(&server_iter);
                                    ogs_assert(server_key);
                                    if (!strcmp(server_key, "family")) {
                                        const char *v =
                                            ogs_yaml_iter_value(&server_iter);
                                        if (v) family = atoi(v);
                                        if (family != AF_UNSPEC &&
                                            family != AF_INET &&
                                            family != AF_INET6) {
                                            ogs_warn("Ignore family(%d) : "
                                                "AF_UNSPEC(%d), "
                                                "AF_INET(%d), AF_INET6(%d) ",
                                                family,
                                                AF_UNSPEC, AF_INET, AF_INET6);
                                            family = AF_UNSPEC;
                                        }
                                    } else if (!strcmp(server_key, "address")) {
                                        ogs_yaml_iter_t hostname_iter;
                                        ogs_yaml_iter_recurse(&server_iter,
                                                &hostname_iter);
                                        ogs_assert(ogs_yaml_iter_type(
                                                    &hostname_iter) !=
                                                YAML_MAPPING_NODE);

                                        do {
                                            if (ogs_yaml_iter_type(
                                                        &hostname_iter) ==
                                                    YAML_SEQUENCE_NODE) {
                                                if (!ogs_yaml_iter_next(
                                                            &hostname_iter))
                                                    break;
                                            }

                                            ogs_assert(num <
                                                    OGS_MAX_NUM_OF_HOSTNAME);
                                            hostname[num++] =
                                                ogs_yaml_iter_value(
                                                        &hostname_iter);
                                        } while (ogs_yaml_iter_type(
                                                    &hostname_iter) ==
                                                YAML_SEQUENCE_NODE);
                                    } else if (!strcmp(
                                                server_key, "advertise")) {
                                        ogs_yaml_iter_t hostname_iter;
                                        ogs_yaml_iter_recurse(&server_iter,
                                                &hostname_iter);
                                        ogs_assert(ogs_yaml_iter_type(
                                                    &hostname_iter) !=
                                                YAML_MAPPING_NODE);

                                        do {
                                            if (ogs_yaml_iter_type(
                                                        &hostname_iter) ==
                                                    YAML_SEQUENCE_NODE) {
                                                if (!ogs_yaml_iter_next(
                                                            &hostname_iter))
                                                    break;
                                            }

                                            ogs_assert(num <
                                                    OGS_MAX_NUM_OF_HOSTNAME);
                                            advertise[num_of_advertise++] =
                                                ogs_yaml_iter_value(
                                                        &hostname_iter);
                                        } while (ogs_yaml_iter_type(
                                                    &hostname_iter) ==
                                                YAML_SEQUENCE_NODE);
                                    } else if (!strcmp(server_key, "port")) {
                                        const char *v =
                                            ogs_yaml_iter_value(&server_iter);
                                        if (v) {
                                            port = atoi(v);
                                            self.pfcp_port = port;
                                        }
                                    } else if (!strcmp(server_key, "dev")) {
                                        dev = ogs_yaml_iter_value(&server_iter);
                                    } else if (!strcmp(server_key, "option")) {
                                        rv = ogs_app_parse_sockopt_config(
                                                &server_iter, &option);
                                        if (rv != OGS_OK) {
                                            ogs_error("ogs_app_parse_sockopt_"
                                                    "config() failed");
                                            return rv;
                                        }
                                        is_option = true;
                                    } else if (!strcmp(server_key, "apn") ||
                                                !strcmp(server_key, "dnn")) {
                                        /* Skip */
                                    } else
                                        ogs_warn("unknown key `%s`",
                                                server_key);
                                }

                                /* Add address information */
                                addr = NULL;
                                for (i = 0; i < num; i++) {
                                    rv = ogs_addaddrinfo(&addr,
                                            family, hostname[i], port, 0);
                                    ogs_assert(rv == OGS_OK);
                                }

                                /* Add each address as a separate socknode */
                                if (addr) {
                                    ogs_sockaddr_t *current = addr;
                                    while (current) {
                                        if (current->ogs_sa_family ==
                                                AF_INET &&
                                            ogs_global_conf()->
                                                parameter.no_ipv4 == 0) {
                                            ogs_socknode_add(&self.pfcp_list,
                                                             AF_INET, current,
                                                             is_option ?
                                                             &option : NULL);
                                        }
                                        if (current->ogs_sa_family ==
                                                AF_INET6 &&
                                            ogs_global_conf()->
                                                parameter.no_ipv6 == 0) {
                                            ogs_socknode_add(&self.pfcp_list6,
                                                             AF_INET6, current,
                                                             is_option ?
                                                             &option : NULL);
                                        }
                                        current = current->next;
                                    }
                                    ogs_freeaddrinfo(addr);
                                }

                                /* Process advertise addresses if needed */
                                addr = NULL;
                                for (i = 0; i < num_of_advertise; i++) {
                                    rv = ogs_addaddrinfo(&addr,
                                            family, advertise[i], port, 0);
                                    ogs_assert(rv == OGS_OK);
                                }

                                if (addr) {
                                    if (ogs_global_conf()->
                                            parameter.no_ipv4 == 0 &&
                                        !self.pfcp_advertise) {
                                        ogs_copyaddrinfo(
                                                &self.pfcp_advertise, addr);
                                        ogs_filteraddrinfo(
                                                &self.pfcp_advertise, AF_INET);
                                    }
                                    if (ogs_global_conf()->
                                            parameter.no_ipv6 == 0 &&
                                        !self.pfcp_advertise6) {
                                        ogs_copyaddrinfo(
                                                &self.pfcp_advertise6, addr);
                                        ogs_filteraddrinfo(
                                                &self.pfcp_advertise6,
                                                AF_INET6);
                                    }
                                    ogs_freeaddrinfo(addr);
                                }

                                /* Bind to device if specified */
                                if (dev) {
                                    rv = ogs_socknode_probe(
                                            ogs_global_conf()->
                                            parameter.no_ipv4 ?
                                                NULL : &self.pfcp_list,
                                            ogs_global_conf()->
                                            parameter.no_ipv6 ?
                                                NULL : &self.pfcp_list6,
                                            dev, self.pfcp_port,
                                            is_option ? &option : NULL);
                                    ogs_assert(rv == OGS_OK);
                                }

                            } while (ogs_yaml_iter_type(&server_array) ==
                                    YAML_SEQUENCE_NODE);
                        } else if (!strcmp(pfcp_key, "client")) {
                            ogs_yaml_iter_t client_iter;
                            ogs_yaml_iter_recurse(&pfcp_iter, &client_iter);
                            while (ogs_yaml_iter_next(&client_iter)) {
                                const char *client_key =
                                    ogs_yaml_iter_key(&client_iter);
                                ogs_assert(client_key);
                                if (!strcmp(client_key, remote)) {
                                    ogs_yaml_iter_t remote_array, remote_iter;
                                    ogs_yaml_iter_recurse(
                                            &client_iter, &remote_array);
                                    do {
                                        ogs_pfcp_node_t *node = NULL;
                                        ogs_sockaddr_t *addr = NULL;
                                        int family = AF_UNSPEC;
                                        int i, num = 0;
                                        const char *hostname[
                                            OGS_MAX_NUM_OF_HOSTNAME];
                                        uint16_t port = self.pfcp_port;
                                        uint16_t tac[OGS_MAX_NUM_OF_TAI] = {0,};
                                        int num_of_tac = 0;
                                        const char *dnn[OGS_MAX_NUM_OF_DNN];
                                        int num_of_dnn = 0;
                                        uint32_t e_cell_id[
                                            OGS_MAX_NUM_OF_CELL_ID] = {0,};
                                        int num_of_e_cell_id = 0;
                                        uint64_t nr_cell_id[
                                            OGS_MAX_NUM_OF_CELL_ID] = {0,};
                                        int num_of_nr_cell_id = 0;

                                        if (ogs_yaml_iter_type(&remote_array) ==
                                                YAML_MAPPING_NODE) {
                                            memcpy(&remote_iter, &remote_array,
                                                    sizeof(ogs_yaml_iter_t));
                                        } else if (ogs_yaml_iter_type(
                                                    &remote_array) ==
                                                YAML_SEQUENCE_NODE) {
                                            if (!ogs_yaml_iter_next(
                                                        &remote_array))
                                                break;
                                            ogs_yaml_iter_recurse(&remote_array,
                                                    &remote_iter);
                                        } else if (ogs_yaml_iter_type(
                                                    &remote_array) ==
                                                YAML_SCALAR_NODE) {
                                            break;
                                        } else
                                            ogs_assert_if_reached();

                                        while (ogs_yaml_iter_next(
                                                    &remote_iter)) {
                                            const char *remote_key =
                                                ogs_yaml_iter_key(&remote_iter);
                                            ogs_assert(remote_key);
                                            if (!strcmp(remote_key, "family")) {
                                                const char *v =
                                                    ogs_yaml_iter_value(
                                                            &remote_iter);
                                                if (v) family = atoi(v);
                                                if (family != AF_UNSPEC &&
                                                    family != AF_INET &&
                                                    family != AF_INET6) {
                                                    ogs_warn(
                                                        "Ignore family(%d) : "
                                                        "AF_UNSPEC(%d), "
                                                        "AF_INET(%d), "
                                                        "AF_INET6(%d) ",
                                                        family, AF_UNSPEC,
                                                        AF_INET, AF_INET6);
                                                    family = AF_UNSPEC;
                                                }
                                            } else if (!strcmp(remote_key,
                                                        "address")) {
                                                ogs_yaml_iter_t hostname_iter;
                                                ogs_yaml_iter_recurse(
                                                        &remote_iter,
                                                        &hostname_iter);
                                                ogs_assert(ogs_yaml_iter_type(
                                                            &hostname_iter) !=
                                                        YAML_MAPPING_NODE);

                                                do {
                                                    if (ogs_yaml_iter_type(
                                                            &hostname_iter) ==
                                                        YAML_SEQUENCE_NODE) {
                                                        if (!ogs_yaml_iter_next(
                                                                &hostname_iter))
                                                            break;
                                                    }

                                                    ogs_assert(num <
                                                    OGS_MAX_NUM_OF_HOSTNAME);
                                                    hostname[num++] =
                                                        ogs_yaml_iter_value(
                                                            &hostname_iter);
                                                } while (ogs_yaml_iter_type(
                                                            &hostname_iter) ==
                                                        YAML_SEQUENCE_NODE);
                                            } else if (!strcmp(remote_key,
                                                        "advertise")) {
                                                /* Nothing in client */
                                            } else if (!strcmp(remote_key,
                                                        "port")) {
                                                const char *v =
                                                    ogs_yaml_iter_value(
                                                            &remote_iter);
                                                if (v) port = atoi(v);
                                            } else if (!strcmp(remote_key,
                                                        "tac")) {
                                                ogs_yaml_iter_t tac_iter;
                                                ogs_yaml_iter_recurse(
                                                        &remote_iter,
                                                        &tac_iter);
                                                ogs_assert(ogs_yaml_iter_type(
                                                            &tac_iter) !=
                                                        YAML_MAPPING_NODE);

                                                do {
                                                    const char *v = NULL;

                                                    ogs_assert(num_of_tac <
                                                            OGS_MAX_NUM_OF_TAI);
                                                    if (ogs_yaml_iter_type(
                                                                &tac_iter) ==
                                                        YAML_SEQUENCE_NODE) {
                                                        if (!ogs_yaml_iter_next(
                                                                    &tac_iter))
                                                            break;
                                                    }

                                                    v = ogs_yaml_iter_value(
                                                            &tac_iter);
                                                    if (v) {
                                                        tac[num_of_tac] =
                                                            atoi(v);
                                                        num_of_tac++;
                                                    }
                                                } while (ogs_yaml_iter_type(
                                                            &tac_iter) ==
                                                        YAML_SEQUENCE_NODE);
                                            } else if (!strcmp(
                                                        remote_key, "apn") ||
                                                    !strcmp(
                                                        remote_key, "dnn")) {
                                                ogs_yaml_iter_t dnn_iter;
                                                ogs_yaml_iter_recurse(
                                                        &remote_iter,
                                                        &dnn_iter);
                                                ogs_assert(ogs_yaml_iter_type(
                                                            &dnn_iter) !=
                                                        YAML_MAPPING_NODE);

                                                do {
                                                    const char *v = NULL;

                                                    ogs_assert(num_of_dnn <
                                                            OGS_MAX_NUM_OF_DNN);
                                                    if (ogs_yaml_iter_type(
                                                                &dnn_iter) ==
                                                        YAML_SEQUENCE_NODE) {
                                                        if (!ogs_yaml_iter_next(
                                                                    &dnn_iter))
                                                            break;
                                                    }

                                                    v = ogs_yaml_iter_value(
                                                            &dnn_iter);
                                                    if (v) {
                                                        dnn[num_of_dnn] = v;
                                                        num_of_dnn++;
                                                    }
                                                } while (ogs_yaml_iter_type(
                                                            &dnn_iter) ==
                                                        YAML_SEQUENCE_NODE);
                                            } else if (!strcmp(remote_key,
                                                        "e_cell_id")) {
                                                ogs_yaml_iter_t e_cell_id_iter;
                                                ogs_yaml_iter_recurse(
                                                        &remote_iter,
                                                        &e_cell_id_iter);
                                                ogs_assert(ogs_yaml_iter_type(
                                                            &e_cell_id_iter) !=
                                                        YAML_MAPPING_NODE);

                                                do {
                                                    const char *v = NULL;

                                                    ogs_assert(
                                                            num_of_e_cell_id <
                                                        OGS_MAX_NUM_OF_ENB_ID);
                                                    if (ogs_yaml_iter_type(
                                                            &e_cell_id_iter) ==
                                                        YAML_SEQUENCE_NODE) {
                                                        if (!ogs_yaml_iter_next(
                                                            &e_cell_id_iter))
                                                            break;
                                                    }

                                                    v = ogs_yaml_iter_value(
                                                            &e_cell_id_iter);
                                                    if (v) {
                                                        e_cell_id[
                                                            num_of_e_cell_id] =
                                                        ogs_uint64_from_string_hexadecimal(
                                                                (char*)v);
                                                        num_of_e_cell_id++;
                                                    }
                                                } while (ogs_yaml_iter_type(
                                                            &e_cell_id_iter) ==
                                                        YAML_SEQUENCE_NODE);
                                            } else if (!strcmp(remote_key,
                                                        "nr_cell_id")) {
                                                ogs_yaml_iter_t nr_cell_id_iter;
                                                ogs_yaml_iter_recurse(
                                                        &remote_iter,
                                                        &nr_cell_id_iter);
                                                ogs_assert(ogs_yaml_iter_type(
                                                            &nr_cell_id_iter) !=
                                                        YAML_MAPPING_NODE);

                                                do {
                                                    const char *v = NULL;

                                                    ogs_assert(
                                                            num_of_nr_cell_id <
                                                        OGS_MAX_NUM_OF_ENB_ID);
                                                    if (ogs_yaml_iter_type(
                                                            &nr_cell_id_iter) ==
                                                        YAML_SEQUENCE_NODE) {
                                                        if (!ogs_yaml_iter_next(
                                                            &nr_cell_id_iter))
                                                            break;
                                                    }

                                                    v = ogs_yaml_iter_value(
                                                            &nr_cell_id_iter);
                                                    if (v) {
                                                        nr_cell_id[
                                                            num_of_nr_cell_id] =
                                                        ogs_uint64_from_string_hexadecimal(
                                                                (char*)v);
                                                        num_of_nr_cell_id++;
                                                    }
                                                } while (ogs_yaml_iter_type(
                                                        &nr_cell_id_iter) ==
                                                        YAML_SEQUENCE_NODE);
                                            } else
                                                ogs_warn("unknown key `%s`",
                                                        remote_key);
                                        }

                                        addr = NULL;
                                        for (i = 0; i < num; i++) {
                                            rv = ogs_addaddrinfo(&addr, family,
                                                    hostname[i], port, 0);
                                            ogs_assert(rv == OGS_OK);
                                        }

                                        ogs_filter_ip_version(&addr,
                                                ogs_global_conf()->parameter.
                                                no_ipv4,
                                                ogs_global_conf()->parameter.
                                                no_ipv6,
                                                ogs_global_conf()->parameter.
                                                prefer_ipv4);

                                        if (addr == NULL) continue;

                                        node = ogs_pfcp_node_new(addr);
                                        ogs_assert(node);
                                        ogs_list_add(
                                                &self.pfcp_peer_list, node);

                                        node->num_of_tac = num_of_tac;
                                        if (num_of_tac != 0)
                                            memcpy(node->tac,
                                                    tac, sizeof(node->tac));

                                        node->num_of_dnn = num_of_dnn;
                                        if (num_of_dnn != 0)
                                            memcpy(node->dnn,
                                                    dnn, sizeof(node->dnn));

                                        node->num_of_e_cell_id =
                                            num_of_e_cell_id;
                                        if (num_of_e_cell_id != 0)
                                            memcpy(node->e_cell_id, e_cell_id,
                                                    sizeof(node->e_cell_id));

                                        node->num_of_nr_cell_id =
                                            num_of_nr_cell_id;
                                        if (num_of_nr_cell_id != 0)
                                            memcpy(node->nr_cell_id, nr_cell_id,
                                                    sizeof(node->nr_cell_id));

                                    } while (ogs_yaml_iter_type(
                                                &remote_array) ==
                                            YAML_SEQUENCE_NODE);
                                }
                            }
                        } else
                            ogs_warn("unknown key `%s`", pfcp_key);
                    }
                } else if (!strcmp(local_key, "session")) {
                    ogs_yaml_iter_t subnet_array, subnet_iter;
                    ogs_yaml_iter_recurse(&local_iter, &subnet_array);

                    do {
                        ogs_pfcp_subnet_t *subnet = NULL;
                        const char *ipstr = NULL;
                        const char *gateway = NULL;
                        const char *mask_or_numbits = NULL;
                        const char *dnn = NULL;
                        const char *dev = self.tun_ifname;
                        const char *low[OGS_MAX_NUM_OF_SUBNET_RANGE];
                        const char *high[OGS_MAX_NUM_OF_SUBNET_RANGE];
                        int i, num = 0;

                        memset(low, 0, sizeof(low));
                        memset(high, 0, sizeof(high));

                        if (ogs_yaml_iter_type(&subnet_array) ==
                                YAML_MAPPING_NODE) {
                            memcpy(&subnet_iter, &subnet_array,
                                    sizeof(ogs_yaml_iter_t));
                        } else if (ogs_yaml_iter_type(&subnet_array) ==
                                YAML_SEQUENCE_NODE) {
                            if (!ogs_yaml_iter_next(&subnet_array))
                                break;
                            ogs_yaml_iter_recurse(&subnet_array, &subnet_iter);
                        } else if (ogs_yaml_iter_type(&subnet_array) ==
                                YAML_SCALAR_NODE) {
                            break;
                        } else
                            ogs_assert_if_reached();

                        while (ogs_yaml_iter_next(&subnet_iter)) {
                            const char *subnet_key =
                                ogs_yaml_iter_key(&subnet_iter);
                            ogs_assert(subnet_key);
                            if (!strcmp(subnet_key, "subnet")) {
                                char *v =
                                    (char *)ogs_yaml_iter_value(&subnet_iter);
                                if (v) {
                                    ipstr = (const char *)strsep(&v, "/");
                                    if (ipstr) {
                                        mask_or_numbits = (const char *)v;
                                    }
                                }
                            } else if (!strcmp(subnet_key, "gateway")) {
                                gateway = ogs_yaml_iter_value(&subnet_iter);
                            } else if (!strcmp(subnet_key, "apn") ||
                                        !strcmp(subnet_key, "dnn")) {
                                dnn = ogs_yaml_iter_value(&subnet_iter);
                            } else if (!strcmp(subnet_key, "dev")) {
                                dev = ogs_yaml_iter_value(&subnet_iter);
                            } else if (!strcmp(subnet_key, "range")) {
                                ogs_yaml_iter_t range_iter;
                                ogs_yaml_iter_recurse(
                                        &subnet_iter, &range_iter);
                                ogs_assert(ogs_yaml_iter_type(&range_iter) !=
                                    YAML_MAPPING_NODE);
                                do {
                                    char *v = NULL;

                                    if (ogs_yaml_iter_type(&range_iter) ==
                                            YAML_SEQUENCE_NODE) {
                                        if (!ogs_yaml_iter_next(&range_iter))
                                            break;
                                    }

                                    v = (char *)
                                        ogs_yaml_iter_value(&range_iter);
                                    if (v) {
                                        ogs_assert(num <
                                                OGS_MAX_NUM_OF_SUBNET_RANGE);
                                        low[num] =
                                            (const char *)strsep(&v, "-");
                                        if (low[num] && strlen(low[num]) == 0)
                                            low[num] = NULL;

                                        high[num] = (const char *)v;
                                        if (high[num] && strlen(high[num]) == 0)
                                            high[num] = NULL;
                                    }

                                    if (low[num] || high[num]) num++;
                                } while (
                                    ogs_yaml_iter_type(&range_iter) ==
                                    YAML_SEQUENCE_NODE);
                            } else
                                ogs_warn("unknown key `%s`", subnet_key);
                        }

                        subnet = ogs_pfcp_subnet_add(
                                ipstr, mask_or_numbits, gateway, dnn, dev);
                        ogs_assert(subnet);

                        subnet->num_of_range = num;
                        for (i = 0; i < subnet->num_of_range; i++) {
                            subnet->range[i].low = low[i];
                            subnet->range[i].high = high[i];
                        }

                    } while (ogs_yaml_iter_type(&subnet_array) ==
                            YAML_SEQUENCE_NODE);
                }
            }
        }
    }

    rv = ogs_pfcp_context_validation(local);
    if (rv != OGS_OK) return rv;

    return OGS_OK;
}

/******************************************************************************
 * ogs_pfcp_node_new()
 *  - Initialize node_id.type to OGS_PFCP_NODE_ID_UNKNOWN
 *  - So the node can later be updated with a real Node ID via
 *    ogs_pfcp_node_merge() once we learn it from PFCP messages.
 ******************************************************************************/
ogs_pfcp_node_t *ogs_pfcp_node_new(ogs_sockaddr_t *config_addr)
{
    int rv;
    ogs_pfcp_node_t *node = NULL;

    ogs_pool_alloc(&ogs_pfcp_node_pool, &node);
    if (!node) {
        ogs_error("No memory: ogs_pool_alloc() failed [%s]",
                ogs_sockaddr_to_string_static(config_addr));
        return NULL;
    }
    memset(node, 0, sizeof(ogs_pfcp_node_t));

    /* Store config_addr, if any */
    node->config_addr = config_addr;

    /* If config_addr is given, copy it immediately into addr_list */
    if (config_addr) {
        rv = ogs_copyaddrinfo(&node->addr_list, config_addr);
        if (rv != OGS_OK) {
            ogs_error("ogs_copyaddrinfo() failed");
            ogs_pool_free(&ogs_pfcp_node_pool, node);
            return NULL;
        }
    }

    /*
     * Initialize node->node_id to UNKNOWN, meaning "no Node ID assigned yet".
     */
    memset(&node->node_id, 0, sizeof(node->node_id));
    node->node_id.type = OGS_PFCP_NODE_ID_UNKNOWN;

    ogs_list_init(&node->local_list);
    ogs_list_init(&node->remote_list);

    ogs_list_init(&node->gtpu_resource_list);

    return node;
}

void ogs_pfcp_node_free(ogs_pfcp_node_t *node)
{
    ogs_assert(node);

    ogs_gtpu_resource_remove_all(&node->gtpu_resource_list);

    ogs_pfcp_xact_delete_all(node);

    ogs_freeaddrinfo(node->config_addr);
    ogs_freeaddrinfo(node->addr_list);

    ogs_pool_free(&ogs_pfcp_node_pool, node);
}

/******************************************************************************
 * ogs_pfcp_node_add()
 *  - Create a new PFCP node, then call ogs_pfcp_node_merge() to handle
 *    IPv4/IPv6 or FQDN logic.
 ******************************************************************************/
ogs_pfcp_node_t *ogs_pfcp_node_add(ogs_list_t *list,
    ogs_pfcp_node_id_t *node_id, ogs_sockaddr_t *from)
{
    ogs_pfcp_node_t *node = NULL;

    ogs_assert(list);
    ogs_assert(node_id && from);

    /*
     * We only handle IPv4, IPv6, and FQDN types here. If the incoming
     * node_id has any other type, we treat it as invalid. This ensures
     * we do not merge a node with an unsupported PFCP Node ID.
     */
    if (node_id->type != OGS_PFCP_NODE_ID_IPV4 &&
        node_id->type != OGS_PFCP_NODE_ID_IPV6 &&
        node_id->type != OGS_PFCP_NODE_ID_FQDN) {
        ogs_error("Invalid PFCP Node Type = %d", node_id->type);
        return NULL;
    }

    /* Create node with no config_addr initially */
    node = ogs_pfcp_node_new(NULL);
    if (!node) {
        ogs_error("No memory: ogs_pfcp_node_add() failed node_id:%s from:%s",
                ogs_pfcp_node_id_to_string_static(node_id),
                ogs_sockaddr_to_string_static(from));
        return NULL;
    }

    /* Set node->node_id, reset last_dns_refresh. */
    memcpy(&node->node_id, node_id, sizeof(node->node_id));
    node->last_dns_refresh = 0;

    /* Merge addresses => fill node->addr_list if conditions are met */
    if (ogs_pfcp_node_merge(node, node_id, from) != OGS_OK) {
        ogs_error("ogs_pfcp_node_merge() failed node_id [%s] from [%s]",
                ogs_pfcp_node_id_to_string_static(node_id),
                ogs_sockaddr_to_string_static(from));
        ogs_pool_free(&ogs_pfcp_node_pool, node);
        return NULL;
    }

    ogs_list_add(list, node);

    return node;
}

/******************************************************************************
 * ogs_pfcp_node_find()
 *  - No DNS logic here. Merely finds a node by node_id (if provided) and
 *    checks if 'from' address is in node->addr_list.
 ******************************************************************************/
ogs_pfcp_node_t *ogs_pfcp_node_find(ogs_list_t *list,
    ogs_pfcp_node_id_t *node_id, ogs_sockaddr_t *from)
{
    ogs_pfcp_node_t *cur;

    ogs_assert(list);
    ogs_assert(node_id || from);

    ogs_list_for_each(list, cur) {
        /*
         * If the node currently has a known Node ID (not UNKNOWN)
         * and the caller provided a node_id to match, then compare them.
         * If they do not match, skip this node. This allows config-based nodes
         * (with an UNKNOWN node_id) to be found by IP address alone,
         * while nodes with a definite ID must match the incoming node_id.
         */
        if (cur->node_id.type != OGS_PFCP_NODE_ID_UNKNOWN && node_id) {
            if (!ogs_pfcp_node_id_compare(&cur->node_id, node_id))
                continue;
        }
        if (!from)
            return cur;

        /* Check if 'from' is in cur->addr_list. */
        if (ogs_sockaddr_check_any_match(cur->addr_list, NULL,
                                         from, /* compare_port= */ true)) {
            return cur;
        }
    }

    /* No match found. */
    return NULL;
}

/******************************************************************************
 * ogs_pfcp_node_merge():
 *  - If node_id changes to FQDN, we check last_dns_refresh.
 *    => If 0, do an immediate DNS resolution (first time).
 *    => If >= 300 seconds passed, do a periodic refresh.
 *    => Otherwise, skip.
 *  - If node_id changes to IPv4/IPv6, convert IP addresses immediately.
 *  - Merge the 'from' address into addr_list if provided.
 ******************************************************************************/
int ogs_pfcp_node_merge(ogs_pfcp_node_t *node,
    ogs_pfcp_node_id_t *node_id, ogs_sockaddr_t *from)
{
    ogs_sockaddr_t single;
    ogs_sockaddr_t *tmp_list = NULL;

    ogs_assert(node);
    ogs_assert(node_id || from);

    if (node_id) {
        /*
         * We only handle IPv4, IPv6, and FQDN types here. If the incoming
         * node_id has any other type, we treat it as invalid. This ensures
         * we do not merge a node with an unsupported PFCP Node ID.
         */
        if (node_id->type != OGS_PFCP_NODE_ID_IPV4 &&
            node_id->type != OGS_PFCP_NODE_ID_IPV6 &&
            node_id->type != OGS_PFCP_NODE_ID_FQDN) {
            ogs_error("Invalid PFCP Node Type = %d", node_id->type);
            return OGS_ERROR;
        }

        /* Check if node_id is different from node->node_id. */
        if (!ogs_pfcp_node_id_compare(&node->node_id, node_id)) {
            /* Update the node's ID and reset the refresh timestamp. */
            memcpy(&node->node_id, node_id, sizeof(node->node_id));
            node->last_dns_refresh = 0;
        }

        /* If FQDN, do a DNS lookup (immediate or periodic). */
        if (node->node_id.type == OGS_PFCP_NODE_ID_FQDN) {
/*
 * We perform a DNS resolution if 'last_dns_refresh' is zero, which means
 * this FQDN node has never been resolved yet (first-time resolution), or if
 * at least 300 seconds have passed since the last refresh. Without checking
 * '== 0', a newly created FQDN node might skip resolution if 'now' is less
 * than the 300-second threshold.
 */
            ogs_time_t now = ogs_time_now();

/* For 300-second refresh interval in microseconds. */
#define OGS_PFCP_NODE_DNS_REFRESH_INTERVAL \
    ((ogs_time_t)(300) * OGS_USEC_PER_SEC)
            if (node->last_dns_refresh == 0 ||
                (now - node->last_dns_refresh) >=
                  OGS_PFCP_NODE_DNS_REFRESH_INTERVAL) {

                tmp_list = ogs_pfcp_node_id_to_addrinfo(&node->node_id);
                if (!tmp_list) {
                    ogs_error("DNS resolution failed for FQDN [%s]",
                              node->node_id.fqdn);
                    return OGS_ERROR;
                }

                ogs_freeaddrinfo(node->addr_list);
                node->addr_list = tmp_list;
                node->last_dns_refresh = now;
                node->current_addr = NULL;
                tmp_list = NULL;
            }
        }
        /* If IPv4/IPv6, convert immediately. */
        else if (node->node_id.type == OGS_PFCP_NODE_ID_IPV4 ||
                 node->node_id.type == OGS_PFCP_NODE_ID_IPV6) {
            tmp_list = ogs_pfcp_node_id_to_addrinfo(&node->node_id);
            if (!tmp_list) {
                ogs_error("Failed to convert node ID to address info");
                return OGS_ERROR;
            }
            ogs_merge_addrinfo(&node->addr_list, tmp_list);
            ogs_freeaddrinfo(tmp_list);
            tmp_list = NULL;
        }
        else {
            /* Not IPv4, IPv6, or FQDN => invalid node type. */
            ogs_error("Invalid Node ID type [%d]", node->node_id.type);
            return OGS_ERROR;
        }
    }

    /* Merge 'from' into addr_list if provided. */
    if (from) {
        memcpy(&single, from, sizeof(single));
        single.next = NULL;
        ogs_merge_addrinfo(&node->addr_list, &single);
    }

    return OGS_OK;
}

void ogs_pfcp_node_remove(ogs_list_t *list, ogs_pfcp_node_t *node)
{
    ogs_assert(list);
    ogs_assert(node);

    ogs_list_remove(list, node);
    ogs_pfcp_node_free(node);
}

void ogs_pfcp_node_remove_all(ogs_list_t *list)
{
    ogs_pfcp_node_t *node = NULL, *next_node = NULL;

    ogs_assert(list);

    ogs_list_for_each_safe(list, next_node, node)
        ogs_pfcp_node_remove(list, node);
}

/******************************************************************************
 * Compare two node IDs for equality. Returns true if they match, else false.
 ******************************************************************************/
bool ogs_pfcp_node_id_compare(
        const ogs_pfcp_node_id_t *id1, const ogs_pfcp_node_id_t *id2)
{
    if (id1->type != id2->type)
        return false; /* Types do not match */

    switch (id1->type) {
        case OGS_PFCP_NODE_ID_IPV4:
            if (id1->addr != id2->addr) return false;
            return true;

        case OGS_PFCP_NODE_ID_IPV6:
            if (memcmp(id1->addr6, id2->addr6, OGS_IPV6_LEN) != 0)
                return false;
            return true;

        case OGS_PFCP_NODE_ID_FQDN:
            if (strcmp(id1->fqdn, id2->fqdn) != 0)
                return false;
            return true;

        default:
            ogs_error("Unexpected Node Type [%d]", id1->type);
            ogs_abort();
            return false; /* Unknown types do not match */
    }
}

ogs_gtpu_resource_t *ogs_pfcp_find_gtpu_resource(ogs_list_t *list,
        char *dnn, ogs_pfcp_interface_t source_interface)
{
    ogs_gtpu_resource_t *resource = NULL;

    ogs_assert(list);

    ogs_list_for_each(list, resource) {
        bool match = true;

        if (resource->info.assoni &&
            strlen(resource->info.network_instance) &&
            dnn && strlen(dnn) &&
            ogs_strcasecmp(dnn, resource->info.network_instance) != 0) {
            match = false;
        }

        if (resource->info.assosi &&
            resource->info.source_interface <= OGS_PFCP_INTERFACE_LI_FUNCTION &&
            source_interface <= OGS_PFCP_INTERFACE_LI_FUNCTION &&
            source_interface != resource->info.source_interface) {
            match = false;
        }

        if (match == true) return resource;
    }

    return NULL;
}

int ogs_pfcp_setup_far_gtpu_node(ogs_pfcp_far_t *far)
{
    int rv;
    ogs_ip_t ip;
    ogs_gtp_node_t *gnode = NULL;

    ogs_assert(far);

    ogs_pfcp_outer_header_creation_to_ip(&far->outer_header_creation, &ip);

    /* No Outer Header Creation */
    if (ip.len == 0) return OGS_DONE;

    gnode = ogs_gtp_node_find_by_ip(&ogs_gtp_self()->gtpu_peer_list, &ip);
    if (!gnode) {
        gnode = ogs_gtp_node_add_by_ip(
            &ogs_gtp_self()->gtpu_peer_list, &ip, ogs_gtp_self()->gtpu_port);
        if (!gnode) {
            ogs_error("ogs_gtp_node_add_by_ip() failed");
            return OGS_ERROR;
        }

        rv = ogs_gtp_connect(
                ogs_gtp_self()->gtpu_sock, ogs_gtp_self()->gtpu_sock6, gnode);
        if (rv != OGS_OK) {
            ogs_error("ogs_gtp_connect() failed");
            return rv;
        }
    }

    OGS_SETUP_GTP_NODE(far, gnode);

    return OGS_OK;
}

int ogs_pfcp_setup_pdr_gtpu_node(ogs_pfcp_pdr_t *pdr)
{
    int rv;
    ogs_ip_t ip;
    ogs_gtp_node_t *gnode = NULL;

    ogs_assert(pdr);

    /* No F-TEID */
    if (pdr->f_teid_len == 0) return OGS_DONE;

    rv = ogs_pfcp_f_teid_to_ip(&pdr->f_teid, &ip);
    if (rv != OGS_OK) {
        ogs_error("ogs_pfcp_f_teid_to_ip() failed");
        return rv;
    }

    gnode = ogs_gtp_node_find_by_ip(&ogs_gtp_self()->gtpu_peer_list, &ip);
    if (!gnode) {
        gnode = ogs_gtp_node_add_by_ip(
            &ogs_gtp_self()->gtpu_peer_list, &ip, ogs_gtp_self()->gtpu_port);
        if (!gnode) {
            ogs_error("ogs_gtp_node_add_by_ip() failed");
            return OGS_ERROR;
        }

        rv = ogs_gtp_connect(
                ogs_gtp_self()->gtpu_sock, ogs_gtp_self()->gtpu_sock6, gnode);
        if (rv != OGS_OK) {
            ogs_error("ogs_gtp_connect() failed");
            return rv;
        }
    }

    OGS_SETUP_GTP_NODE(pdr, gnode);

    return OGS_OK;
}

void ogs_pfcp_sess_clear(ogs_pfcp_sess_t *sess)
{
    ogs_pfcp_pdr_remove_all(sess);
    ogs_pfcp_far_remove_all(sess);
    ogs_pfcp_urr_remove_all(sess);
    ogs_pfcp_qer_remove_all(sess);
    if (sess->bar) ogs_pfcp_bar_delete(sess->bar);
}

static int precedence_compare(ogs_pfcp_pdr_t *pdr1, ogs_pfcp_pdr_t *pdr2)
{
    if (pdr1->precedence == pdr2->precedence)
        return 0;
    else if (pdr1->precedence < pdr2->precedence)
        return -1;
    else
        return 1;
}

ogs_pfcp_pdr_t *ogs_pfcp_pdr_add(ogs_pfcp_sess_t *sess)
{
    ogs_pfcp_pdr_t *pdr = NULL;

    ogs_assert(sess);

    ogs_pool_alloc(&ogs_pfcp_pdr_pool, &pdr);
    if (pdr == NULL) {
        ogs_error("pdr_pool() failed");
        return NULL;
    }
    memset(pdr, 0, sizeof *pdr);

    pdr->obj.type = OGS_PFCP_OBJ_PDR_TYPE;
    pdr->src_if = OGS_PFCP_INTERFACE_UNKNOWN;

    /* Set TEID */
    ogs_pool_alloc(&ogs_pfcp_pdr_teid_pool, &pdr->teid_node);
    ogs_assert(pdr->teid_node);

    pdr->teid = *(pdr->teid_node);

    /* Set PDR-ID */
    ogs_pool_alloc(&sess->pdr_id_pool, &pdr->id_node);
    if (pdr->id_node == NULL) {
        ogs_error("pdr_id_pool() failed");
        ogs_pool_free(&ogs_pfcp_pdr_pool, pdr);
        return NULL;
    }

    pdr->id = *(pdr->id_node);
    ogs_assert(pdr->id > 0 && pdr->id <= OGS_MAX_NUM_OF_PDR);

    pdr->sess = sess;
    ogs_list_add(&sess->pdr_list, pdr);

    return pdr;
}

ogs_pfcp_pdr_t *ogs_pfcp_pdr_find(
        ogs_pfcp_sess_t *sess, ogs_pfcp_pdr_id_t id)
{
    ogs_pfcp_pdr_t *pdr = NULL;

    ogs_assert(sess);

    ogs_list_for_each(&sess->pdr_list, pdr)
        if (pdr->id == id) return pdr;

    return NULL;
}

ogs_pfcp_pdr_t *ogs_pfcp_pdr_find_or_add(
        ogs_pfcp_sess_t *sess, ogs_pfcp_pdr_id_t id)
{
    ogs_pfcp_pdr_t *pdr = NULL;

    ogs_assert(sess);

    pdr = ogs_pfcp_pdr_find(sess, id);
    if (!pdr) {
        pdr = ogs_pfcp_pdr_add(sess);
        ogs_assert(pdr);
        pdr->id = id;
    }

    return pdr;
}

int ogs_pfcp_pdr_swap_teid(ogs_pfcp_pdr_t *pdr)
{
    int i = 0;

    ogs_assert(pdr);
    ogs_assert(!pdr->f_teid.ch);

    /*
     * Issues #3747, #3574
     *
     * This code validates the F-TEID (Fully encapsulated TEID) information
     * element within a PDR structure before further processing the PFCP
     * message. The validation ensures that the F-TEID is present and
     * within acceptable limits defined by the system.
     */
    if (pdr->f_teid_len > 0 &&
        pdr->f_teid.teid > 0 &&
        pdr->f_teid.teid <= ogs_pfcp_pdr_teid_pool.size) {
        /* PASS OK */
    } else {
        ogs_error("F-TEID LEN[%d] TEID[0x%x]",
                pdr->f_teid_len, pdr->f_teid.teid);
        return OGS_PFCP_CAUSE_MANDATORY_IE_INCORRECT;
    }

    /* Find out the Array Index for the restored TEID. */
    i = pdr_random_to_index[pdr->f_teid.teid];
    ogs_assert(i < ogs_pfcp_pdr_teid_pool.size);

    ogs_assert(pdr->teid_node);
    /*
     * If SWAP has already done this, it will not try this again.
     * This situation can occur when multiple PDRs are restored
     * with the same TEID.
     */
    if (pdr->f_teid.teid == ogs_pfcp_pdr_teid_pool.array[i]) {
        ogs_pfcp_pdr_teid_pool.array[i] = *(pdr->teid_node);
        *(pdr->teid_node) = pdr->f_teid.teid;
    }

    return OGS_PFCP_CAUSE_REQUEST_ACCEPTED;
}

void ogs_pfcp_object_teid_hash_set(
        ogs_pfcp_object_type_e type, ogs_pfcp_pdr_t *pdr,
        bool restoration_indication)
{
    ogs_assert(type);
    ogs_assert(pdr);

    if (ogs_pfcp_self()->up_function_features.ftup && pdr->f_teid.ch) {

        ogs_pfcp_pdr_t *choosed_pdr = NULL;

        if (pdr->f_teid.chid) {
            choosed_pdr = ogs_pfcp_pdr_find_by_choose_id(
                    pdr->sess, pdr->f_teid.choose_id);
            if (!choosed_pdr) {
                pdr->chid = true;
                pdr->choose_id = pdr->f_teid.choose_id;
            }
        }

        if (choosed_pdr) {
            pdr->f_teid_len = choosed_pdr->f_teid_len;
            memcpy(&pdr->f_teid, &choosed_pdr->f_teid, pdr->f_teid_len);

        } else {
            ogs_gtpu_resource_t *resource = NULL;
            resource = ogs_pfcp_find_gtpu_resource(
                    &ogs_gtp_self()->gtpu_resource_list,
                    pdr->dnn, pdr->src_if);
            if (resource) {
                ogs_assert(
                    (resource->info.v4 && pdr->f_teid.ipv4) ||
                    (resource->info.v6 && pdr->f_teid.ipv6));
                ogs_assert(OGS_OK ==
                    ogs_pfcp_user_plane_ip_resource_info_to_f_teid(
                    &resource->info, &pdr->f_teid, &pdr->f_teid_len));
                if (resource->info.teidri)
                    pdr->f_teid.teid = OGS_PFCP_GTPU_INDEX_TO_TEID(
                            pdr->teid, resource->info.teidri,
                            resource->info.teid_range);
                else
                    pdr->f_teid.teid = pdr->teid;
            } else {
                ogs_assert(
                    (ogs_gtp_self()->gtpu_addr && pdr->f_teid.ipv4) ||
                    (ogs_gtp_self()->gtpu_addr6 && pdr->f_teid.ipv6));
                ogs_assert(OGS_OK ==
                    ogs_pfcp_sockaddr_to_f_teid(
                        pdr->f_teid.ipv4 ?
                            ogs_gtp_self()->gtpu_addr : NULL,
                        pdr->f_teid.ipv6 ?
                            ogs_gtp_self()->gtpu_addr6 : NULL,
                        &pdr->f_teid, &pdr->f_teid_len));
                pdr->f_teid.teid = pdr->teid;
            }
        }
    }

    if (pdr->hash.teid.len)
        ogs_hash_set(self.object_teid_hash,
                &pdr->hash.teid.key, pdr->hash.teid.len, NULL);

    pdr->hash.teid.key = pdr->f_teid.teid;
    pdr->hash.teid.len = sizeof(pdr->hash.teid.key);

    switch(type) {
    case OGS_PFCP_OBJ_PDR_TYPE:
        ogs_hash_set(self.object_teid_hash,
                &pdr->hash.teid.key, pdr->hash.teid.len, pdr);
        break;
    case OGS_PFCP_OBJ_SESS_TYPE:
        ogs_assert(pdr->sess);
        ogs_hash_set(self.object_teid_hash,
                &pdr->hash.teid.key, pdr->hash.teid.len, pdr->sess);
        break;
    default:
        ogs_fatal("Unknown type [%d]", type);
        ogs_assert_if_reached();
    }
}

ogs_pfcp_object_t *ogs_pfcp_object_find_by_teid(uint32_t teid)
{
    return (ogs_pfcp_object_t *)ogs_hash_get(
            self.object_teid_hash, &teid, sizeof(teid));
}

int ogs_pfcp_object_count_by_teid(ogs_pfcp_sess_t *sess, uint32_t teid)
{
    ogs_pfcp_pdr_t *pdr = NULL;
    int count = 0;

    ogs_assert(sess);

    ogs_list_for_each(&sess->pdr_list, pdr) {
        if (pdr->f_teid.teid == teid) count++;
    }

    return count;
}

ogs_pfcp_pdr_t *ogs_pfcp_pdr_find_by_choose_id(
        ogs_pfcp_sess_t *sess, uint8_t choose_id)
{
    ogs_pfcp_pdr_t *pdr = NULL;

    ogs_assert(sess);

    ogs_list_for_each(&sess->pdr_list, pdr)
        if (pdr->chid == true && pdr->choose_id == choose_id)
            return pdr;

    return NULL;
}

void ogs_pfcp_pdr_reorder_by_precedence(
        ogs_pfcp_pdr_t *pdr, ogs_pfcp_precedence_t precedence)
{
    ogs_pfcp_sess_t *sess = NULL;

    ogs_assert(pdr);
    sess = pdr->sess;
    ogs_assert(sess);

    ogs_list_remove(&sess->pdr_list, pdr);

    pdr->precedence = precedence;
    ogs_list_insert_sorted(&sess->pdr_list, pdr, precedence_compare);
}

void ogs_pfcp_pdr_associate_far(ogs_pfcp_pdr_t *pdr, ogs_pfcp_far_t *far)
{
    ogs_assert(pdr);
    ogs_assert(far);

    pdr->far = far;
}
void ogs_pfcp_pdr_associate_urr(ogs_pfcp_pdr_t *pdr, ogs_pfcp_urr_t *urr)
{
    ogs_assert(pdr);
    ogs_assert(urr);
    ogs_assert(pdr->num_of_urr < OGS_ARRAY_SIZE(pdr->urr));
    int i;

    /* Avoid storing duplicate pointers */
    for (i = 0; i < pdr->num_of_urr; i++) {
        if (pdr->urr[i]->id == urr->id)
            return;
    }

    pdr->urr[pdr->num_of_urr++] = urr;
}
void ogs_pfcp_pdr_associate_qer(ogs_pfcp_pdr_t *pdr, ogs_pfcp_qer_t *qer)
{
    ogs_assert(pdr);
    ogs_assert(qer);

    pdr->qer = qer;
}

void ogs_pfcp_pdr_remove(ogs_pfcp_pdr_t *pdr)
{
    int i;

    ogs_assert(pdr);
    ogs_assert(pdr->sess);

    ogs_list_remove(&pdr->sess->pdr_list, pdr);

    ogs_pfcp_rule_remove_all(pdr);

    if (pdr->hash.teid.len) {
        /*
         * Issues #2003
         *
         * In 5G Core, two PDRs can use different QFIDs for the same TEID.
         * So, before deleting a TEID, we should check if there is a PDR
         * using the same TEID.
         *
         * Since this PDR has already been deleted with ogs_list_remove() above,
         * if the current list has a TEID count of 0, there are no other PDRs.
         */
        if (ogs_pfcp_object_count_by_teid(pdr->sess, pdr->f_teid.teid) == 0)
            ogs_hash_set(self.object_teid_hash,
                    &pdr->hash.teid.key, pdr->hash.teid.len, NULL);
    }

    if (pdr->dnn)
        ogs_free(pdr->dnn);

    if (pdr->id_node)
        ogs_pool_free(&pdr->sess->pdr_id_pool, pdr->id_node);

    if (pdr->ipv4_framed_routes) {
        for (i = 0; i < OGS_MAX_NUM_OF_FRAMED_ROUTES_IN_PDI; i++) {
            if (!pdr->ipv4_framed_routes[i])
                break;
            ogs_free(pdr->ipv4_framed_routes[i]);
        }
        ogs_free(pdr->ipv4_framed_routes);
    }

    if (pdr->ipv6_framed_routes) {
        for (i = 0; i < OGS_MAX_NUM_OF_FRAMED_ROUTES_IN_PDI; i++) {
            if (!pdr->ipv6_framed_routes[i])
                break;
            ogs_free(pdr->ipv6_framed_routes[i]);
        }
        ogs_free(pdr->ipv6_framed_routes);
    }

    ogs_pool_free(&ogs_pfcp_pdr_teid_pool, pdr->teid_node);
    ogs_pool_free(&ogs_pfcp_pdr_pool, pdr);
}

void ogs_pfcp_pdr_remove_all(ogs_pfcp_sess_t *sess)
{
    ogs_pfcp_pdr_t *pdr = NULL, *next_pdr = NULL;

    ogs_assert(sess);
    ogs_list_for_each_safe(&sess->pdr_list, next_pdr, pdr)
        ogs_pfcp_pdr_remove(pdr);
}

ogs_pfcp_far_t *ogs_pfcp_far_add(ogs_pfcp_sess_t *sess)
{
    ogs_pfcp_far_t *far = NULL;

    ogs_assert(sess);

    ogs_pool_alloc(&ogs_pfcp_far_pool, &far);
    if (far == NULL) {
        ogs_error("far_pool() failed");
        return NULL;
    }
    memset(far, 0, sizeof *far);

    ogs_pool_alloc(&sess->far_id_pool, &far->id_node);
    if (far->id_node == NULL) {
        ogs_error("far_id_pool() failed");
        ogs_pool_free(&ogs_pfcp_far_pool, far);
        return NULL;
    }

    far->id = *(far->id_node);
    ogs_assert(far->id > 0 && far->id <= OGS_MAX_NUM_OF_FAR);

    far->dst_if = OGS_PFCP_INTERFACE_UNKNOWN;

    far->sess = sess;
    ogs_list_add(&sess->far_list, far);

    return far;
}

ogs_pfcp_far_t *ogs_pfcp_far_find(
        ogs_pfcp_sess_t *sess, ogs_pfcp_far_id_t id)
{
    ogs_pfcp_far_t *far = NULL;

    ogs_assert(sess);

    ogs_list_for_each(&sess->far_list, far)
        if (far->id == id) return far;

    return NULL;
}

ogs_pfcp_far_t *ogs_pfcp_far_find_or_add(
        ogs_pfcp_sess_t *sess, ogs_pfcp_far_id_t id)
{
    ogs_pfcp_far_t *far = NULL;

    ogs_assert(sess);

    far = ogs_pfcp_far_find(sess, id);
    if (!far) {
        far = ogs_pfcp_far_add(sess);
        ogs_assert(far);
        far->id = id;
    }

    return far;
}

void ogs_pfcp_far_f_teid_hash_set(ogs_pfcp_far_t *far)
{
    int family;

    ogs_gtp_node_t *gnode = NULL;
    ogs_sockaddr_t *addr = NULL;

    ogs_assert(far);
    gnode = far->gnode;
    ogs_assert(gnode);
    addr = &gnode->addr;
    ogs_assert(addr);

    if (far->hash.f_teid.len)
        ogs_hash_set(self.far_f_teid_hash,
                &far->hash.f_teid.key, far->hash.f_teid.len, NULL);

    far->hash.f_teid.key.teid = far->outer_header_creation.teid;
    far->hash.f_teid.len = sizeof(far->hash.f_teid.key.teid);

    family = addr->ogs_sa_family;
    switch (family) {
    case AF_INET:
        memcpy(far->hash.f_teid.key.addr, &addr->sin.sin_addr, OGS_IPV4_LEN);
        far->hash.f_teid.len += OGS_IPV4_LEN;
        break;
    case AF_INET6:
        memcpy(far->hash.f_teid.key.addr, &addr->sin6.sin6_addr, OGS_IPV6_LEN);
        far->hash.f_teid.len += OGS_IPV6_LEN;
        break;
    default:
        ogs_fatal("Unknown family(%d)", family);
        ogs_abort();
        return;
    }

    ogs_hash_set(self.far_f_teid_hash,
            &far->hash.f_teid.key, far->hash.f_teid.len, far);
}

ogs_pfcp_far_t *ogs_pfcp_far_find_by_gtpu_error_indication(ogs_pkbuf_t *pkbuf)
{
    ogs_pfcp_far_hash_f_teid_t hashkey;
    int hashkey_len;

    uint32_t teid;
    uint16_t len;
    unsigned char *p = NULL;

    ogs_assert(pkbuf);

    p = pkbuf->data;
    ogs_assert(p);

    /*
     * 8.3 Tunnel Endpoint Identifier Data I
     *
     * Octet 1 : Type = 16 (Decimal)
     * Octet 2-5 : Tunnel Endpoint Identitifer Data I
     */
    if (*p != 16) {
        ogs_error("Unknown Type [%d]", *p);
        return NULL;
    }
    p += 1;

    memcpy(&teid, p, 4);
    teid = be32toh(teid);
    p += 4;

    /*
     * 8.4 GTP-U Peer Address
     *
     * Octet 1 : Type = 133 (Decimal)
     * Octet 2-3 : Length
     * Octet 4-n : IPv4 or IPv6 Address
     */
    if (*p != 133) {
        ogs_error("Unknown Type [%d]", *p);
        return NULL;
    }
    p += 1;

    memcpy(&len, p, 2);
    len = be16toh(len);
    p += 2;

    if (len == OGS_IPV4_LEN) {
    } else if (len == OGS_IPV6_LEN) {
    } else {
        ogs_error("Invalid Length [%d]", len);
        return NULL;
    }

    hashkey.teid = teid;
    memcpy(hashkey.addr, p, len);
    hashkey_len = 4 + len;

    return (ogs_pfcp_far_t *)ogs_hash_get(
            self.far_f_teid_hash, &hashkey, hashkey_len);
}

ogs_pfcp_far_t *ogs_pfcp_far_find_by_pfcp_session_report(
        ogs_pfcp_sess_t *sess,
        ogs_pfcp_tlv_error_indication_report_t *error_indication_report)
{
    ogs_pfcp_far_t *far = NULL;
    ogs_pfcp_f_teid_t *remote_f_teid = NULL;

    uint32_t teid;
    uint16_t len;  /* OGS_IPV4_LEN or OGS_IPV6_LEN */
    uint32_t addr[4];

    ogs_assert(sess);
    ogs_assert(error_indication_report);

    if (error_indication_report->presence == 0) {
        ogs_error("No Error Indication Report");
        return NULL;
    }

    if (error_indication_report->remote_f_teid.presence == 0) {
        ogs_error("No Remote F-TEID");
        return NULL;
    }

    remote_f_teid = error_indication_report->remote_f_teid.data;
    ogs_assert(remote_f_teid);

    teid = be32toh(remote_f_teid->teid);
    if (remote_f_teid->ipv4 && remote_f_teid->ipv6) {
        ogs_error("User plane should not set both IPv4 and IPv6");
        return NULL;
    } else if (remote_f_teid->ipv4) {
        len = OGS_IPV4_LEN;
        memcpy(addr, &remote_f_teid->addr, len);
    } else if (remote_f_teid->ipv6) {
        len = OGS_IPV6_LEN;
        memcpy(addr, remote_f_teid->addr6, len);
    } else {
        ogs_error("No IPv4 and IPv6");
        return NULL;
    }

    ogs_list_for_each(&sess->far_list, far) {
        if (teid == far->outer_header_creation.teid)
            return far;
    }

    ogs_error("Cannot find the session context "
            "[TEID:0x%x,LEN:%d,ADDR:%08x %08x %08x %08x]",
            teid, len, be32toh(addr[0]), be32toh(addr[1]),
            be32toh(addr[2]), be32toh(addr[3]));

    return NULL;
}

void ogs_pfcp_far_teid_hash_set(ogs_pfcp_far_t *far)
{
    ogs_assert(far);

    if (far->hash.teid.len)
        ogs_hash_set(self.far_teid_hash,
                &far->hash.teid.key, far->hash.teid.len, NULL);

    far->hash.teid.key = far->outer_header_creation.teid;
    far->hash.teid.len = sizeof(far->hash.teid.key);

    ogs_hash_set(self.far_teid_hash,
            &far->hash.teid.key, far->hash.teid.len, far);
}

ogs_pfcp_far_t *ogs_pfcp_far_find_by_teid(uint32_t teid)
{
    return (ogs_pfcp_far_t *)ogs_hash_get(
            self.far_teid_hash, &teid, sizeof(teid));
}

void ogs_pfcp_far_remove(ogs_pfcp_far_t *far)
{
    int i;
    ogs_pfcp_sess_t *sess = NULL;

    ogs_assert(far);
    sess = far->sess;
    ogs_assert(sess);

    ogs_list_remove(&sess->far_list, far);

    if (far->hash.teid.len)
        ogs_hash_set(self.far_teid_hash,
                &far->hash.teid.key, far->hash.teid.len, NULL);

    if (far->hash.f_teid.len)
        ogs_hash_set(self.far_f_teid_hash,
                &far->hash.f_teid.key, far->hash.f_teid.len, NULL);

    if (far->dnn)
        ogs_free(far->dnn);

    for (i = 0; i < far->num_of_buffered_packet; i++)
        ogs_pkbuf_free(far->buffered_packet[i]);

    if (far->id_node)
        ogs_pool_free(&far->sess->far_id_pool, far->id_node);

    ogs_pool_free(&ogs_pfcp_far_pool, far);
}

void ogs_pfcp_far_remove_all(ogs_pfcp_sess_t *sess)
{
    ogs_pfcp_far_t *far = NULL, *next_far = NULL;

    ogs_assert(sess);

    ogs_list_for_each_safe(&sess->far_list, next_far, far)
        ogs_pfcp_far_remove(far);
}

ogs_pfcp_urr_t *ogs_pfcp_urr_add(ogs_pfcp_sess_t *sess)
{
    ogs_pfcp_urr_t *urr = NULL;

    ogs_assert(sess);

    ogs_pool_alloc(&ogs_pfcp_urr_pool, &urr);
    if (urr == NULL) {
        ogs_error("urr_pool() failed");
        return NULL;
    }
    memset(urr, 0, sizeof *urr);

    ogs_pool_alloc(&sess->urr_id_pool, &urr->id_node);
    if (urr->id_node == NULL) {
        ogs_error("urr_id_pool() failed");
        ogs_pool_free(&ogs_pfcp_urr_pool, urr);
        return NULL;
    }

    urr->id = *(urr->id_node);
    ogs_assert(urr->id > 0 && urr->id <= OGS_MAX_NUM_OF_URR);

    urr->sess = sess;
    ogs_list_add(&sess->urr_list, urr);

    return urr;
}

ogs_pfcp_urr_t *ogs_pfcp_urr_find(
        ogs_pfcp_sess_t *sess, ogs_pfcp_urr_id_t id)
{
    ogs_pfcp_urr_t *urr = NULL;

    ogs_assert(sess);

    ogs_list_for_each(&sess->urr_list, urr)
        if (urr->id == id) return urr;

    return NULL;
}

ogs_pfcp_urr_t *ogs_pfcp_urr_find_or_add(
        ogs_pfcp_sess_t *sess, ogs_pfcp_urr_id_t id)
{
    ogs_pfcp_urr_t *urr = NULL;

    ogs_assert(sess);

    urr = ogs_pfcp_urr_find(sess, id);
    if (!urr) {
        urr = ogs_pfcp_urr_add(sess);
        ogs_assert(urr);
        urr->id = id;
    }

    return urr;
}

void ogs_pfcp_urr_remove(ogs_pfcp_urr_t *urr)
{
    ogs_pfcp_sess_t *sess = NULL;

    ogs_assert(urr);
    sess = urr->sess;
    ogs_assert(sess);

    ogs_list_remove(&sess->urr_list, urr);

    if (urr->id_node)
        ogs_pool_free(&urr->sess->urr_id_pool, urr->id_node);

    ogs_pool_free(&ogs_pfcp_urr_pool, urr);
}

void ogs_pfcp_urr_remove_all(ogs_pfcp_sess_t *sess)
{
    ogs_pfcp_urr_t *urr = NULL, *next_urr = NULL;

    ogs_assert(sess);

    ogs_list_for_each_safe(&sess->urr_list, next_urr, urr)
        ogs_pfcp_urr_remove(urr);
}

ogs_pfcp_qer_t *ogs_pfcp_qer_add(ogs_pfcp_sess_t *sess)
{
    ogs_pfcp_qer_t *qer = NULL;

    ogs_assert(sess);

    ogs_pool_alloc(&ogs_pfcp_qer_pool, &qer);
    if (qer == NULL) {
        ogs_error("qer_pool() failed");
        return NULL;
    }
    memset(qer, 0, sizeof *qer);

    ogs_pool_alloc(&sess->qer_id_pool, &qer->id_node);
    if (qer->id_node == NULL) {
        ogs_error("qer_id_pool() failed");
        ogs_pool_free(&ogs_pfcp_qer_pool, qer);
        return NULL;
    }

    qer->id = *(qer->id_node);
    ogs_assert(qer->id > 0 && qer->id <= OGS_MAX_NUM_OF_QER);

    qer->sess = sess;
    ogs_list_add(&sess->qer_list, qer);

    return qer;
}

ogs_pfcp_qer_t *ogs_pfcp_qer_find(
        ogs_pfcp_sess_t *sess, ogs_pfcp_qer_id_t id)
{
    ogs_pfcp_qer_t *qer = NULL;

    ogs_assert(sess);

    ogs_list_for_each(&sess->qer_list, qer)
        if (qer->id == id) return qer;

    return NULL;
}

ogs_pfcp_qer_t *ogs_pfcp_qer_find_or_add(
        ogs_pfcp_sess_t *sess, ogs_pfcp_qer_id_t id)
{
    ogs_pfcp_qer_t *qer = NULL;

    ogs_assert(sess);

    qer = ogs_pfcp_qer_find(sess, id);
    if (!qer) {
        qer = ogs_pfcp_qer_add(sess);
        ogs_assert(qer);
        qer->id = id;
    }

    return qer;
}

void ogs_pfcp_qer_remove(ogs_pfcp_qer_t *qer)
{
    ogs_pfcp_sess_t *sess = NULL;

    ogs_assert(qer);
    sess = qer->sess;
    ogs_assert(sess);

    ogs_list_remove(&sess->qer_list, qer);

    if (qer->id_node)
        ogs_pool_free(&qer->sess->qer_id_pool, qer->id_node);

    ogs_pool_free(&ogs_pfcp_qer_pool, qer);
}

void ogs_pfcp_qer_remove_all(ogs_pfcp_sess_t *sess)
{
    ogs_pfcp_qer_t *qer = NULL, *next_qer = NULL;

    ogs_assert(sess);

    ogs_list_for_each_safe(&sess->qer_list, next_qer, qer)
        ogs_pfcp_qer_remove(qer);
}

ogs_pfcp_bar_t *ogs_pfcp_bar_new(ogs_pfcp_sess_t *sess)
{
    ogs_pfcp_bar_t *bar = NULL;

    ogs_assert(sess);
    ogs_assert(sess->bar == NULL); /* Only One BAR is supported */

    ogs_pool_alloc(&ogs_pfcp_bar_pool, &bar);
    ogs_assert(bar);
    memset(bar, 0, sizeof *bar);

    ogs_pool_alloc(&sess->bar_id_pool, &bar->id_node);
    ogs_assert(bar->id_node);

    bar->id = *(bar->id_node);
    ogs_assert(bar->id > 0 && bar->id <= OGS_MAX_NUM_OF_BAR);

    bar->sess = sess;
    sess->bar = bar;

    return bar;
}

void ogs_pfcp_bar_delete(ogs_pfcp_bar_t *bar)
{
    ogs_pfcp_sess_t *sess = NULL;

    ogs_assert(bar);
    sess = bar->sess;
    ogs_assert(sess);

    if (bar->id_node)
        ogs_pool_free(&bar->sess->bar_id_pool, bar->id_node);

    bar->sess = NULL;
    sess->bar = NULL;

    ogs_pool_free(&ogs_pfcp_bar_pool, bar);
}

ogs_pfcp_rule_t *ogs_pfcp_rule_add(ogs_pfcp_pdr_t *pdr)
{
    ogs_pfcp_rule_t *rule = NULL;

    ogs_assert(pdr);

    ogs_pool_alloc(&ogs_pfcp_rule_pool, &rule);
    ogs_assert(rule);
    memset(rule, 0, sizeof *rule);

    rule->pdr = pdr;
    ogs_list_add(&pdr->rule_list, rule);

    return rule;
}

ogs_pfcp_rule_t *ogs_pfcp_rule_find_by_sdf_filter_id(
        ogs_pfcp_sess_t *sess, uint32_t sdf_filter_id)
{
    ogs_pfcp_pdr_t *pdr = NULL;
    ogs_pfcp_rule_t *rule = NULL;

    ogs_assert(sess);

    ogs_list_for_each(&sess->pdr_list, pdr) {
        ogs_list_for_each(&pdr->rule_list, rule) {
            if (rule->bid && rule->sdf_filter_id == sdf_filter_id)
                return rule;
        }
    }

    return NULL;
}

void ogs_pfcp_rule_remove(ogs_pfcp_rule_t *rule)
{
    ogs_pfcp_pdr_t *pdr = NULL;

    ogs_assert(rule);
    pdr = rule->pdr;
    ogs_assert(pdr);

    ogs_list_remove(&pdr->rule_list, rule);
    ogs_pool_free(&ogs_pfcp_rule_pool, rule);
}

void ogs_pfcp_rule_remove_all(ogs_pfcp_pdr_t *pdr)
{
    ogs_pfcp_rule_t *rule = NULL, *next_rule = NULL;

    ogs_assert(pdr);

    ogs_list_for_each_safe(&pdr->rule_list, next_rule, rule)
        ogs_pfcp_rule_remove(rule);
}

int ogs_pfcp_ue_pool_generate(void)
{
    int i, rv;
    ogs_pfcp_subnet_t *subnet = NULL;

    ogs_list_for_each(&self.subnet_list, subnet) {
        int maxbytes = 0;
        int lastindex = 0;
        uint32_t start[4], end[4], broadcast[4];
        int rangeindex, num_of_range;
        int poolindex;
        int inc;

        if (subnet->family == AF_INET) {
            maxbytes = 4;
            lastindex = 0;
        } else if (subnet->family == AF_INET6) {
            maxbytes = 8; /* Default Prefixlen 64bits */
            lastindex = 1;
        } else {
            /* subnet->family might be AF_UNSPEC. So, skip it */
            continue;
        }

        for (i = 0; i < 4; i++) {
            broadcast[i] = subnet->sub.sub[i] + ~subnet->sub.mask[i];
        }

        num_of_range = subnet->num_of_range;
        if (!num_of_range) num_of_range = 1;

        poolindex = 0;
        for (rangeindex = 0; rangeindex < num_of_range; rangeindex++) {

            if (subnet->num_of_range &&
                subnet->range[rangeindex].low) {
                ogs_ipsubnet_t low;
                rv = ogs_ipsubnet(&low, subnet->range[rangeindex].low, NULL);
                ogs_assert(rv == OGS_OK);
                memcpy(start, low.sub, maxbytes);
            } else {
                memcpy(start, subnet->sub.sub, maxbytes);
            }

            if (subnet->num_of_range &&
                subnet->range[rangeindex].high) {
                ogs_ipsubnet_t high;
                rv = ogs_ipsubnet(&high, subnet->range[rangeindex].high, NULL);
                ogs_assert(rv == OGS_OK);
                high.sub[lastindex] += htobe32(1);
                memcpy(end, high.sub, maxbytes);
            } else {
                memcpy(end, broadcast, maxbytes);
            }

            inc = 0;
            while(poolindex < ogs_app()->pool.sess) {
                ogs_pfcp_ue_ip_t *ue_ip = NULL;

                ue_ip = &subnet->pool.array[poolindex];
                ogs_assert(ue_ip);
                memset(ue_ip, 0, sizeof *ue_ip);
                ue_ip->subnet = subnet;

                memcpy(ue_ip->addr, start, maxbytes);
                ue_ip->addr[lastindex] += htobe32(inc);
                inc++;

                if (memcmp(ue_ip->addr, end, maxbytes) == 0)
                    break;

                /* Exclude Network Address */
                if (memcmp(ue_ip->addr, subnet->sub.sub, maxbytes) == 0)
                    continue;

                /* Exclude TUN IP Address */
                if (memcmp(ue_ip->addr, subnet->gw.sub, maxbytes) == 0)
                    continue;

                /* Allocate Full IPv6 Address */
                if (lastindex == 1)
                    ue_ip->addr[3] += htobe32(inc);

                ogs_trace("[%d] - %x:%x:%x:%x",
                        poolindex,
                        ue_ip->addr[0], ue_ip->addr[1],
                        ue_ip->addr[2], ue_ip->addr[3]);

                poolindex++;
            }
        }
        subnet->pool.size = subnet->pool.avail = poolindex;
    }

    return OGS_OK;
}

ogs_pfcp_ue_ip_t *ogs_pfcp_ue_ip_alloc(
        uint8_t *cause_value, int family, const char *dnn, uint8_t *addr)
{
    ogs_pfcp_subnet_t *subnet = NULL;
    ogs_pfcp_ue_ip_t *ue_ip = NULL;

    uint8_t zero[16];
    size_t maxbytes = 0;

    memset(zero, 0, sizeof zero);
    if (family == AF_INET) {
        maxbytes = 4;
    } else if (family == AF_INET6) {
        maxbytes = 16;
    } else {
        ogs_error("Invalid family[%d]", family);
        ogs_assert_if_reached();
        return NULL;
    }

    if (dnn)
        subnet = ogs_pfcp_find_subnet_by_dnn(family, dnn);
    else
        subnet = ogs_pfcp_find_subnet(family);

    if (subnet == NULL) {
        ogs_error("All IP addresses in all subnets are occupied");
        *cause_value = OGS_PFCP_CAUSE_NO_RESOURCES_AVAILABLE;
        return NULL;
    }

    /* if assigning a static IP, do so. If not, assign dynamically! */
    if (memcmp(addr, zero, maxbytes) != 0) {
        ue_ip = ogs_calloc(1, sizeof(ogs_pfcp_ue_ip_t));
        if (!ue_ip) {
            ogs_error("All dynamic addresses are occupied");
            *cause_value = OGS_PFCP_CAUSE_ALL_DYNAMIC_ADDRESS_ARE_OCCUPIED;
            return NULL;
        }

        ue_ip->subnet = subnet;
        ue_ip->static_ip = true;
        memcpy(ue_ip->addr, addr, maxbytes);
    } else {
        ogs_pool_alloc(&subnet->pool, &ue_ip);
        if (!ue_ip) {
            ogs_error("No resources available");
            *cause_value = OGS_PFCP_CAUSE_NO_RESOURCES_AVAILABLE;
            return NULL;
        }
    }

    return ue_ip;
}

void ogs_pfcp_ue_ip_free(ogs_pfcp_ue_ip_t *ue_ip)
{
    ogs_pfcp_subnet_t *subnet = NULL;

    ogs_assert(ue_ip);
    subnet = ue_ip->subnet;

    ogs_assert(subnet);

    if (ue_ip->static_ip) {
        ogs_free(ue_ip);
    } else {
        ogs_pool_free(&subnet->pool, ue_ip);
    }
}

ogs_pfcp_dev_t *ogs_pfcp_dev_add(const char *ifname)
{
    ogs_pfcp_dev_t *dev = NULL;

    ogs_assert(ifname);

    ogs_pool_alloc(&ogs_pfcp_dev_pool, &dev);
    ogs_assert(dev);
    memset(dev, 0, sizeof *dev);

    ogs_cpystrn(dev->ifname, ifname, OGS_MAX_IFNAME_LEN-1);

    ogs_list_add(&self.dev_list, dev);

    return dev;
}

void ogs_pfcp_dev_remove(ogs_pfcp_dev_t *dev)
{
    ogs_assert(dev);

    ogs_list_remove(&self.dev_list, dev);
    ogs_pool_free(&ogs_pfcp_dev_pool, dev);
}

void ogs_pfcp_dev_remove_all(void)
{
    ogs_pfcp_dev_t *dev = NULL, *next_dev = NULL;

    ogs_list_for_each_safe(&self.dev_list, next_dev, dev)
        ogs_pfcp_dev_remove(dev);
}

ogs_pfcp_dev_t *ogs_pfcp_dev_find_by_ifname(const char *ifname)
{
    ogs_pfcp_dev_t *dev = NULL;

    ogs_assert(ifname);

    ogs_list_for_each(&ogs_pfcp_self()->dev_list, dev) {
        if (ogs_strcasecmp(dev->ifname, ifname) == 0)
            return dev;
    }

    return OGS_OK;
}

ogs_pfcp_subnet_t *ogs_pfcp_subnet_add(
        const char *ipstr, const char *mask_or_numbits,
        const char *gateway, const char *dnn, const char *ifname)
{
    int rv;
    ogs_pfcp_dev_t *dev = NULL;
    ogs_pfcp_subnet_t *subnet = NULL;

    ogs_assert(ifname);

    dev = ogs_pfcp_dev_find_by_ifname(ifname);
    if (!dev)
        dev = ogs_pfcp_dev_add(ifname);
    ogs_assert(dev);

    ogs_pool_alloc(&ogs_pfcp_subnet_pool, &subnet);
    ogs_assert(subnet);
    memset(subnet, 0, sizeof *subnet);

    subnet->family = AF_UNSPEC;
    subnet->dev = dev;

    if (ipstr && mask_or_numbits) {
        rv = ogs_ipsubnet(&subnet->gw, ipstr, NULL);
        ogs_assert(rv == OGS_OK);

        rv = ogs_ipsubnet(&subnet->sub, ipstr, mask_or_numbits);
        ogs_assert(rv == OGS_OK);

        subnet->family = subnet->gw.family;
        subnet->prefixlen = atoi(mask_or_numbits);

        if (memcmp(subnet->gw.sub, subnet->sub.sub,
                    sizeof(subnet->gw.sub)) != 0) {
            char *subnet_string = NULL;

            if (subnet->family == AF_INET) {
                subnet_string = ogs_ipv4_to_string(subnet->sub.sub[0]);
                ogs_assert(subnet_string);
            } else if (subnet->family == AF_INET6) {
                subnet_string = ogs_ipv6addr_to_string(
                        (uint8_t*)&subnet->sub.sub[0]);
                ogs_assert(subnet_string);
            }

            ogs_warn("Please change the configuration files of "
                    "smf.yaml and upf.yaml as below.");
            ogs_log_print(OGS_LOG_WARN, "\n<OLD Format>\n");
            ogs_log_print(OGS_LOG_WARN, "smf:\n");
            ogs_log_print(OGS_LOG_WARN, "  session:\n");
            ogs_log_print(OGS_LOG_WARN, "    - subnet: %s/%s\n",
                    ipstr, mask_or_numbits);
            ogs_log_print(OGS_LOG_WARN, "\n<NEW Format>\n");
            ogs_log_print(OGS_LOG_WARN, "smf:\n");
            ogs_log_print(OGS_LOG_WARN, "  session:\n");
            ogs_log_print(OGS_LOG_WARN, "    - subnet: %s/%s\n",
                    subnet_string ? subnet_string : "Unknown", mask_or_numbits);
            ogs_log_print(OGS_LOG_WARN, "      gateway: %s\n\n\n", ipstr);

            ogs_free(subnet_string);
        }
    }

    if (gateway) {
        rv = ogs_ipsubnet(&subnet->gw, gateway, NULL);
        ogs_assert(rv == OGS_OK);
    }

    if (dnn)
        ogs_cpystrn(subnet->dnn, dnn, OGS_MAX_DNN_LEN);

    ogs_pool_init(&subnet->pool, ogs_app()->pool.sess);

    ogs_list_add(&self.subnet_list, subnet);

    return subnet;
}

void ogs_pfcp_subnet_remove(ogs_pfcp_subnet_t *subnet)
{
    ogs_assert(subnet);

    ogs_list_remove(&self.subnet_list, subnet);

    ogs_pool_final(&subnet->pool);

    ogs_pool_free(&ogs_pfcp_subnet_pool, subnet);
}

void ogs_pfcp_subnet_remove_all(void)
{
    ogs_pfcp_subnet_t *subnet = NULL, *next_subnet = NULL;

    ogs_list_for_each_safe(&self.subnet_list, next_subnet, subnet)
        ogs_pfcp_subnet_remove(subnet);
}

ogs_pfcp_subnet_t *ogs_pfcp_find_subnet(int family)
{
    ogs_pfcp_subnet_t *subnet = NULL;

    ogs_assert(family == AF_INET || family == AF_INET6);

    ogs_list_for_each(&self.subnet_list, subnet) {
        if ((subnet->family == AF_UNSPEC || subnet->family == family) &&
            (strlen(subnet->dnn) == 0) &&
            subnet->pool.avail)
            break;
    }

    return subnet;
}

ogs_pfcp_subnet_t *ogs_pfcp_find_subnet_by_dnn(int family, const char *dnn)
{
    ogs_pfcp_subnet_t *subnet = NULL;

    ogs_assert(dnn);
    ogs_assert(family == AF_INET || family == AF_INET6);

    ogs_list_for_each(&self.subnet_list, subnet) {
        if ((subnet->family == AF_UNSPEC || subnet->family == family) &&
            (strlen(subnet->dnn) == 0 ||
                (strlen(subnet->dnn) && ogs_strcasecmp(subnet->dnn, dnn) == 0)) &&
            subnet->pool.avail)
            break;
    }

    return subnet;
}

void ogs_pfcp_pool_init(ogs_pfcp_sess_t *sess)
{
    ogs_assert(sess);

    sess->obj.type = OGS_PFCP_OBJ_SESS_TYPE;

    ogs_pool_create(&sess->pdr_id_pool, OGS_MAX_NUM_OF_PDR);
    ogs_pool_create(&sess->far_id_pool, OGS_MAX_NUM_OF_FAR);
    ogs_pool_create(&sess->urr_id_pool, OGS_MAX_NUM_OF_URR);
    ogs_pool_create(&sess->qer_id_pool, OGS_MAX_NUM_OF_QER);
    ogs_pool_create(&sess->bar_id_pool, OGS_MAX_NUM_OF_BAR);

    ogs_pool_sequence_id_generate(&sess->pdr_id_pool);
    ogs_pool_sequence_id_generate(&sess->far_id_pool);
    ogs_pool_sequence_id_generate(&sess->urr_id_pool);
    ogs_pool_sequence_id_generate(&sess->qer_id_pool);
    ogs_pool_sequence_id_generate(&sess->bar_id_pool);
}
void ogs_pfcp_pool_final(ogs_pfcp_sess_t *sess)
{
    ogs_assert(sess);

    ogs_pool_destroy(&sess->pdr_id_pool);
    ogs_pool_destroy(&sess->far_id_pool);
    ogs_pool_destroy(&sess->urr_id_pool);
    ogs_pool_destroy(&sess->qer_id_pool);
    ogs_pool_destroy(&sess->bar_id_pool);
}
===== context.h =====

#if !defined(OGS_PFCP_INSIDE) && !defined(OGS_PFCP_COMPILATION)
#error "This header cannot be included directly."
#endif

#ifndef OGS_PFCP_CONTEXT_H
#define OGS_PFCP_CONTEXT_H

#ifdef __cplusplus
extern "C" {
#endif

#define OGS_PFCP_DEFAULT_PDR_PRECEDENCE 65535
#define OGS_PFCP_INDIRECT_PDR_PRECEDENCE 4096
#define OGS_PFCP_UP2CP_PDR_PRECEDENCE 255
#define OGS_PFCP_CP2UP_PDR_PRECEDENCE 255

#define OGS_PFCP_DEFAULT_CHOOSE_ID 5
#define OGS_PFCP_INDIRECT_DATA_FORWARDING_CHOOSE_ID 10

#define OGS_MAX_NUM_OF_DEV      16
#define OGS_MAX_NUM_OF_SUBNET   16

typedef struct ogs_pfcp_node_s ogs_pfcp_node_t;

typedef struct ogs_pfcp_context_s {
    uint32_t        pfcp_port;      /* PFCP local port */

    const char      *tun_ifname;    /* PFCP TUN Interface Name */

    ogs_list_t      pfcp_list;      /* PFCP IPv4 Server List */
    ogs_list_t      pfcp_list6;     /* PFCP IPv6 Server List */
    ogs_sockaddr_t  *pfcp_advertise; /* PFCP Advertise Addr */
    ogs_sockaddr_t  *pfcp_advertise6;
    ogs_sock_t      *pfcp_sock;     /* PFCP IPv4 Socket */
    ogs_sock_t      *pfcp_sock6;    /* PFCP IPv6 Socket */
    ogs_sockaddr_t  *pfcp_addr;     /* PFCP IPv4 Address */
    ogs_sockaddr_t  *pfcp_addr6;    /* PFCP IPv6 Address */

    uint32_t        local_recovery; /* UTC time */

    /* CP Function Features */
    ogs_pfcp_cp_function_features_t cp_function_features;
    /* UP Function Features */
    ogs_pfcp_up_function_features_t up_function_features;
    int up_function_features_len;

    ogs_list_t      pfcp_peer_list; /* PFCP Node List */
    ogs_pfcp_node_t *pfcp_node;     /* Iterator for Peer round-robin */

    ogs_list_t      dev_list;       /* Tun Device List */
    ogs_list_t      subnet_list;    /* UE Subnet List */

    ogs_hash_t      *object_teid_hash; /* hash table for PFCP OBJ(TEID) */
    ogs_hash_t      *far_f_teid_hash;  /* hash table for FAR(TEID+ADDR) */
    ogs_hash_t      *far_teid_hash; /* hash table for FAR(TEID) */
} ogs_pfcp_context_t;

#define OGS_SETUP_PFCP_NODE(__cTX, __pNODE) \
    do { \
        ogs_assert((__cTX)); \
        ogs_assert((__pNODE)); \
        (__cTX)->pfcp_node = __pNODE; \
    } while(0)

typedef struct ogs_pfcp_node_s {
    ogs_lnode_t     lnode;          /* A node of list_t */

    ogs_sockaddr_t  *config_addr; /* Configured addresses */
    ogs_pfcp_node_id_t node_id;     /* PFCP node ID */

    /* List of addresses:: final merged address list */
    ogs_sockaddr_t  *addr_list;

     /*
     * Iterator for round-robin sendto operations.
     * Points to the current address in the round-robin sequence.
     */
    ogs_sockaddr_t  *current_addr;

    /* Timestamp of last DNS refresh for FQDN nodes. */
    ogs_time_t      last_dns_refresh;

    ogs_list_t      local_list;
    ogs_list_t      remote_list;

    ogs_fsm_t       sm;             /* A state machine */
    ogs_timer_t     *t_association; /* timer to retry to associate peer node */
    ogs_timer_t     *t_no_heartbeat; /* heartbeat timer to check aliveness */

    uint16_t        tac[OGS_MAX_NUM_OF_TAI];
    uint8_t         num_of_tac;
    const char*     dnn[OGS_MAX_NUM_OF_DNN];
    uint8_t         num_of_dnn;
    uint32_t        e_cell_id[OGS_MAX_NUM_OF_CELL_ID];
    uint8_t         num_of_e_cell_id;
    uint64_t        nr_cell_id[OGS_MAX_NUM_OF_CELL_ID];
    uint8_t         num_of_nr_cell_id;

    uint32_t        remote_recovery; /* UTC time */
    bool            restoration_required;

    ogs_list_t      gtpu_resource_list; /* User Plane IP Resource Information */

    ogs_pfcp_up_function_features_t up_function_features;
    int up_function_features_len;
} ogs_pfcp_node_t;

typedef enum {
    OGS_PFCP_OBJ_BASE = 0,

    OGS_PFCP_OBJ_SESS_TYPE,
    OGS_PFCP_OBJ_PDR_TYPE,

    OGS_PFCP_OBJ_TOP,
} ogs_pfcp_object_type_e;

typedef struct ogs_pfcp_object_s {
    ogs_lnode_t lnode;
    ogs_pfcp_object_type_e type;
} ogs_pfcp_object_t;

typedef struct ogs_pfcp_sess_s ogs_pfcp_sess_t;
typedef struct ogs_pfcp_pdr_s ogs_pfcp_pdr_t;
typedef struct ogs_pfcp_far_s ogs_pfcp_far_t;
typedef struct ogs_pfcp_urr_s ogs_pfcp_urr_t;
typedef struct ogs_pfcp_qer_s ogs_pfcp_qer_t;
typedef struct ogs_pfcp_bar_s ogs_pfcp_bar_t;

typedef struct ogs_pfcp_pdr_s {
    ogs_pfcp_object_t       obj;

    ogs_pool_id_t           *teid_node;  /* A node of TEID */
    ogs_pool_id_t           teid;

    ogs_lnode_t             to_create_node;
    ogs_lnode_t             to_modify_node;

    struct {
        struct {
            int len;
            uint32_t key;
        } teid;
    } hash;

    uint8_t                 *id_node;      /* Pool-Node for ID */
    ogs_pfcp_pdr_id_t       id;
    ogs_pfcp_precedence_t   precedence;
    ogs_pfcp_interface_t    src_if;

    bool src_if_type_presence;
    ogs_pfcp_3gpp_interface_type_t src_if_type;

    union {
        char *apn;
        char *dnn;
    };

    ogs_pfcp_ue_ip_addr_t   ue_ip_addr;
    int                     ue_ip_addr_len;

    char                    **ipv4_framed_routes;
    char                    **ipv6_framed_routes;

    ogs_pfcp_f_teid_t       f_teid;
    int                     f_teid_len;

    bool                    chid;
    uint8_t                 choose_id;

    ogs_pfcp_outer_header_removal_t outer_header_removal;
    int                     outer_header_removal_len;

    uint8_t                 qfi;

    ogs_pfcp_far_t          *far;

    int                     num_of_urr;
    ogs_pfcp_urr_t          *urr[OGS_MAX_NUM_OF_URR];

    ogs_pfcp_qer_t          *qer;

    int                     num_of_flow;
    struct {
        union {
            struct {
    ED6(uint8_t     spare1:3;,
        uint8_t     bid:1;,
        uint8_t     fl:1;,
        uint8_t     spi:1;,
        uint8_t     ttc:1;,
        uint8_t     fd:1;)
            };
            uint8_t flags;
        };
        char *description;
        uint32_t sdf_filter_id;
    } flow[OGS_MAX_NUM_OF_FLOW_IN_PDR];;

    ogs_list_t              rule_list;      /* Rule List */

    /* Related Context */
    ogs_pfcp_sess_t         *sess;
    void                    *gnode;         /* For CP-Function */
} ogs_pfcp_pdr_t;

typedef struct ogs_pfcp_far_hash_f_teid_s {
    uint32_t teid;
    uint32_t addr[4];
} ogs_pfcp_far_hash_f_teid_t;

typedef struct ogs_pfcp_far_s {
    ogs_lnode_t             lnode;

    struct {
        struct {
            int len;
            ogs_pfcp_far_hash_f_teid_t key;
        } f_teid;

        struct {
            int len;
            uint32_t key;
        } teid;
    } hash;

    union {
        char *apn;
        char *dnn;
    };

    uint8_t                 *id_node;      /* Pool-Node for ID */
    ogs_pfcp_far_id_t       id;
    ogs_pfcp_apply_action_t apply_action;
    ogs_pfcp_interface_t    dst_if;

    bool dst_if_type_presence;
    ogs_pfcp_3gpp_interface_type_t dst_if_type;

    ogs_pfcp_outer_header_creation_t outer_header_creation;
    int                     outer_header_creation_len;

    ogs_pfcp_smreq_flags_t  smreq_flags;

    uint32_t                num_of_buffered_packet;
    ogs_pkbuf_t             *buffered_packet[OGS_MAX_NUM_OF_PACKET_BUFFER];

    struct {
        bool prepared;
    } handover; /* Saved from N2-Handover Request Acknowledge */

    /* Related Context */
    ogs_pfcp_sess_t         *sess;
    void                    *gnode;
} ogs_pfcp_far_t;

typedef struct ogs_pfcp_urr_s {
    ogs_lnode_t             lnode;

    uint8_t                 *id_node;      /* Pool-Node for ID */
    ogs_pfcp_urr_id_t       id;

    ogs_pfcp_measurement_method_t meas_method;
    ogs_pfcp_reporting_triggers_t rep_triggers;
    ogs_pfcp_measurement_information_t meas_info;
    ogs_pfcp_measurement_period_t meas_period;

    ogs_pfcp_volume_threshold_t vol_threshold;
    ogs_pfcp_volume_quota_t vol_quota;

    ogs_pfcp_event_threshold_t event_threshold;
    ogs_pfcp_event_quota_t event_quota;

    ogs_pfcp_time_threshold_t time_threshold;
    ogs_pfcp_time_quota_t time_quota;

    ogs_pfcp_quota_holding_time_t quota_holding_time;

    ogs_pfcp_dropped_dl_traffic_threshold_t dropped_dl_traffic_threshold;

    ogs_pfcp_quota_validity_time_t quota_validity_time;

    ogs_pfcp_sess_t         *sess;
} ogs_pfcp_urr_t;

typedef struct ogs_pfcp_qer_s {
    ogs_lnode_t             lnode;

    uint8_t                 *id_node;      /* Pool-Node for ID */
    ogs_pfcp_qer_id_t       id;

    ogs_pfcp_gate_status_t  gate_status;
    ogs_pfcp_bitrate_t      mbr;
    ogs_pfcp_bitrate_t      gbr;

    uint8_t                 qfi;

    ogs_pfcp_sess_t         *sess;
} ogs_pfcp_qer_t;

typedef struct ogs_pfcp_bar_s {
    ogs_lnode_t             lnode;

    uint8_t                 *id_node;      /* Pool-Node for ID */
    ogs_pfcp_bar_id_t       id;

    ogs_pfcp_sess_t         *sess;
} ogs_pfcp_bar_t;

typedef struct ogs_pfcp_sess_s {
    ogs_pfcp_object_t   obj;

    ogs_list_t          pdr_list;       /* PDR List */
    ogs_list_t          far_list;       /* FAR List */
    ogs_list_t          urr_list;       /* URR List */
    ogs_list_t          qer_list;       /* QER List */
    ogs_pfcp_bar_t      *bar;           /* BAR Item */

    OGS_POOL(pdr_id_pool, uint8_t);
    OGS_POOL(far_id_pool, uint8_t);
    OGS_POOL(urr_id_pool, uint8_t);
    OGS_POOL(qer_id_pool, uint8_t);
    OGS_POOL(bar_id_pool, uint8_t);
} ogs_pfcp_sess_t;

typedef struct ogs_pfcp_subnet_s ogs_pfcp_subnet_t;
typedef struct ogs_pfcp_ue_ip_s {
    uint32_t        addr[4];
    bool            static_ip;

    /* Related Context */
    ogs_pfcp_subnet_t    *subnet;
} ogs_pfcp_ue_ip_t;

typedef struct ogs_pfcp_dev_s {
    ogs_lnode_t     lnode;

    char            ifname[OGS_MAX_IFNAME_LEN];
    ogs_socket_t    fd;

    ogs_poll_t      *poll;
    bool            is_tap;
    uint8_t         mac_addr[6];
} ogs_pfcp_dev_t;

typedef struct ogs_pfcp_subnet_s {
    ogs_lnode_t     lnode;

    ogs_ipsubnet_t  sub;                    /* Subnet : 2001:db8:cafe::0/48 */
    ogs_ipsubnet_t  gw;                     /* Gateway : 2001:db8:cafe::1 */
    char            dnn[OGS_MAX_DNN_LEN+1]; /* DNN : "internet", "volte", .. */

#define OGS_MAX_NUM_OF_SUBNET_RANGE 16
    struct {
        const char *low;
        const char *high;
    } range[OGS_MAX_NUM_OF_SUBNET_RANGE];
    int num_of_range;

    int             family;         /* AF_INET or AF_INET6 */
    uint8_t         prefixlen;      /* prefixlen */
    OGS_POOL(pool, ogs_pfcp_ue_ip_t);

    ogs_pfcp_dev_t  *dev;           /* Related Context */
} ogs_pfcp_subnet_t;

typedef struct ogs_pfcp_rule_s {
    ogs_lnode_t lnode;

    union {
        struct {
ED6(uint8_t     spare1:3;,
    uint8_t     bid:1;,
    uint8_t     fl:1;,
    uint8_t     spi:1;,
    uint8_t     ttc:1;,
    uint8_t     fd:1;)
        };
        uint8_t flags;
    };

    ogs_ipfw_rule_t ipfw;
    uint32_t sdf_filter_id;

    /* Related Context */
    ogs_pfcp_pdr_t  *pdr;
} ogs_pfcp_rule_t;

void ogs_pfcp_context_init(void);
void ogs_pfcp_context_final(void);
ogs_pfcp_context_t *ogs_pfcp_self(void);
int ogs_pfcp_context_parse_config(const char *local, const char *remote);

ogs_pfcp_node_t *ogs_pfcp_node_new(ogs_sockaddr_t *config_addr);
void ogs_pfcp_node_free(ogs_pfcp_node_t *node);

ogs_pfcp_node_t *ogs_pfcp_node_add(ogs_list_t *list,
    ogs_pfcp_node_id_t *node_id, ogs_sockaddr_t *from);
ogs_pfcp_node_t *ogs_pfcp_node_find(ogs_list_t *list,
    ogs_pfcp_node_id_t *node_id, ogs_sockaddr_t *from);
int ogs_pfcp_node_merge(ogs_pfcp_node_t *node,
    ogs_pfcp_node_id_t *node_id, ogs_sockaddr_t *from);
void ogs_pfcp_node_remove(ogs_list_t *list, ogs_pfcp_node_t *node);
void ogs_pfcp_node_remove_all(ogs_list_t *list);
bool ogs_pfcp_node_id_compare(
        const ogs_pfcp_node_id_t *id1, const ogs_pfcp_node_id_t *id2);

ogs_gtpu_resource_t *ogs_pfcp_find_gtpu_resource(ogs_list_t *list,
        char *dnn, ogs_pfcp_interface_t source_interface);
int ogs_pfcp_setup_far_gtpu_node(ogs_pfcp_far_t *far);
int ogs_pfcp_setup_pdr_gtpu_node(ogs_pfcp_pdr_t *pdr);

void ogs_pfcp_sess_clear(ogs_pfcp_sess_t *sess);

ogs_pfcp_pdr_t *ogs_pfcp_pdr_add(ogs_pfcp_sess_t *sess);
ogs_pfcp_pdr_t *ogs_pfcp_pdr_find(
        ogs_pfcp_sess_t *sess, ogs_pfcp_pdr_id_t id);
ogs_pfcp_pdr_t *ogs_pfcp_pdr_find_or_add(
        ogs_pfcp_sess_t *sess, ogs_pfcp_pdr_id_t id);

int ogs_pfcp_pdr_swap_teid(ogs_pfcp_pdr_t *pdr);

void ogs_pfcp_object_teid_hash_set(
        ogs_pfcp_object_type_e type, ogs_pfcp_pdr_t *pdr,
        bool restoration_indication);
ogs_pfcp_object_t *ogs_pfcp_object_find_by_teid(uint32_t teid);
int ogs_pfcp_object_count_by_teid(ogs_pfcp_sess_t *sess, uint32_t teid);

ogs_pfcp_pdr_t *ogs_pfcp_pdr_find_by_choose_id(
        ogs_pfcp_sess_t *sess, uint8_t choose_id);

void ogs_pfcp_pdr_reorder_by_precedence(
        ogs_pfcp_pdr_t *pdr, ogs_pfcp_precedence_t precedence);
void ogs_pfcp_pdr_associate_far(ogs_pfcp_pdr_t *pdr, ogs_pfcp_far_t *far);
void ogs_pfcp_pdr_associate_urr(ogs_pfcp_pdr_t *pdr, ogs_pfcp_urr_t *urr);
void ogs_pfcp_pdr_associate_qer(ogs_pfcp_pdr_t *pdr, ogs_pfcp_qer_t *qer);
void ogs_pfcp_pdr_remove(ogs_pfcp_pdr_t *pdr);
void ogs_pfcp_pdr_remove_all(ogs_pfcp_sess_t *sess);

ogs_pfcp_far_t *ogs_pfcp_far_add(ogs_pfcp_sess_t *sess);
ogs_pfcp_far_t *ogs_pfcp_far_find(
        ogs_pfcp_sess_t *sess, ogs_pfcp_far_id_t id);
ogs_pfcp_far_t *ogs_pfcp_far_find_or_add(
        ogs_pfcp_sess_t *sess, ogs_pfcp_far_id_t id);

void ogs_pfcp_far_f_teid_hash_set(ogs_pfcp_far_t *far);
ogs_pfcp_far_t *ogs_pfcp_far_find_by_gtpu_error_indication(
        ogs_pkbuf_t *pkbuf);
ogs_pfcp_far_t *ogs_pfcp_far_find_by_pfcp_session_report(
        ogs_pfcp_sess_t *sess,
        ogs_pfcp_tlv_error_indication_report_t *error_indication_report);

void ogs_pfcp_far_teid_hash_set(ogs_pfcp_far_t *far);
ogs_pfcp_far_t *ogs_pfcp_far_find_by_teid(uint32_t teid);

void ogs_pfcp_far_remove(ogs_pfcp_far_t *far);
void ogs_pfcp_far_remove_all(ogs_pfcp_sess_t *sess);

ogs_pfcp_urr_t *ogs_pfcp_urr_add(ogs_pfcp_sess_t *sess);
ogs_pfcp_urr_t *ogs_pfcp_urr_find(
        ogs_pfcp_sess_t *sess, ogs_pfcp_urr_id_t id);
ogs_pfcp_urr_t *ogs_pfcp_urr_find_or_add(
        ogs_pfcp_sess_t *sess, ogs_pfcp_urr_id_t id);
void ogs_pfcp_urr_remove(ogs_pfcp_urr_t *urr);
void ogs_pfcp_urr_remove_all(ogs_pfcp_sess_t *sess);

ogs_pfcp_qer_t *ogs_pfcp_qer_add(ogs_pfcp_sess_t *sess);
ogs_pfcp_qer_t *ogs_pfcp_qer_find(
        ogs_pfcp_sess_t *sess, ogs_pfcp_qer_id_t id);
ogs_pfcp_qer_t *ogs_pfcp_qer_find_or_add(
        ogs_pfcp_sess_t *sess, ogs_pfcp_qer_id_t id);
void ogs_pfcp_qer_remove(ogs_pfcp_qer_t *qer);
void ogs_pfcp_qer_remove_all(ogs_pfcp_sess_t *sess);

ogs_pfcp_bar_t *ogs_pfcp_bar_new(ogs_pfcp_sess_t *sess);
void ogs_pfcp_bar_delete(ogs_pfcp_bar_t *bar);

ogs_pfcp_rule_t *ogs_pfcp_rule_add(ogs_pfcp_pdr_t *pdr);
ogs_pfcp_rule_t *ogs_pfcp_rule_find_by_sdf_filter_id(
        ogs_pfcp_sess_t *sess, uint32_t sdf_filter_id);
void ogs_pfcp_rule_remove(ogs_pfcp_rule_t *rule);
void ogs_pfcp_rule_remove_all(ogs_pfcp_pdr_t *pdr);

int ogs_pfcp_ue_pool_generate(void);
ogs_pfcp_ue_ip_t *ogs_pfcp_ue_ip_alloc(
        uint8_t *cause_value, int family, const char *dnn, uint8_t *addr);
void ogs_pfcp_ue_ip_free(ogs_pfcp_ue_ip_t *ip);

ogs_pfcp_dev_t *ogs_pfcp_dev_add(const char *ifname);
void ogs_pfcp_dev_remove(ogs_pfcp_dev_t *dev);
void ogs_pfcp_dev_remove_all(void);
ogs_pfcp_dev_t *ogs_pfcp_dev_find_by_ifname(const char *ifname);

ogs_pfcp_subnet_t *ogs_pfcp_subnet_add(
        const char *ipstr, const char *mask_or_numbits,
        const char *gateway, const char *dnn, const char *ifname);
ogs_pfcp_subnet_t *ogs_pfcp_subnet_next(ogs_pfcp_subnet_t *subnet);
void ogs_pfcp_subnet_remove(ogs_pfcp_subnet_t *subnet);
void ogs_pfcp_subnet_remove_all(void);
ogs_pfcp_subnet_t *ogs_pfcp_find_subnet(int family);
ogs_pfcp_subnet_t *ogs_pfcp_find_subnet_by_dnn(int family, const char *dnn);

void ogs_pfcp_pool_init(ogs_pfcp_sess_t *sess);
void ogs_pfcp_pool_final(ogs_pfcp_sess_t *sess);

#ifdef __cplusplus
}
#endif

#endif /* OGS_PFCP_CONTEXT_H */
===== conv.c =====

#include "ogs-pfcp.h"

int ogs_pfcp_sockaddr_to_node_id(ogs_pfcp_node_id_t *node_id, int *len)
{
    const int hdr_len = 1;
    char *hostname = NULL;

    ogs_sockaddr_t *advertise = ogs_pfcp_self()->pfcp_advertise;
    ogs_sockaddr_t *advertise6 = ogs_pfcp_self()->pfcp_advertise6;
    ogs_sockaddr_t *addr = ogs_pfcp_self()->pfcp_addr;
    ogs_sockaddr_t *addr6 = ogs_pfcp_self()->pfcp_addr6;
    int prefer_ipv4 = ogs_global_conf()->parameter.prefer_ipv4;

    ogs_assert(node_id);

    memset(node_id, 0, sizeof *node_id);

    if (advertise || advertise6) {
        hostname = ogs_gethostname(advertise ? advertise : advertise6);
        if (hostname) {
            node_id->type = OGS_PFCP_NODE_ID_FQDN;
            *len = ogs_fqdn_build(node_id->fqdn,
                        hostname, strlen(hostname)) + hdr_len;

            return OGS_OK;
        }
    }

    if (advertise && (prefer_ipv4 || !advertise6)) {
        node_id->type = OGS_PFCP_NODE_ID_IPV4;
        node_id->addr = advertise->sin.sin_addr.s_addr;
        *len = OGS_IPV4_LEN + hdr_len;
        return OGS_OK;
    }
    if (advertise6) {
        node_id->type = OGS_PFCP_NODE_ID_IPV6;
        memcpy(node_id->addr6, advertise6->sin6.sin6_addr.s6_addr, OGS_IPV6_LEN);
        *len = OGS_IPV6_LEN + hdr_len;
        return OGS_OK;
    }

    if (addr) {
        hostname = ogs_gethostname(addr);
        if (hostname) {
            node_id->type = OGS_PFCP_NODE_ID_FQDN;
            *len = ogs_fqdn_build(node_id->fqdn,
                        hostname, strlen(hostname)) + hdr_len;

            return OGS_OK;
        }
    }

    if (addr6) {
        hostname = ogs_gethostname(addr6);
        if (hostname) {
            node_id->type = OGS_PFCP_NODE_ID_FQDN;
            *len = ogs_fqdn_build(node_id->fqdn,
                        hostname, strlen(hostname)) + hdr_len;

            return OGS_OK;
        }
    }

    if (prefer_ipv4 && addr) {
        node_id->type = OGS_PFCP_NODE_ID_IPV4;
        node_id->addr = addr->sin.sin_addr.s_addr;
        *len = OGS_IPV4_LEN + hdr_len;
    } else if (addr6) {
        node_id->type = OGS_PFCP_NODE_ID_IPV6;
        memcpy(node_id->addr6, addr6->sin6.sin6_addr.s6_addr, OGS_IPV6_LEN);
        *len = OGS_IPV6_LEN + hdr_len;
    } else if (addr) {
        node_id->type = OGS_PFCP_NODE_ID_IPV4;
        node_id->addr = addr->sin.sin_addr.s_addr;
        *len = OGS_IPV4_LEN + hdr_len;
    } else {
        ogs_error("No IPv4 or IPv6");
        return OGS_ERROR;
    }

    return OGS_OK;
}

int ogs_pfcp_f_seid_to_sockaddr(
    ogs_pfcp_f_seid_t *f_seid, uint16_t port, ogs_sockaddr_t **list)
{
    ogs_sockaddr_t *addr = NULL, *addr6 = NULL;

    ogs_assert(f_seid);
    ogs_assert(list);

    addr = ogs_calloc(1, sizeof(ogs_sockaddr_t));
    if (!addr) {
        ogs_error("ogs_calloc() failed");
        return OGS_ERROR;
    }
    addr->ogs_sa_family = AF_INET;
    addr->ogs_sin_port = htobe16(port);

    addr6 = ogs_calloc(1, sizeof(ogs_sockaddr_t));
    if (!addr6) {
        ogs_error("ogs_calloc() failed");
        ogs_free(addr);
        return OGS_ERROR;
    }
    addr6->ogs_sa_family = AF_INET6;
    addr6->ogs_sin_port = htobe16(port);

    if (f_seid->ipv4 && f_seid->ipv6) {
        addr->next = addr6;

        addr->sin.sin_addr.s_addr = f_seid->both.addr;
        memcpy(addr6->sin6.sin6_addr.s6_addr, f_seid->both.addr6, OGS_IPV6_LEN);

        *list = addr;
    } else if (f_seid->ipv4) {
        addr->sin.sin_addr.s_addr = f_seid->addr;
        ogs_free(addr6);

        *list = addr;
    } else if (f_seid->ipv6) {
        memcpy(addr6->sin6.sin6_addr.s6_addr, f_seid->addr6, OGS_IPV6_LEN);
        ogs_free(addr);

        *list = addr6;
    } else {
        ogs_free(addr);
        ogs_free(addr6);
        ogs_error("No IPv4 or IPv6");
        return OGS_ERROR;
    }

    return OGS_OK;
}

int ogs_pfcp_sockaddr_to_f_seid(ogs_pfcp_f_seid_t *f_seid, int *len)
{
    const int hdr_len = 9;
    ogs_sockaddr_t *advertise = ogs_pfcp_self()->pfcp_advertise;
    ogs_sockaddr_t *advertise6 = ogs_pfcp_self()->pfcp_advertise6;
    ogs_sockaddr_t *addr = advertise ? advertise : ogs_pfcp_self()->pfcp_addr;
    ogs_sockaddr_t *addr6 = advertise6 ? advertise6 : ogs_pfcp_self()->pfcp_addr6;

    ogs_assert(f_seid);

    memset(f_seid, 0, sizeof *f_seid);

    if (addr && addr6) {
        f_seid->ipv4 = 1;
        f_seid->both.addr = addr->sin.sin_addr.s_addr;
        f_seid->ipv6 = 1;
        memcpy(f_seid->both.addr6, addr6->sin6.sin6_addr.s6_addr, OGS_IPV6_LEN);
        *len = OGS_IPV4V6_LEN + hdr_len;
    } else if (addr) {
        f_seid->ipv4 = 1;
        f_seid->ipv6 = 0;
        f_seid->addr = addr->sin.sin_addr.s_addr;
        *len = OGS_IPV4_LEN + hdr_len;
    } else if (addr6) {
        f_seid->ipv4 = 0;
        f_seid->ipv6 = 1;
        memcpy(f_seid->addr6, addr6->sin6.sin6_addr.s6_addr, OGS_IPV6_LEN);
        *len = OGS_IPV6_LEN + hdr_len;
    } else {
        ogs_error("No IPv4 or IPv6");
        return OGS_ERROR;
    }

    return OGS_OK;
}

int ogs_pfcp_f_seid_to_ip(ogs_pfcp_f_seid_t *f_seid, ogs_ip_t *ip)
{
    ogs_assert(ip);
    ogs_assert(f_seid);

    memset(ip, 0, sizeof *ip);

    ip->ipv4 = f_seid->ipv4;
    ip->ipv6 = f_seid->ipv6;

    if (ip->ipv4 && ip->ipv6) {
        ip->addr = f_seid->both.addr;
        memcpy(ip->addr6, f_seid->both.addr6, OGS_IPV6_LEN);
        ip->len = OGS_IPV4V6_LEN;
    } else if (ip->ipv4) {
        ip->addr = f_seid->addr;
        ip->len = OGS_IPV4_LEN;
    } else if (ip->ipv6) {
        memcpy(ip->addr6, f_seid->addr6, OGS_IPV6_LEN);
        ip->len = OGS_IPV6_LEN;
    } else {
        ogs_error("No IPv4 or IPv6");
        return OGS_ERROR;
    }

    return OGS_OK;
}

int ogs_pfcp_sockaddr_to_f_teid(
    ogs_sockaddr_t *addr, ogs_sockaddr_t *addr6,
    ogs_pfcp_f_teid_t *f_teid, int *len)
{
    const int hdr_len = 5;

    if (!addr && !addr6) {
        ogs_error("No addr");
        return OGS_ERROR;
    }
    if (!f_teid) {
        ogs_error("No F-TEID");
        return OGS_ERROR;
    }
    memset(f_teid, 0, sizeof *f_teid);

    if (addr && addr6) {
        f_teid->ipv4 = 1;
        f_teid->both.addr = addr->sin.sin_addr.s_addr;
        f_teid->ipv6 = 1;
        memcpy(f_teid->both.addr6, addr6->sin6.sin6_addr.s6_addr, OGS_IPV6_LEN);
        *len = OGS_IPV4V6_LEN + hdr_len;
    } else if (addr) {
        f_teid->ipv4 = 1;
        f_teid->ipv6 = 0;
        f_teid->addr = addr->sin.sin_addr.s_addr;
        *len = OGS_IPV4_LEN + hdr_len;
    } else if (addr6) {
        f_teid->ipv4 = 0;
        f_teid->ipv6 = 1;
        memcpy(f_teid->addr6, addr6->sin6.sin6_addr.s6_addr, OGS_IPV6_LEN);
        *len = OGS_IPV6_LEN + hdr_len;
    } else {
        ogs_error("No IPv4 or IPv6");
        return OGS_ERROR;
    }

    return OGS_OK;
}

int ogs_pfcp_f_teid_to_sockaddr(
    ogs_pfcp_f_teid_t *f_teid, int f_teid_len,
    ogs_sockaddr_t **addr, ogs_sockaddr_t **addr6)
{
    ogs_assert(addr && addr6);
    ogs_assert(f_teid);
    ogs_assert(f_teid_len);

    *addr = NULL;
    *addr6 = NULL;

    if (f_teid->ipv4 && f_teid->ipv6) {
        *addr = ogs_calloc(1, sizeof(**addr));
        if (!(*addr)) {
            ogs_error("ogs_calloc() failed");
            return OGS_ERROR;
        }
        (*addr)->sin.sin_addr.s_addr = f_teid->both.addr;
        (*addr)->ogs_sa_family = AF_INET;

        *addr6 = ogs_calloc(1, sizeof(**addr6));
        if (!(*addr6)) {
            ogs_error("ogs_calloc() failed");
            return OGS_ERROR;
        }
        memcpy((*addr6)->sin6.sin6_addr.s6_addr,
                f_teid->both.addr6, OGS_IPV6_LEN);
        (*addr6)->ogs_sa_family = AF_INET6;
    } else if (f_teid->ipv4) {
        *addr = ogs_calloc(1, sizeof(**addr));
        if (!(*addr)) {
            ogs_error("ogs_calloc() failed");
            return OGS_ERROR;
        }
        (*addr)->sin.sin_addr.s_addr = f_teid->addr;
        (*addr)->ogs_sa_family = AF_INET;
    } else if (f_teid->ipv6) {
        *addr6 = ogs_calloc(1, sizeof(**addr6));
        if (!(*addr6)) {
            ogs_error("ogs_calloc() failed");
            return OGS_ERROR;
        }
        memcpy((*addr6)->sin6.sin6_addr.s6_addr, f_teid->addr6, OGS_IPV6_LEN);
        (*addr6)->ogs_sa_family = AF_INET6;
    } else {
        ogs_error("No IPv4 or IPv6");
        return OGS_ERROR;
    }

    return OGS_OK;
}

int ogs_pfcp_f_teid_to_ip(ogs_pfcp_f_teid_t *f_teid, ogs_ip_t *ip)
{
    ogs_assert(ip);
    ogs_assert(f_teid);

    memset(ip, 0, sizeof *ip);

    ip->ipv4 = f_teid->ipv4;
    ip->ipv6 = f_teid->ipv6;

    if (ip->ipv4 && ip->ipv6) {
        ip->addr = f_teid->both.addr;
        memcpy(ip->addr6, f_teid->both.addr6, OGS_IPV6_LEN);
        ip->len = OGS_IPV4V6_LEN;
    } else if (ip->ipv4) {
        ip->addr = f_teid->addr;
        ip->len = OGS_IPV4_LEN;
    } else if (ip->ipv6) {
        memcpy(ip->addr6, f_teid->addr6, OGS_IPV6_LEN);
        ip->len = OGS_IPV6_LEN;
    } else {
        ogs_error("No IPv4 or IPv6");
        return OGS_ERROR;
    }

    return OGS_OK;
}

int ogs_pfcp_user_plane_ip_resource_info_to_f_teid(
    ogs_user_plane_ip_resource_info_t *info,
    ogs_pfcp_f_teid_t *f_teid, int *len)
{
    const int hdr_len = 5;
    int v4, v6;

    ogs_assert(info);
    ogs_assert(f_teid);

    v4 = info->v4 & f_teid->ipv4;
    v6 = info->v6 & f_teid->ipv6;
    ogs_assert(v4 || v6);

    memset(f_teid, 0, sizeof *f_teid);

    if (v4 && v6) {
        f_teid->ipv4 = 1;
        f_teid->both.addr = info->addr;
        f_teid->ipv6 = 1;
        memcpy(f_teid->both.addr6, info->addr6, OGS_IPV6_LEN);
        *len = OGS_IPV4V6_LEN + hdr_len;
    } else if (v4) {
        f_teid->ipv4 = 1;
        f_teid->ipv6 = 0;
        f_teid->addr = info->addr;
        *len = OGS_IPV4_LEN + hdr_len;
    } else if (v6) {
        f_teid->ipv4 = 0;
        f_teid->ipv6 = 1;
        memcpy(f_teid->addr6, info->addr6, OGS_IPV6_LEN);
        *len = OGS_IPV6_LEN + hdr_len;
    } else {
        ogs_error("No IPv4 or IPv6");
        return OGS_ERROR;
    }

    return OGS_OK;
}

int ogs_pfcp_paa_to_ue_ip_addr(
    ogs_paa_t *paa, ogs_pfcp_ue_ip_addr_t *addr, int *len)
{
    const int hdr_len = 1;

    ogs_assert(paa);
    ogs_assert(addr);

    memset(addr, 0, sizeof *addr);

    if (paa->session_type == OGS_PDU_SESSION_TYPE_IPV4V6) {
        addr->ipv4 = 1;
        addr->both.addr = paa->both.addr;
        addr->ipv6 = 1;
        memcpy(addr->both.addr6, paa->both.addr6, OGS_IPV6_LEN);
        *len = OGS_IPV4V6_LEN + hdr_len;
    } else if (paa->session_type == OGS_PDU_SESSION_TYPE_IPV4) {
        addr->ipv4 = 1;
        addr->ipv6 = 0;
        addr->addr = paa->addr;
        *len = OGS_IPV4_LEN + hdr_len;
    } else if (paa->session_type == OGS_PDU_SESSION_TYPE_IPV6) {
        addr->ipv4 = 0;
        addr->ipv6 = 1;
        memcpy(addr->addr6, paa->addr6, OGS_IPV6_LEN);
        *len = OGS_IPV6_LEN + hdr_len;
    } else {
        ogs_error("No IPv4 or IPv6");
        return OGS_ERROR;
    }

    return OGS_OK;
}

int ogs_pfcp_ip_to_outer_header_creation(ogs_ip_t *ip,
        ogs_pfcp_outer_header_creation_t *outer_header_creation, int *len)
{
    const int hdr_len = 6;

    ogs_assert(ip);
    ogs_assert(outer_header_creation);
    memset(outer_header_creation, 0, sizeof *outer_header_creation);

    if (ip->ipv4 && ip->ipv6) {
        outer_header_creation->gtpu4 = 1;
        outer_header_creation->both.addr = ip->addr;
        outer_header_creation->gtpu6 = 1;
        memcpy(outer_header_creation->both.addr6, ip->addr6, OGS_IPV6_LEN);
        *len = OGS_IPV4V6_LEN + hdr_len;
    } else if (ip->ipv4) {
        outer_header_creation->gtpu4 = 1;
        outer_header_creation->gtpu6 = 0;
        outer_header_creation->addr = ip->addr;
        *len = OGS_IPV4_LEN + hdr_len;
    } else if (ip->ipv6) {
        outer_header_creation->gtpu4 = 0;
        outer_header_creation->gtpu6 = 1;
        memcpy(outer_header_creation->addr6, ip->addr6, OGS_IPV6_LEN);
        *len = OGS_IPV6_LEN + hdr_len;
    } else {
        ogs_error("No IPv4 or IPv6");
        return OGS_ERROR;
    }

    return OGS_OK;
}

void ogs_pfcp_outer_header_creation_to_ip(
        ogs_pfcp_outer_header_creation_t *outer_header_creation, ogs_ip_t *ip)
{
    ogs_assert(outer_header_creation);
    ogs_assert(ip);
    memset(ip, 0, sizeof *ip);

    if ((outer_header_creation->gtpu4 ||
        outer_header_creation->ip4 ||
        outer_header_creation->udp4) &&
        (outer_header_creation->gtpu6 ||
        outer_header_creation->ip6 ||
        outer_header_creation->udp6)) {
        ip->ipv4 = 1; ip->ipv6 = 1;
        ip->len = OGS_IPV4V6_LEN;
        ip->addr = outer_header_creation->both.addr;
        memcpy(ip->addr6, outer_header_creation->both.addr6, OGS_IPV6_LEN);
    } else if (outer_header_creation->gtpu4 ||
                outer_header_creation->ip4 ||
                outer_header_creation->udp4) {
        ip->ipv4 = 1;
        ip->len = OGS_IPV4_LEN;
        ip->addr = outer_header_creation->addr;
    } else if (outer_header_creation->gtpu6 ||
                outer_header_creation->ip6 ||
                outer_header_creation->udp6) {
        ip->ipv6 = 1;
        ip->len = OGS_IPV6_LEN;
        memcpy(ip->addr6, outer_header_creation->addr6, OGS_IPV6_LEN);
    }
}
===== conv.h =====

#if !defined(OGS_PFCP_INSIDE) && !defined(OGS_PFCP_COMPILATION)
#error "This header cannot be included directly."
#endif

#ifndef OGS_PFCP_CONV_H
#define OGS_PFCP_CONV_H

#ifdef __cplusplus
extern "C" {
#endif

int ogs_pfcp_sockaddr_to_node_id(ogs_pfcp_node_id_t *node_id, int *len);

int ogs_pfcp_f_seid_to_sockaddr(
    ogs_pfcp_f_seid_t *f_seid, uint16_t port, ogs_sockaddr_t **list);
int ogs_pfcp_sockaddr_to_f_seid(ogs_pfcp_f_seid_t *f_seid, int *len);
int ogs_pfcp_f_seid_to_ip(ogs_pfcp_f_seid_t *f_seid, ogs_ip_t *ip);

int ogs_pfcp_sockaddr_to_f_teid(
    ogs_sockaddr_t *addr, ogs_sockaddr_t *addr6,
    ogs_pfcp_f_teid_t *f_teid, int *len);
int ogs_pfcp_f_teid_to_sockaddr(
    ogs_pfcp_f_teid_t *f_teid, int f_teid_len,
    ogs_sockaddr_t **addr, ogs_sockaddr_t **addr6);
int ogs_pfcp_f_teid_to_ip(ogs_pfcp_f_teid_t *f_teid, ogs_ip_t *ip);

int ogs_pfcp_user_plane_ip_resource_info_to_f_teid(
    ogs_user_plane_ip_resource_info_t *info,
    ogs_pfcp_f_teid_t *f_teid, int *len);

int ogs_pfcp_paa_to_ue_ip_addr(
    ogs_paa_t *paa, ogs_pfcp_ue_ip_addr_t *addr, int *len);

int ogs_pfcp_ip_to_outer_header_creation(ogs_ip_t *ip,
    ogs_pfcp_outer_header_creation_t *outer_header_creation, int *len);
void ogs_pfcp_outer_header_creation_to_ip(
    ogs_pfcp_outer_header_creation_t *outer_header_creation, ogs_ip_t *ip);

#ifdef __cplusplus
}
#endif

#endif
===== handler.c =====

#include "ogs-pfcp.h"

bool ogs_pfcp_handle_heartbeat_request(
        ogs_pfcp_node_t *node, ogs_pfcp_xact_t *xact,
        ogs_pfcp_heartbeat_request_t *req)
{
    int rv;
    ogs_assert(node);
    ogs_assert(xact);
    ogs_assert(req);

    if (req->recovery_time_stamp.presence == 0) {
        ogs_error("No Recovery Time Stamp");
        return false;
    }

    if (node->remote_recovery == 0 ||
        node->remote_recovery == req->recovery_time_stamp.u32) {
    } else if (node->remote_recovery < req->recovery_time_stamp.u32) {
        ogs_error("Remote PFCP restarted [%u<%u] in Heartbeat REQ",
            node->remote_recovery, req->recovery_time_stamp.u32);
        node->restoration_required = true;
    } else if (node->remote_recovery > req->recovery_time_stamp.u32) {
        ogs_error("Invalid Recovery Time Stamp [%u>%u] in Heartbeat REQ",
        node->remote_recovery, req->recovery_time_stamp.u32);
    }

    node->remote_recovery = req->recovery_time_stamp.u32;

    rv = ogs_pfcp_send_heartbeat_response(xact);
    if (rv != OGS_OK) {
        ogs_error("ogs_pfcp_send_heartbeat_response() failed");
        return false;
    }

    return true;
}

bool ogs_pfcp_handle_heartbeat_response(
        ogs_pfcp_node_t *node, ogs_pfcp_xact_t *xact,
        ogs_pfcp_heartbeat_response_t *rsp)
{
    ogs_assert(node);
    ogs_assert(xact);
    ogs_assert(rsp);

    ogs_pfcp_xact_commit(xact);

    if (rsp->recovery_time_stamp.presence == 0) {
        ogs_error("No Recovery Time Stamp");
        return false;
    }

    if (node->remote_recovery == 0 ||
        node->remote_recovery == rsp->recovery_time_stamp.u32) {
    } else if (node->remote_recovery < rsp->recovery_time_stamp.u32) {
        ogs_error("Remote PFCP restarted [%u<%u] in Heartbeat RSP",
            node->remote_recovery, rsp->recovery_time_stamp.u32);
        node->restoration_required = true;
    } else if (node->remote_recovery > rsp->recovery_time_stamp.u32) {
        ogs_error("Invalid Recovery Time Stamp [%u>%u] in Heartbeat RSP",
        node->remote_recovery, rsp->recovery_time_stamp.u32);
    }

    node->remote_recovery = rsp->recovery_time_stamp.u32;

    ogs_timer_start(node->t_no_heartbeat,
            ogs_local_conf()->time.message.pfcp.no_heartbeat_duration);

    return true;
}

bool ogs_pfcp_cp_handle_association_setup_request(
        ogs_pfcp_node_t *node, ogs_pfcp_xact_t *xact,
        ogs_pfcp_association_setup_request_t *req)
{
    int i;
    int16_t decoded;

    ogs_assert(xact);
    ogs_assert(node);
    ogs_assert(req);

    ogs_pfcp_cp_send_association_setup_response(
            xact, OGS_PFCP_CAUSE_REQUEST_ACCEPTED);

    ogs_gtpu_resource_remove_all(&node->gtpu_resource_list);

    for (i = 0; i < OGS_MAX_NUM_OF_GTPU_RESOURCE; i++) {
        ogs_pfcp_tlv_user_plane_ip_resource_information_t *message =
            &req->user_plane_ip_resource_information[i];
        ogs_user_plane_ip_resource_info_t info;

        if (message->presence == 0)
            break;

        decoded = ogs_pfcp_parse_user_plane_ip_resource_info(&info, message);
        if (message->len == decoded)
            ogs_gtpu_resource_add(&node->gtpu_resource_list, &info);
        else
            ogs_error("Invalid User Plane IP Resource Info");
    }

    if (req->up_function_features.presence) {
        if (req->up_function_features.data && req->up_function_features.len) {
            node->up_function_features_len =
                ogs_min(req->up_function_features.len,
                        sizeof(node->up_function_features));
            memcpy(&node->up_function_features, req->up_function_features.data,
                    node->up_function_features_len);
        }
    }

    if (node->up_function_features.ftup == 0)
        ogs_warn("F-TEID allocation/release not supported with peer %s",
                ogs_sockaddr_to_string_static(node->addr_list));

    return true;
}

bool ogs_pfcp_cp_handle_association_setup_response(
        ogs_pfcp_node_t *node, ogs_pfcp_xact_t *xact,
        ogs_pfcp_association_setup_response_t *rsp)
{
    int i;
    int16_t decoded;

    ogs_assert(xact);
    ogs_pfcp_xact_commit(xact);

    ogs_assert(node);
    ogs_assert(rsp);

    ogs_gtpu_resource_remove_all(&node->gtpu_resource_list);

    for (i = 0; i < OGS_MAX_NUM_OF_GTPU_RESOURCE; i++) {
        ogs_pfcp_tlv_user_plane_ip_resource_information_t *message =
            &rsp->user_plane_ip_resource_information[i];
        ogs_user_plane_ip_resource_info_t info;

        if (message->presence == 0)
            break;

        decoded = ogs_pfcp_parse_user_plane_ip_resource_info(&info, message);
        if (message->len == decoded)
            ogs_gtpu_resource_add(&node->gtpu_resource_list, &info);
        else
            ogs_error("Invalid User Plane IP Resource Info");
    }

    if (rsp->up_function_features.presence) {
        if (rsp->up_function_features.data && rsp->up_function_features.len) {
            node->up_function_features_len =
                ogs_min(rsp->up_function_features.len,
                        sizeof(node->up_function_features));
            memcpy(&node->up_function_features, rsp->up_function_features.data,
                    node->up_function_features_len);
        }
    }

    if (node->up_function_features.ftup == 0)
        ogs_warn("F-TEID allocation/release not supported with peer %s",
                ogs_sockaddr_to_string_static(node->addr_list));

    return true;
}

bool ogs_pfcp_up_handle_association_setup_request(
        ogs_pfcp_node_t *node, ogs_pfcp_xact_t *xact,
        ogs_pfcp_association_setup_request_t *req)
{
    ogs_assert(xact);
    ogs_pfcp_up_send_association_setup_response(
            xact, OGS_PFCP_CAUSE_REQUEST_ACCEPTED);

    if (req->cp_function_features.presence) {
        ogs_pfcp_self()->cp_function_features.octet5 =
            req->cp_function_features.u8;
    }

    return true;
}

bool ogs_pfcp_up_handle_association_setup_response(
        ogs_pfcp_node_t *node, ogs_pfcp_xact_t *xact,
        ogs_pfcp_association_setup_response_t *rsp)
{
    ogs_assert(xact);
    ogs_pfcp_xact_commit(xact);

    if (rsp->cp_function_features.presence) {
        ogs_pfcp_self()->cp_function_features.octet5 =
            rsp->cp_function_features.u8;
    }

    return true;
}

bool ogs_pfcp_up_handle_pdr(
        ogs_pfcp_pdr_t *pdr, uint8_t type,
        ogs_gtp2_header_desc_t *recvhdr, ogs_pkbuf_t *sendbuf,
        ogs_pfcp_user_plane_report_t *report)
{
    ogs_pfcp_far_t *far = NULL;
    bool buffering;

    ogs_assert(sendbuf);
    ogs_assert(type);
    ogs_assert(pdr);
    ogs_assert(report);

    far = pdr->far;
    ogs_assert(far);

    memset(report, 0, sizeof(*report));

    buffering = false;

    if (!far->gnode) {
        buffering = true;

    } else {
        if (far->apply_action & OGS_PFCP_APPLY_ACTION_FORW) {
            ogs_gtp2_header_desc_t sendhdr;

            /* Forward packet */
            memset(&sendhdr, 0, sizeof(sendhdr));
            sendhdr.type = type;

            if (recvhdr) {
                /*
                 * Issue #2584
                 * Discussion #2477
                 *
                 * Forward PDCP Number via Indirect Tunnel during Handover
                 */
                if (recvhdr->pdcp_number_presence == true) {
                    sendhdr.pdcp_number_presence =
                        recvhdr->pdcp_number_presence;
                    sendhdr.pdcp_number = recvhdr->pdcp_number;
                }
            }

            ogs_pfcp_send_g_pdu(pdr, &sendhdr, sendbuf);

        } else if (far->apply_action & OGS_PFCP_APPLY_ACTION_BUFF) {

            buffering = true;

        } else {
            ogs_error("Not implemented = %d", far->apply_action);
            ogs_pkbuf_free(sendbuf);
        }
    }

    if (buffering == true) {

        if (far->num_of_buffered_packet == 0) {
            /* Only the first time a packet is buffered,
             * it reports downlink notifications. */
            report->type.downlink_data_report = 1;
        }

        if (far->num_of_buffered_packet < OGS_MAX_NUM_OF_PACKET_BUFFER) {
            far->buffered_packet[far->num_of_buffered_packet++] = sendbuf;
        } else {
            ogs_pkbuf_free(sendbuf);
        }
    }

    return true;
}

bool ogs_pfcp_up_handle_error_indication(
        ogs_pfcp_far_t *far, ogs_pfcp_user_plane_report_t *report)
{
    uint16_t len;

    ogs_assert(far);
    ogs_assert(far->hash.f_teid.len);

    ogs_assert(report);

    memset(report, 0, sizeof(*report));

    /* Remove TEID size, Only use ADDR size */
    len = far->hash.f_teid.len - 4;

    report->error_indication.remote_f_teid_len = 5 + len;
    report->error_indication.remote_f_teid.teid =
        htobe32(far->hash.f_teid.key.teid);
    if (len == OGS_IPV4_LEN) {
        report->error_indication.remote_f_teid.ipv4 = 1;
        memcpy(&report->error_indication.remote_f_teid.addr,
            far->hash.f_teid.key.addr,
            ogs_min(sizeof(report->error_indication.remote_f_teid.addr), len));
    } else if (len == OGS_IPV6_LEN) {
        report->error_indication.remote_f_teid.ipv6 = 1;
        memcpy(report->error_indication.remote_f_teid.addr6,
            far->hash.f_teid.key.addr,
            ogs_min(sizeof(report->error_indication.remote_f_teid.addr6), len));
    } else {
        ogs_error("Invalid Length [%d]", len);
        return false;
    }

    report->type.error_indication_report = 1;

    return true;
}

ogs_pfcp_pdr_t *ogs_pfcp_handle_create_pdr(ogs_pfcp_sess_t *sess,
        ogs_pfcp_tlv_create_pdr_t *message,
        ogs_pfcp_sereq_flags_t *sereq_flags,
        uint8_t *cause_value, uint8_t *offending_ie_value)
{
    ogs_pfcp_pdr_t *pdr = NULL;
    ogs_pfcp_far_t *far = NULL;
    ogs_pfcp_urr_t *urr = NULL;
    ogs_pfcp_qer_t *qer = NULL;
    int i, len;
    int rv;

    ogs_assert(sess);
    ogs_assert(message);

    if (message->presence == 0)
        return NULL;

    if (message->pdr_id.presence == 0) {
        ogs_error("No PDR-ID");
        *cause_value = OGS_PFCP_CAUSE_MANDATORY_IE_MISSING;
        *offending_ie_value = OGS_PFCP_PDR_ID_TYPE;
        return NULL;
    }

    pdr = ogs_pfcp_pdr_find_or_add(sess, message->pdr_id.u16);
    ogs_assert(pdr);

    if (message->precedence.presence) {
        ogs_pfcp_pdr_reorder_by_precedence(pdr, message->precedence.u32);
        pdr->precedence = message->precedence.u32;
    }

    if (message->pdi.presence == 0) {
        ogs_error("No PDI in PDR");
        *cause_value = OGS_PFCP_CAUSE_MANDATORY_IE_MISSING;
        *offending_ie_value = OGS_PFCP_PDI_TYPE;
        return NULL;
    }

    if (message->pdi.source_interface.presence == 0) {
        ogs_error("No Source Interface in PDI");
        *cause_value = OGS_PFCP_CAUSE_MANDATORY_IE_MISSING;
        *offending_ie_value = OGS_PFCP_SOURCE_INTERFACE_TYPE;
        return NULL;
    }

    if (message->pdi.local_f_teid.presence) {
        ogs_pfcp_f_teid_t f_teid;

        memcpy(&f_teid, message->pdi.local_f_teid.data,
                ogs_min(sizeof(f_teid), message->pdi.local_f_teid.len));
        if (f_teid.ipv4 == 0 && f_teid.ipv6 == 0) {
            ogs_error("One of the IPv4 and IPv6 flags should be 1 "
                        "in the local F-TEID");
            *cause_value = OGS_PFCP_CAUSE_MANDATORY_IE_INCORRECT;
            *offending_ie_value = OGS_PFCP_F_TEID_TYPE;
            return NULL;
        }

        if (f_teid.ch == 0) {
            if (sereq_flags && sereq_flags->restoration_indication == 1) {
                f_teid.teid = be32toh(f_teid.teid);
                if (ogs_pfcp_object_find_by_teid(f_teid.teid)) {
                    ogs_error("TEID:%x had already been allocated", f_teid.teid);
                    *cause_value = OGS_PFCP_CAUSE_INVALID_F_TEID_ALLOCATION_OPTION;
                    *offending_ie_value = OGS_PFCP_F_TEID_TYPE;
                    return NULL;
                }
            }
        }
    }

    pdr->src_if = message->pdi.source_interface.u8;

    if (message->pdi.source_interface_type.presence) {
        pdr->src_if_type_presence = true;
        pdr->src_if_type = message->pdi.source_interface_type.u8;
    }

    ogs_pfcp_rule_remove_all(pdr);

    for (i = 0; i < OGS_MAX_NUM_OF_FLOW_IN_PDR; i++) {
        ogs_pfcp_sdf_filter_t sdf_filter;
        ogs_pfcp_rule_t *rule = NULL;
        ogs_pfcp_rule_t *oppsite_direction_rule = NULL;

        if (message->pdi.sdf_filter[i].presence == 0)
            break;

        len = ogs_pfcp_parse_sdf_filter(
                &sdf_filter, &message->pdi.sdf_filter[i]);
        if (message->pdi.sdf_filter[i].len != len) {
            ogs_error("Invalid SDF Filter");
            break;
        }

        /* Check Previous SDF Filter ID */
        if (sdf_filter.bid) {
            oppsite_direction_rule = ogs_pfcp_rule_find_by_sdf_filter_id(
                        sess, sdf_filter.sdf_filter_id);
        }

        if (!oppsite_direction_rule && !sdf_filter.fd) {
            ogs_error("Not Supported SDF Filter [Flags:0x%x, Len:%d]",
                    sdf_filter.flags, message->pdi.sdf_filter[i].len);
            ogs_log_hexdump(OGS_LOG_ERROR,
                    message->pdi.sdf_filter[i].data,
                    message->pdi.sdf_filter[i].len);
            continue;
        }

        rule = ogs_pfcp_rule_add(pdr);
        ogs_assert(rule);

        /* Set All Flags (BID, FL, SPI, TTC, FD) */
        rule->flags = sdf_filter.flags;

        if (oppsite_direction_rule) {
            /* Copy oppsite direction rule and Swap */
            memcpy(&rule->ipfw, &oppsite_direction_rule->ipfw,
                    sizeof(rule->ipfw));
            ogs_ipfw_rule_swap(&rule->ipfw);
        }

        /* If BID, Store SDF Filter ID */
        if (rule->bid)
            rule->sdf_filter_id = sdf_filter.sdf_filter_id;

        /* If FD, Apply Flow-Description to the RULE */
        if (rule->fd) {
            char *flow_description = NULL;

            flow_description = ogs_calloc(
                    1, sdf_filter.flow_description_len+1);
            ogs_assert(flow_description);
            ogs_cpystrn(flow_description,
                    sdf_filter.flow_description,
                    sdf_filter.flow_description_len+1);

            rv = ogs_ipfw_compile_rule(&rule->ipfw, flow_description);
            ogs_assert(rv == OGS_OK);

            ogs_free(flow_description);
/*
 *
 * TS29.244 Ch 5.2.1A.2A
 *
 * The UP function shall apply the SDF filter based on the Source Interface
 * of the PDR as follows (see also clause 8.2.5):
 *
 * - when the Source Interface is CORE, this indicates that the filter is
 *   for downlink data flow, so the UP function shall apply
 *   the Flow Description as is;
 *
 * - when the Source Interface is ACCESS, this indicates that the filter is
 *   for uplink data flow, so the UP function shall swap the source and
 *   destination address/port in the Flow Description;
 *
 * - when the Source Interface is CP-function or SGi-LAN,
 *   the UP function shall use the Flow Description as is.
 *
 *
 * Refer to lib/ipfw/ogs-ipfw.h
 * Issue #338
 *
 * <DOWNLINK>
 * GX : permit out from <P-CSCF_RTP_IP> <P-CSCF_RTP_PORT> to <UE_IP> <UE_PORT>
 * RULE : Source <P-CSCF_RTP_IP> <P-CSCF_RTP_PORT> Destination <UE_IP> <UE_PORT>
 *
 * <UPLINK>
 * GX : permit out from <P-CSCF_RTP_IP> <P-CSCF_RTP_PORT> to <UE_IP> <UE_PORT>
 * RULE : Source <UE_IP> <UE_PORT> Destination <P-CSCF_RTP_IP> <P-CSCF_RTP_PORT>
 */

            /* Uplink data flow */
            if (pdr->src_if == OGS_PFCP_INTERFACE_ACCESS)
                ogs_ipfw_rule_swap(&rule->ipfw);
        }
    }

    if (pdr->dnn) {
        ogs_free(pdr->dnn);
        pdr->dnn = NULL;
    }

    if (message->pdi.network_instance.presence) {
        char dnn[OGS_MAX_DNN_LEN+1];

        if (ogs_fqdn_parse(dnn, message->pdi.network_instance.data,
            ogs_min(message->pdi.network_instance.len, OGS_MAX_DNN_LEN)) > 0) {
            pdr->dnn = ogs_strdup(dnn);
            ogs_assert(pdr->dnn);
        } else {
            ogs_error("Invalid pdi.network_instance");
        }
    }

    pdr->chid = false;
    pdr->choose_id = 0;

    memset(&pdr->f_teid, 0, sizeof(pdr->f_teid));
    pdr->f_teid_len = 0;

    if (message->pdi.local_f_teid.presence) {
        pdr->f_teid_len =
            ogs_min(message->pdi.local_f_teid.len, sizeof(pdr->f_teid));
        memcpy(&pdr->f_teid, message->pdi.local_f_teid.data, pdr->f_teid_len);
        ogs_assert(pdr->f_teid.ipv4 || pdr->f_teid.ipv6);
        pdr->f_teid.teid = be32toh(pdr->f_teid.teid);
    }

    pdr->qfi = 0;

    if (message->pdi.qfi.presence) {
        pdr->qfi = message->pdi.qfi.u8;
    }

    memset(&pdr->ue_ip_addr, 0, sizeof(pdr->ue_ip_addr));
    pdr->ue_ip_addr_len = 0;

    if (message->pdi.ue_ip_address.presence) {
        pdr->ue_ip_addr_len =
            ogs_min(message->pdi.ue_ip_address.len, sizeof(pdr->ue_ip_addr));
        memcpy(&pdr->ue_ip_addr, message->pdi.ue_ip_address.data,
                pdr->ue_ip_addr_len);
    }

    for (i = 0; i < OGS_MAX_NUM_OF_FRAMED_ROUTES_IN_PDI; i++) {
        if (!pdr->ipv4_framed_routes || !pdr->ipv4_framed_routes[i])
            break;
        ogs_free(pdr->ipv4_framed_routes[i]);
        pdr->ipv4_framed_routes[i] = NULL;
    }

    for (i = 0; i < OGS_MAX_NUM_OF_FRAMED_ROUTES_IN_PDI; i++) {
        if (!pdr->ipv6_framed_routes || !pdr->ipv6_framed_routes[i])
            break;
        ogs_free(pdr->ipv6_framed_routes[i]);
        pdr->ipv6_framed_routes[i] = NULL;
    }

    for (i = 0; i < OGS_MAX_NUM_OF_FRAMED_ROUTES_IN_PDI; i++) {
        char *route;

        if (!message->pdi.framed_route[i].presence)
            break;

        if (!pdr->ipv4_framed_routes) {
            pdr->ipv4_framed_routes = ogs_calloc(
                    OGS_MAX_NUM_OF_FRAMED_ROUTES_IN_PDI, sizeof(pdr->ipv4_framed_routes[0]));
            ogs_assert(pdr->ipv4_framed_routes);
        }
        route = ogs_malloc(message->pdi.framed_route[i].len + 1);
        ogs_assert(route);
        memcpy(route, message->pdi.framed_route[i].data,
               message->pdi.framed_route[i].len);
        route[message->pdi.framed_route[i].len] = '\0';
        pdr->ipv4_framed_routes[i] = route;
    }

    for (i = 0; i < OGS_MAX_NUM_OF_FRAMED_ROUTES_IN_PDI; i++) {
        char *route;

        if (!message->pdi.framed_ipv6_route[i].presence)
            break;

        if (!pdr->ipv6_framed_routes) {
            pdr->ipv6_framed_routes = ogs_calloc(
                    OGS_MAX_NUM_OF_FRAMED_ROUTES_IN_PDI, sizeof(pdr->ipv6_framed_routes[0]));
            ogs_assert(pdr->ipv6_framed_routes);
        }
        route = ogs_malloc(message->pdi.framed_ipv6_route[i].len + 1);
        ogs_assert(route);
        memcpy(route, message->pdi.framed_ipv6_route[i].data,
               message->pdi.framed_ipv6_route[i].len);
        route[message->pdi.framed_ipv6_route[i].len] = '\0';
        pdr->ipv6_framed_routes[i] = route;
    }

    memset(&pdr->outer_header_removal, 0, sizeof(pdr->outer_header_removal));
    pdr->outer_header_removal_len = 0;

    if (message->outer_header_removal.presence) {
        pdr->outer_header_removal_len =
            ogs_min(message->outer_header_removal.len,
                    sizeof(pdr->outer_header_removal));
        memcpy(&pdr->outer_header_removal, message->outer_header_removal.data,
                pdr->outer_header_removal_len);
    }

    pdr->far = NULL;

    if (message->far_id.presence) {
        far = ogs_pfcp_far_find_or_add(sess, message->far_id.u32);
        ogs_assert(far);
        ogs_pfcp_pdr_associate_far(pdr, far);
    }

    for (i = 0; i < OGS_ARRAY_SIZE(pdr->urr); i++)
        pdr->urr[i] = NULL;
    pdr->num_of_urr = 0;
    for (i = 0; i < OGS_ARRAY_SIZE(message->urr_id); i++) {
        if (message->urr_id[i].presence) {
            urr = ogs_pfcp_urr_find_or_add(sess, message->urr_id[i].u32);
            ogs_assert(urr);
            ogs_pfcp_pdr_associate_urr(pdr,urr);
        }
    }

    pdr->qer = NULL;

    if (message->qer_id.presence) {
        qer = ogs_pfcp_qer_find_or_add(sess, message->qer_id.u32);
        ogs_assert(qer);
        ogs_pfcp_pdr_associate_qer(pdr, qer);
    }

    return pdr;
}

ogs_pfcp_pdr_t *ogs_pfcp_handle_created_pdr(ogs_pfcp_sess_t *sess,
        ogs_pfcp_tlv_created_pdr_t *message,
        uint8_t *cause_value, uint8_t *offending_ie_value)
{
    ogs_pfcp_pdr_t *pdr = NULL;

    ogs_assert(sess);
    ogs_assert(message);

    if (message->presence == 0)
        return NULL;

    if (message->pdr_id.presence == 0) {
        ogs_error("No PDR-ID");
        *cause_value = OGS_PFCP_CAUSE_MANDATORY_IE_MISSING;
        *offending_ie_value = OGS_PFCP_PDR_ID_TYPE;
        return NULL;
    }

    pdr = ogs_pfcp_pdr_find(sess, message->pdr_id.u16);
    if (!pdr) {
        ogs_error("Cannot find PDR-ID[%d] in PDR", message->pdr_id.u16);
        *cause_value = OGS_PFCP_CAUSE_MANDATORY_IE_INCORRECT;
        *offending_ie_value = OGS_PFCP_PDR_ID_TYPE;
        return NULL;
    }

    if (message->local_f_teid.presence) {
        ogs_pfcp_f_teid_t f_teid;

        memcpy(&f_teid, message->local_f_teid.data,
                ogs_min(sizeof(f_teid), message->local_f_teid.len));
        if (f_teid.ipv4 == 0 && f_teid.ipv6 == 0) {
            ogs_error("One of the IPv4 and IPv6 flags should be 1 "
                        "in the local F-TEID");
            *cause_value = OGS_PFCP_CAUSE_MANDATORY_IE_INCORRECT;
            *offending_ie_value = OGS_PFCP_F_TEID_TYPE;

            return NULL;
        }

        pdr->f_teid_len = message->local_f_teid.len;
        memcpy(&pdr->f_teid, message->local_f_teid.data,
                ogs_min(sizeof(pdr->f_teid), pdr->f_teid_len));
        ogs_assert(pdr->f_teid.ipv4 || pdr->f_teid.ipv6);
        pdr->f_teid.teid = be32toh(pdr->f_teid.teid);
    }

    return pdr;
}

ogs_pfcp_pdr_t *ogs_pfcp_handle_update_pdr(ogs_pfcp_sess_t *sess,
        ogs_pfcp_tlv_update_pdr_t *message,
        uint8_t *cause_value, uint8_t *offending_ie_value)
{
    ogs_pfcp_pdr_t *pdr = NULL;
    int i, len;
    int rv;

    ogs_assert(message);
    ogs_assert(sess);

    if (message->presence == 0)
        return NULL;

    if (message->pdr_id.presence == 0) {
        ogs_error("No PDR-ID");
        *cause_value = OGS_PFCP_CAUSE_MANDATORY_IE_MISSING;
        *offending_ie_value = OGS_PFCP_PDR_ID_TYPE;
        return NULL;
    }

    pdr = ogs_pfcp_pdr_find(sess, message->pdr_id.u16);
    if (!pdr) {
        ogs_error("Cannot find PDR-ID[%d] in PDR", message->pdr_id.u16);
        *cause_value = OGS_PFCP_CAUSE_MANDATORY_IE_INCORRECT;
        *offending_ie_value = OGS_PFCP_PDR_ID_TYPE;
        return NULL;
    }

    if (message->pdi.presence) {
        if (message->pdi.source_interface.presence == 0) {
            ogs_error("No Source Interface in PDI");
            *cause_value = OGS_PFCP_CAUSE_MANDATORY_IE_MISSING;
            *offending_ie_value = OGS_PFCP_SOURCE_INTERFACE_TYPE;
            return NULL;
        }

        if (message->pdi.local_f_teid.presence) {
            ogs_pfcp_f_teid_t f_teid;

            memcpy(&f_teid, message->pdi.local_f_teid.data,
                    ogs_min(sizeof(f_teid), message->pdi.local_f_teid.len));
            if (f_teid.ipv4 == 0 && f_teid.ipv6 == 0) {
                ogs_error("One of the IPv4 and IPv6 flags should be 1 "
                            "in the local F-TEID");
                *cause_value = OGS_PFCP_CAUSE_MANDATORY_IE_INCORRECT;
                *offending_ie_value = OGS_PFCP_F_TEID_TYPE;
                return NULL;
            }
        }

        pdr->src_if = message->pdi.source_interface.u8;

        if (message->pdi.source_interface_type.presence) {
            pdr->src_if_type_presence = true;
            pdr->src_if_type = message->pdi.source_interface_type.u8;
        }

        ogs_pfcp_rule_remove_all(pdr);

        for (i = 0; i < OGS_MAX_NUM_OF_FLOW_IN_PDR; i++) {
            ogs_pfcp_sdf_filter_t sdf_filter;
            ogs_pfcp_rule_t *rule = NULL;
            ogs_pfcp_rule_t *oppsite_direction_rule = NULL;

            if (message->pdi.sdf_filter[i].presence == 0)
                break;

            len = ogs_pfcp_parse_sdf_filter(
                    &sdf_filter, &message->pdi.sdf_filter[i]);
            if (message->pdi.sdf_filter[i].len != len) {
                ogs_error("Invalid SDF Filter");
                break;
            }

            /* Check Previous SDF Filter ID */
            if (sdf_filter.bid) {
                oppsite_direction_rule = ogs_pfcp_rule_find_by_sdf_filter_id(
                            sess, sdf_filter.sdf_filter_id);

            }

            if (!oppsite_direction_rule && !sdf_filter.fd) {
                ogs_error("Not Supported SDF Filter [Flags:0x%x, Len:%d]",
                        sdf_filter.flags, message->pdi.sdf_filter[i].len);
                ogs_log_hexdump(OGS_LOG_ERROR,
                        message->pdi.sdf_filter[i].data,
                        message->pdi.sdf_filter[i].len);
                continue;
            }

            rule = ogs_pfcp_rule_add(pdr);
            ogs_assert(rule);

            /* Set All Flags (BID, FL, SPI, TTC, FD) */
            rule->flags = sdf_filter.flags;

            if (oppsite_direction_rule) {
                /* Copy oppsite direction rule and Swap */
                memcpy(&rule->ipfw, &oppsite_direction_rule->ipfw,
                        sizeof(rule->ipfw));
                ogs_ipfw_rule_swap(&rule->ipfw);
            }

            /* If BID, Store SDF Filter ID */
            if (rule->bid)
                rule->sdf_filter_id = sdf_filter.sdf_filter_id;

            /* If FD, Apply Flow-Description to the RULE */
            if (rule->fd) {
                char *flow_description = NULL;

                flow_description = ogs_calloc(
                        1, sdf_filter.flow_description_len+1);
                ogs_assert(flow_description);
                ogs_cpystrn(flow_description,
                        sdf_filter.flow_description,
                        sdf_filter.flow_description_len+1);

                rv = ogs_ipfw_compile_rule(&rule->ipfw, flow_description);
                ogs_assert(rv == OGS_OK);

                ogs_free(flow_description);
    /*
     *
     * TS29.244 Ch 5.2.1A.2A
     *
     * The UP function shall apply the SDF filter based on the Source Interface
     * of the PDR as follows (see also clause 8.2.5):
     *
     * - when the Source Interface is CORE, this indicates that the filter is
     *   for downlink data flow, so the UP function shall apply
     *   the Flow Description as is;
     *
     * - when the Source Interface is ACCESS, this indicates that the filter is
     *   for uplink data flow, so the UP function shall swap the source and
     *   destination address/port in the Flow Description;
     *
     * - when the Source Interface is CP-function or SGi-LAN,
     *   the UP function shall use the Flow Description as is.
     *
     *
     * Refer to lib/ipfw/ogs-ipfw.h
     * Issue #338
     *
     * <DOWNLINK>
     * GX : permit out from <P-CSCF_RTP_IP> <P-CSCF_RTP_PORT> to <UE_IP> <UE_PORT>
     * RULE : Source <P-CSCF_RTP_IP> <P-CSCF_RTP_PORT> Destination <UE_IP> <UE_PORT>
     *
     * <UPLINK>
     * GX : permit out from <P-CSCF_RTP_IP> <P-CSCF_RTP_PORT> to <UE_IP> <UE_PORT>
     * RULE : Source <UE_IP> <UE_PORT> Destination <P-CSCF_RTP_IP> <P-CSCF_RTP_PORT>
     */

                /* Uplink data flow */
                if (pdr->src_if == OGS_PFCP_INTERFACE_ACCESS)
                    ogs_ipfw_rule_swap(&rule->ipfw);
            }
        }

        if (message->pdi.network_instance.presence) {
            char dnn[OGS_MAX_DNN_LEN+1];

            if (ogs_fqdn_parse(dnn, message->pdi.network_instance.data,
                ogs_min(message->pdi.network_instance.len,
                    OGS_MAX_DNN_LEN)) > 0) {
                if (pdr->dnn)
                    ogs_free(pdr->dnn);
                pdr->dnn = ogs_strdup(dnn);
                ogs_assert(pdr->dnn);
            } else {
                ogs_error("Invalid pdi.network_instance");
            }
        }

        if (message->pdi.local_f_teid.presence) {
            pdr->f_teid_len = message->pdi.local_f_teid.len;
            memcpy(&pdr->f_teid, message->pdi.local_f_teid.data,
                    ogs_min(sizeof(pdr->f_teid), pdr->f_teid_len));
            pdr->f_teid.teid = be32toh(pdr->f_teid.teid);
        }

        if (message->pdi.qfi.presence) {
            pdr->qfi = message->pdi.qfi.u8;
        }
    }

    return pdr;
}

bool ogs_pfcp_handle_remove_pdr(ogs_pfcp_sess_t *sess,
        ogs_pfcp_tlv_remove_pdr_t *message,
        uint8_t *cause_value, uint8_t *offending_ie_value)
{
    ogs_pfcp_pdr_t *pdr = NULL;

    ogs_assert(sess);
    ogs_assert(message);

    if (message->presence == 0)
        return false;

    if (message->pdr_id.presence == 0) {
        ogs_error("No PDR-ID");
        *cause_value = OGS_PFCP_CAUSE_MANDATORY_IE_MISSING;
        *offending_ie_value = OGS_PFCP_PDR_ID_TYPE;
        return false;
    }

    pdr = ogs_pfcp_pdr_find(sess, message->pdr_id.u16);
    if (!pdr) {
        ogs_error("Unknown PDR-ID[%d]", message->pdr_id.u16);
        *cause_value = OGS_PFCP_CAUSE_SESSION_CONTEXT_NOT_FOUND;
        return false;
    }

    ogs_pfcp_pdr_remove(pdr);

    return true;
}

ogs_pfcp_far_t *ogs_pfcp_handle_create_far(ogs_pfcp_sess_t *sess,
        ogs_pfcp_tlv_create_far_t *message,
        uint8_t *cause_value, uint8_t *offending_ie_value)
{
    ogs_pfcp_far_t *far = NULL;

    ogs_assert(message);
    ogs_assert(sess);

    if (message->presence == 0)
        return NULL;

    if (message->far_id.presence == 0) {
        ogs_error("No FAR-ID");
        *cause_value = OGS_PFCP_CAUSE_MANDATORY_IE_MISSING;
        *offending_ie_value = OGS_PFCP_FAR_ID_TYPE;
        return NULL;
    }

    far = ogs_pfcp_far_find(sess, message->far_id.u32);
    if (!far) {
        ogs_error("Cannot find FAR-ID[%d] in PDR", message->far_id.u32);
        *cause_value = OGS_PFCP_CAUSE_MANDATORY_IE_INCORRECT;
        *offending_ie_value = OGS_PFCP_FAR_ID_TYPE;
        return NULL;
    }

    if (message->apply_action.presence == 0) {
        ogs_error("No Apply Action");
        *cause_value = OGS_PFCP_CAUSE_MANDATORY_IE_MISSING;
        *offending_ie_value = OGS_PFCP_APPLY_ACTION_TYPE;
        return NULL;
    }

    far->apply_action = message->apply_action.u16;

    far->dst_if = 0;
    memset(&far->outer_header_creation, 0, sizeof(far->outer_header_creation));

    if (far->dnn) {
        ogs_free(far->dnn);
        far->dnn = NULL;
    }

    if (message->forwarding_parameters.presence) {
        if (message->forwarding_parameters.destination_interface.presence) {
            far->dst_if =
                message->forwarding_parameters.destination_interface.u8;
        }

        if (message->forwarding_parameters.destination_interface_type.
                presence) {
            far->dst_if_type_presence = true;
            far->dst_if_type = message->forwarding_parameters.
                destination_interface_type.u8;
        }

        if (message->forwarding_parameters.network_instance.presence) {
            char dnn[OGS_MAX_DNN_LEN+1];

            if (ogs_fqdn_parse(dnn,
                message->forwarding_parameters.network_instance.data,
                ogs_min(message->forwarding_parameters.network_instance.len,
                    OGS_MAX_DNN_LEN)) > 0) {
                far->dnn = ogs_strdup(dnn);
                ogs_assert(far->dnn);
            } else {
                ogs_error("Invalid forwarding_parameters.network_instance");
            }
        }

        if (message->forwarding_parameters.outer_header_creation.presence) {
            ogs_pfcp_tlv_outer_header_creation_t *outer_header_creation =
                &message->forwarding_parameters.outer_header_creation;

            ogs_assert(outer_header_creation->data);
            ogs_assert(outer_header_creation->len);

            memcpy(&far->outer_header_creation, outer_header_creation->data,
                    ogs_min(sizeof(far->outer_header_creation),
                            outer_header_creation->len));
            far->outer_header_creation.teid =
                    be32toh(far->outer_header_creation.teid);
        }
    }

    return far;
}

ogs_pfcp_far_t *ogs_pfcp_handle_update_far_flags(ogs_pfcp_sess_t *sess,
        ogs_pfcp_tlv_update_far_t *message,
        uint8_t *cause_value, uint8_t *offending_ie_value)
{
    ogs_pfcp_far_t *far = NULL;

    ogs_assert(message);
    ogs_assert(sess);

    if (message->presence == 0)
        return NULL;

    if (message->far_id.presence == 0) {
        ogs_error("No FAR-ID");
        *cause_value = OGS_PFCP_CAUSE_MANDATORY_IE_MISSING;
        *offending_ie_value = OGS_PFCP_FAR_ID_TYPE;
        return NULL;
    }

    far = ogs_pfcp_far_find(sess, message->far_id.u32);
    if (!far) {
        ogs_error("Cannot find FAR-ID[%d] in PDR", message->far_id.u32);
        *cause_value = OGS_PFCP_CAUSE_MANDATORY_IE_INCORRECT;
        *offending_ie_value = OGS_PFCP_FAR_ID_TYPE;
        return NULL;
    }

    if (message->update_forwarding_parameters.presence) {

        if (message->update_forwarding_parameters.pfcpsmreq_flags.presence) {
            far->smreq_flags.value =
                message->update_forwarding_parameters.pfcpsmreq_flags.u8;
        }
    }

    return far;
}

ogs_pfcp_far_t *ogs_pfcp_handle_update_far(ogs_pfcp_sess_t *sess,
        ogs_pfcp_tlv_update_far_t *message,
        uint8_t *cause_value, uint8_t *offending_ie_value)
{
    ogs_pfcp_far_t *far = NULL;

    ogs_assert(message);
    ogs_assert(sess);

    if (message->presence == 0)
        return NULL;

    if (message->far_id.presence == 0) {
        ogs_error("No FAR-ID");
        *cause_value = OGS_PFCP_CAUSE_MANDATORY_IE_MISSING;
        *offending_ie_value = OGS_PFCP_FAR_ID_TYPE;
        return NULL;
    }

    far = ogs_pfcp_far_find(sess, message->far_id.u32);
    if (!far) {
        ogs_error("Cannot find FAR-ID[%d] in PDR", message->far_id.u32);
        *cause_value = OGS_PFCP_CAUSE_MANDATORY_IE_INCORRECT;
        *offending_ie_value = OGS_PFCP_FAR_ID_TYPE;
        return NULL;
    }

    if (message->apply_action.presence)
        far->apply_action = message->apply_action.u16;

    if (message->update_forwarding_parameters.presence) {
        if (message->update_forwarding_parameters.
                destination_interface.presence) {
            far->dst_if =
                message->update_forwarding_parameters.destination_interface.u8;
        }

        if (message->update_forwarding_parameters.destination_interface_type.
                presence) {
            far->dst_if_type_presence = true;
            far->dst_if_type = message->update_forwarding_parameters.
                destination_interface_type.u8;
        }

        if (message->update_forwarding_parameters.network_instance.presence) {
            char dnn[OGS_MAX_DNN_LEN+1];

            if (ogs_fqdn_parse(dnn,
                message->update_forwarding_parameters.network_instance.data,
                ogs_min(message->update_forwarding_parameters.
                    network_instance.len, OGS_MAX_DNN_LEN)) > 0) {
                if (far->dnn)
                    ogs_free(far->dnn);
                far->dnn = ogs_strdup(dnn);
                ogs_assert(far->dnn);
            } else {
                ogs_error("Invalid "
                        "update_forwarding_parameters.network_instance");
            }
        }

        if (message->update_forwarding_parameters.
                outer_header_creation.presence) {
            ogs_pfcp_tlv_outer_header_creation_t *outer_header_creation =
                &message->update_forwarding_parameters.outer_header_creation;

            ogs_assert(outer_header_creation->data);
            ogs_assert(outer_header_creation->len);

            memcpy(&far->outer_header_creation, outer_header_creation->data,
                    ogs_min(sizeof(far->outer_header_creation),
                            outer_header_creation->len));
            far->outer_header_creation.teid =
                    be32toh(far->outer_header_creation.teid);
        }
    }

    return far;
}

bool ogs_pfcp_handle_remove_far(ogs_pfcp_sess_t *sess,
        ogs_pfcp_tlv_remove_far_t *message,
        uint8_t *cause_value, uint8_t *offending_ie_value)
{
    ogs_pfcp_far_t *far = NULL;

    ogs_assert(sess);
    ogs_assert(message);

    if (message->presence == 0)
        return false;

    if (message->far_id.presence == 0) {
        ogs_error("No FAR-ID");
        *cause_value = OGS_PFCP_CAUSE_MANDATORY_IE_MISSING;
        *offending_ie_value = OGS_PFCP_FAR_ID_TYPE;
        return false;
    }

    far = ogs_pfcp_far_find(sess, message->far_id.u32);
    if (!far) {
        ogs_error("Unknown FAR-ID[%d]", message->far_id.u32);
        *cause_value = OGS_PFCP_CAUSE_SESSION_CONTEXT_NOT_FOUND;
        return false;
    }

    ogs_pfcp_far_remove(far);

    return true;
}

ogs_pfcp_qer_t *ogs_pfcp_handle_create_qer(ogs_pfcp_sess_t *sess,
        ogs_pfcp_tlv_create_qer_t *message,
        uint8_t *cause_value, uint8_t *offending_ie_value)
{
    ogs_pfcp_qer_t *qer = NULL;

    ogs_assert(message);
    ogs_assert(sess);

    if (message->presence == 0)
        return NULL;

    if (message->qer_id.presence == 0) {
        ogs_error("No QER-ID");
        *cause_value = OGS_PFCP_CAUSE_MANDATORY_IE_MISSING;
        *offending_ie_value = OGS_PFCP_QER_ID_TYPE;
        return NULL;
    }

    qer = ogs_pfcp_qer_find(sess, message->qer_id.u32);
    if (!qer) {
        ogs_error("Cannot find QER-ID[%d] in PDR", message->qer_id.u32);
        *cause_value = OGS_PFCP_CAUSE_MANDATORY_IE_INCORRECT;
        *offending_ie_value = OGS_PFCP_QER_ID_TYPE;
        return NULL;
    }

    if (message->gate_status.presence == 0) {
        ogs_error("No Gate Status");
        *cause_value = OGS_PFCP_CAUSE_MANDATORY_IE_MISSING;
        *offending_ie_value = OGS_PFCP_APPLY_ACTION_TYPE;
        return NULL;
    }

    qer->gate_status.value = message->gate_status.u8;

    memset(&qer->mbr, 0, sizeof(qer->mbr));
    memset(&qer->gbr, 0, sizeof(qer->gbr));

    if (message->maximum_bitrate.presence)
        ogs_pfcp_parse_bitrate(&qer->mbr, &message->maximum_bitrate);
    if (message->guaranteed_bitrate.presence)
        ogs_pfcp_parse_bitrate(&qer->gbr, &message->guaranteed_bitrate);

    qer->qfi = 0;

    if (message->qos_flow_identifier.presence)
        qer->qfi = message->qos_flow_identifier.u8;

    return qer;
}

ogs_pfcp_qer_t *ogs_pfcp_handle_update_qer(ogs_pfcp_sess_t *sess,
        ogs_pfcp_tlv_update_qer_t *message,
        uint8_t *cause_value, uint8_t *offending_ie_value)
{
    ogs_pfcp_qer_t *qer = NULL;

    ogs_assert(message);
    ogs_assert(sess);

    if (message->presence == 0)
        return NULL;

    if (message->qer_id.presence == 0) {
        ogs_error("No QER-ID");
        *cause_value = OGS_PFCP_CAUSE_MANDATORY_IE_MISSING;
        *offending_ie_value = OGS_PFCP_QER_ID_TYPE;
        return NULL;
    }

    qer = ogs_pfcp_qer_find(sess, message->qer_id.u32);
    if (!qer) {
        ogs_error("Cannot find QER-ID[%d] in PDR", message->qer_id.u32);
        *cause_value = OGS_PFCP_CAUSE_MANDATORY_IE_INCORRECT;
        *offending_ie_value = OGS_PFCP_QER_ID_TYPE;
        return NULL;
    }

    if (message->maximum_bitrate.presence)
        ogs_pfcp_parse_bitrate(&qer->mbr, &message->maximum_bitrate);
    if (message->guaranteed_bitrate.presence)
        ogs_pfcp_parse_bitrate(&qer->gbr, &message->guaranteed_bitrate);

    return qer;
}

bool ogs_pfcp_handle_remove_qer(ogs_pfcp_sess_t *sess,
        ogs_pfcp_tlv_remove_qer_t *message,
        uint8_t *cause_value, uint8_t *offending_ie_value)
{
    ogs_pfcp_qer_t *qer = NULL;

    ogs_assert(sess);
    ogs_assert(message);

    if (message->presence == 0)
        return false;

    if (message->qer_id.presence == 0) {
        ogs_error("No QER-ID");
        *cause_value = OGS_PFCP_CAUSE_MANDATORY_IE_MISSING;
        *offending_ie_value = OGS_PFCP_QER_ID_TYPE;
        return false;
    }

    qer = ogs_pfcp_qer_find(sess, message->qer_id.u32);
    if (!qer) {
        ogs_error("Unknown QER-ID[%d]", message->qer_id.u32);
        *cause_value = OGS_PFCP_CAUSE_SESSION_CONTEXT_NOT_FOUND;
        return false;
    }

    ogs_pfcp_qer_remove(qer);

    return true;
}

ogs_pfcp_bar_t *ogs_pfcp_handle_create_bar(ogs_pfcp_sess_t *sess,
        ogs_pfcp_tlv_create_bar_t *message,
        uint8_t *cause_value, uint8_t *offending_ie_value)
{
    ogs_assert(message);
    ogs_assert(sess);

    if (message->presence == 0)
        return NULL;

    if (message->bar_id.presence == 0) {
        ogs_error("No BAR-ID");
        *cause_value = OGS_PFCP_CAUSE_MANDATORY_IE_MISSING;
        *offending_ie_value = OGS_PFCP_BAR_ID_TYPE;
        return NULL;
    }

    if (sess->bar)
        ogs_pfcp_bar_delete(sess->bar);

    ogs_pfcp_bar_new(sess);
    ogs_assert(sess->bar);

    sess->bar->id = message->bar_id.u8;

    return sess->bar;
}

bool ogs_pfcp_handle_remove_bar(ogs_pfcp_sess_t *sess,
        ogs_pfcp_tlv_remove_bar_t *message,
        uint8_t *cause_value, uint8_t *offending_ie_value)
{
    ogs_assert(sess);
    ogs_assert(message);

    if (message->presence == 0)
        return false;

    if (message->bar_id.presence == 0) {
        ogs_error("No BAR-ID");
        *cause_value = OGS_PFCP_CAUSE_MANDATORY_IE_MISSING;
        *offending_ie_value = OGS_PFCP_BAR_ID_TYPE;
        return false;
    }

    if (sess->bar && sess->bar->id == message->bar_id.u8) {
        ogs_pfcp_bar_delete(sess->bar);
        return true;
    }

    ogs_error("[%p] Unknown BAR-ID[%d]", sess->bar, message->bar_id.u8);
    *cause_value = OGS_PFCP_CAUSE_SESSION_CONTEXT_NOT_FOUND;
    return false;
}

ogs_pfcp_urr_t *ogs_pfcp_handle_create_urr(ogs_pfcp_sess_t *sess,
        ogs_pfcp_tlv_create_urr_t *message,
        uint8_t *cause_value, uint8_t *offending_ie_value)
{
    int16_t decoded;
    ogs_pfcp_urr_t *urr = NULL;

    ogs_assert(message);
    ogs_assert(sess);

    if (message->presence == 0)
        return NULL;

    if (message->urr_id.presence == 0) {
        ogs_error("No URR-ID");
        *cause_value = OGS_PFCP_CAUSE_MANDATORY_IE_MISSING;
        *offending_ie_value = OGS_PFCP_URR_ID_TYPE;
        return NULL;
    }

    urr = ogs_pfcp_urr_find(sess, message->urr_id.u32);
    if (!urr) {
        ogs_error("Cannot find URR-ID[%d] in PDR", message->urr_id.u32);
        *cause_value = OGS_PFCP_CAUSE_MANDATORY_IE_INCORRECT;
        *offending_ie_value = OGS_PFCP_URR_ID_TYPE;
        return NULL;
    }

    if (message->measurement_method.presence == 0) {
        ogs_error("No Measurement Method");
        *cause_value = OGS_PFCP_CAUSE_MANDATORY_IE_MISSING;
        *offending_ie_value = OGS_PFCP_MEASUREMENT_METHOD_TYPE;
        return NULL;
    }

    if (message->reporting_triggers.presence == 0) {
        ogs_error("No Reporting Triggers");
        *cause_value = OGS_PFCP_CAUSE_MANDATORY_IE_MISSING;
        *offending_ie_value = OGS_PFCP_REPORTING_TRIGGERS_TYPE;
        return NULL;
    }

    urr->meas_method = message->measurement_method.u8;
    urr->rep_triggers.reptri_5 = (message->reporting_triggers.u24 >> 16) & 0xFF;
    urr->rep_triggers.reptri_6 = (message->reporting_triggers.u24 >> 8) & 0xFF;
    urr->rep_triggers.reptri_7 = message->reporting_triggers.u24 & 0xFF;

    if (message->measurement_period.presence) {
        urr->meas_period = message->measurement_period.u32;
    }

    if (message->volume_threshold.presence &&
        (urr->meas_method & OGS_PFCP_MEASUREMENT_METHOD_VOLUME)) {
        decoded = ogs_pfcp_parse_volume(
                &urr->vol_threshold, &message->volume_threshold);
        if (message->volume_threshold.len != decoded) {
            ogs_error("Invalid Volume Threshold");
            *cause_value = OGS_PFCP_CAUSE_MANDATORY_IE_INCORRECT;
            *offending_ie_value = OGS_PFCP_VOLUME_THRESHOLD_TYPE;
            return NULL;
        }
    }

    if (message->volume_quota.presence &&
        (urr->meas_method & OGS_PFCP_MEASUREMENT_METHOD_VOLUME)) {
        decoded = ogs_pfcp_parse_volume(
                &urr->vol_quota, &message->volume_quota);
        if (message->volume_quota.len != decoded) {
            ogs_error("Invalid Volume Quota");
            *cause_value = OGS_PFCP_CAUSE_MANDATORY_IE_INCORRECT;
            *offending_ie_value = OGS_PFCP_VOLUME_QUOTA_TYPE;
            return NULL;
        }
    }

    if (message->event_threshold.presence &&
        (urr->meas_method & OGS_PFCP_MEASUREMENT_METHOD_EVENT)) {
        urr->event_threshold = message->event_threshold.u32;
    }

    if (message->event_quota.presence &&
        (urr->meas_method & OGS_PFCP_MEASUREMENT_METHOD_EVENT)) {
        urr->event_quota = message->event_quota.u32;
    }

    if (message->time_threshold.presence &&
        (urr->meas_method & OGS_PFCP_MEASUREMENT_METHOD_DURATION)) {
        urr->time_threshold = message->time_threshold.u32;
    }

    if (message->time_quota.presence &&
        (urr->meas_method & OGS_PFCP_MEASUREMENT_METHOD_DURATION)) {
        urr->time_quota = message->time_quota.u32;
    }

    if (message->quota_holding_time.presence) {
        urr->quota_holding_time = message->quota_holding_time.u32;
    }

    if (message->dropped_dl_traffic_threshold.presence) {
        ogs_pfcp_parse_dropped_dl_traffic_threshold(
                &urr->dropped_dl_traffic_threshold,
                &message->dropped_dl_traffic_threshold);
    }

    if (message->quota_validity_time.presence) {
        urr->quota_validity_time = message->quota_validity_time.u32;
    }

    if (message->measurement_information.presence &&
        message->measurement_information.len >= 1) {
        urr->meas_info.octet5 = *((unsigned char *)message->measurement_information.data);
    }

    return urr;
}

ogs_pfcp_urr_t *ogs_pfcp_handle_update_urr(ogs_pfcp_sess_t *sess,
        ogs_pfcp_tlv_update_urr_t *message,
        uint8_t *cause_value, uint8_t *offending_ie_value)
{
    int16_t decoded;
    ogs_pfcp_urr_t *urr = NULL;

    ogs_assert(message);
    ogs_assert(sess);

    if (message->presence == 0)
        return NULL;

    if (message->urr_id.presence == 0) {
        ogs_error("No URR-ID");
        *cause_value = OGS_PFCP_CAUSE_MANDATORY_IE_MISSING;
        *offending_ie_value = OGS_PFCP_URR_ID_TYPE;
        return NULL;
    }

    urr = ogs_pfcp_urr_find(sess, message->urr_id.u32);
    if (!urr) {
        ogs_error("Cannot find URR-ID[%d] in PDR", message->urr_id.u32);
        *cause_value = OGS_PFCP_CAUSE_MANDATORY_IE_INCORRECT;
        *offending_ie_value = OGS_PFCP_URR_ID_TYPE;
        return NULL;
    }

    if (message->measurement_method.presence)
        urr->meas_method = message->measurement_method.u8;

    if (message->reporting_triggers.presence) {
        urr->rep_triggers.reptri_5 = message->reporting_triggers.u24 & 0xFF;
        urr->rep_triggers.reptri_6 = (message->reporting_triggers.u24 >> 8) & 0xFF;
        urr->rep_triggers.reptri_7 = (message->reporting_triggers.u24 >> 16) & 0xFF;
    }

    if (message->measurement_period.presence) {
        urr->meas_period = message->measurement_period.u32;
    }

    if (message->volume_threshold.presence &&
        (urr->meas_method & OGS_PFCP_MEASUREMENT_METHOD_VOLUME)) {
        decoded = ogs_pfcp_parse_volume(
                &urr->vol_threshold, &message->volume_threshold);
        if (message->volume_threshold.len != decoded) {
            ogs_error("Invalid Volume Threshold");
            *cause_value = OGS_PFCP_CAUSE_MANDATORY_IE_INCORRECT;
            *offending_ie_value = OGS_PFCP_VOLUME_THRESHOLD_TYPE;
            return NULL;
        }
    }

    if (message->volume_quota.presence &&
        (urr->meas_method & OGS_PFCP_MEASUREMENT_METHOD_VOLUME)) {
        decoded = ogs_pfcp_parse_volume(
                &urr->vol_quota, &message->volume_quota);
        if (message->volume_quota.len != decoded) {
            ogs_error("Invalid Volume Quota");
            *cause_value = OGS_PFCP_CAUSE_MANDATORY_IE_INCORRECT;
            *offending_ie_value = OGS_PFCP_VOLUME_QUOTA_TYPE;
            return NULL;
        }
    }

    if (message->event_threshold.presence &&
        (urr->meas_method & OGS_PFCP_MEASUREMENT_METHOD_EVENT)) {
        urr->event_threshold = message->event_threshold.u32;
    }

    if (message->event_quota.presence &&
        (urr->meas_method & OGS_PFCP_MEASUREMENT_METHOD_EVENT)) {
        urr->event_quota = message->event_quota.u32;
    }

    if (message->time_threshold.presence &&
        (urr->meas_method & OGS_PFCP_MEASUREMENT_METHOD_DURATION)) {
        urr->time_threshold = message->time_threshold.u32;
    }

    if (message->time_quota.presence &&
        (urr->meas_method & OGS_PFCP_MEASUREMENT_METHOD_DURATION)) {
        urr->time_quota = message->time_quota.u32;
    }

    if (message->quota_holding_time.presence) {
        urr->quota_holding_time = message->quota_holding_time.u32;
    }

    if (message->dropped_dl_traffic_threshold.presence) {
        ogs_pfcp_parse_dropped_dl_traffic_threshold(
                &urr->dropped_dl_traffic_threshold,
                &message->dropped_dl_traffic_threshold);
    }

    if (message->quota_validity_time.presence) {
        urr->quota_validity_time = message->quota_validity_time.u32;
    }

    if (message->measurement_information.presence &&
        message->measurement_information.len >= 1) {
        urr->meas_info.octet5 = *((unsigned char *)message->measurement_information.data);
    }

    return urr;
}

bool ogs_pfcp_handle_remove_urr(ogs_pfcp_sess_t *sess,
        ogs_pfcp_tlv_remove_urr_t *message,
        uint8_t *cause_value, uint8_t *offending_ie_value)
{
    ogs_pfcp_urr_t *urr = NULL;

    ogs_assert(sess);
    ogs_assert(message);

    if (message->presence == 0)
        return false;

    if (message->urr_id.presence == 0) {
        ogs_error("No URR-ID");
        *cause_value = OGS_PFCP_CAUSE_MANDATORY_IE_MISSING;
        *offending_ie_value = OGS_PFCP_URR_ID_TYPE;
        return false;
    }

    urr = ogs_pfcp_urr_find(sess, message->urr_id.u32);
    if (!urr) {
        ogs_error("Unknown URR-ID[%d]", message->urr_id.u32);
        *cause_value = OGS_PFCP_CAUSE_SESSION_CONTEXT_NOT_FOUND;
        return false;
    }

    ogs_pfcp_urr_remove(urr);

    return true;
}
===== handler.h =====

#ifndef OGS_PFCP_HANDLER_H
#define OGS_PFCP_HANDLER_H

#ifdef __cplusplus
extern "C" {
#endif

bool ogs_pfcp_handle_heartbeat_request(
        ogs_pfcp_node_t *node, ogs_pfcp_xact_t *xact,
        ogs_pfcp_heartbeat_request_t *req);
bool ogs_pfcp_handle_heartbeat_response(
        ogs_pfcp_node_t *node, ogs_pfcp_xact_t *xact,
        ogs_pfcp_heartbeat_response_t *req);

bool ogs_pfcp_cp_handle_association_setup_request(
        ogs_pfcp_node_t *node, ogs_pfcp_xact_t *xact,
        ogs_pfcp_association_setup_request_t *req);
bool ogs_pfcp_cp_handle_association_setup_response(
        ogs_pfcp_node_t *node, ogs_pfcp_xact_t *xact,
        ogs_pfcp_association_setup_response_t *req);

bool ogs_pfcp_up_handle_association_setup_request(
        ogs_pfcp_node_t *node, ogs_pfcp_xact_t *xact,
        ogs_pfcp_association_setup_request_t *req);
bool ogs_pfcp_up_handle_association_setup_response(
        ogs_pfcp_node_t *node, ogs_pfcp_xact_t *xact,
        ogs_pfcp_association_setup_response_t *req);

bool ogs_pfcp_up_handle_pdr(
        ogs_pfcp_pdr_t *pdr, uint8_t type,
        ogs_gtp2_header_desc_t *recvhdr, ogs_pkbuf_t *recvbuf,
        ogs_pfcp_user_plane_report_t *report);
bool ogs_pfcp_up_handle_error_indication(
        ogs_pfcp_far_t *far, ogs_pfcp_user_plane_report_t *report);

ogs_pfcp_pdr_t *ogs_pfcp_handle_create_pdr(ogs_pfcp_sess_t *sess,
        ogs_pfcp_tlv_create_pdr_t *message,
        ogs_pfcp_sereq_flags_t *sereq_flags,
        uint8_t *cause_value, uint8_t *offending_ie_value);
ogs_pfcp_pdr_t *ogs_pfcp_handle_created_pdr(ogs_pfcp_sess_t *sess,
        ogs_pfcp_tlv_created_pdr_t *message,
        uint8_t *cause_value, uint8_t *offending_ie_value);
ogs_pfcp_pdr_t *ogs_pfcp_handle_update_pdr(ogs_pfcp_sess_t *sess,
        ogs_pfcp_tlv_update_pdr_t *message,
        uint8_t *cause_value, uint8_t *offending_ie_value);
bool ogs_pfcp_handle_remove_pdr(ogs_pfcp_sess_t *sess,
        ogs_pfcp_tlv_remove_pdr_t *message,
        uint8_t *cause_value, uint8_t *offending_ie_value);

ogs_pfcp_far_t *ogs_pfcp_handle_create_far(ogs_pfcp_sess_t *sess,
        ogs_pfcp_tlv_create_far_t *message,
        uint8_t *cause_value, uint8_t *offending_ie_value);
ogs_pfcp_far_t *ogs_pfcp_handle_update_far_flags(ogs_pfcp_sess_t *sess,
        ogs_pfcp_tlv_update_far_t *message,
        uint8_t *cause_value, uint8_t *offending_ie_value);
ogs_pfcp_far_t *ogs_pfcp_handle_update_far(ogs_pfcp_sess_t *sess,
        ogs_pfcp_tlv_update_far_t *message,
        uint8_t *cause_value, uint8_t *offending_ie_value);
bool ogs_pfcp_handle_remove_far(ogs_pfcp_sess_t *sess,
        ogs_pfcp_tlv_remove_far_t *message,
        uint8_t *cause_value, uint8_t *offending_ie_value);

ogs_pfcp_qer_t *ogs_pfcp_handle_create_qer(ogs_pfcp_sess_t *sess,
        ogs_pfcp_tlv_create_qer_t *message,
        uint8_t *cause_value, uint8_t *offending_ie_value);
ogs_pfcp_qer_t *ogs_pfcp_handle_update_qer(ogs_pfcp_sess_t *sess,
        ogs_pfcp_tlv_update_qer_t *message,
        uint8_t *cause_value, uint8_t *offending_ie_value);
bool ogs_pfcp_handle_remove_qer(ogs_pfcp_sess_t *sess,
        ogs_pfcp_tlv_remove_qer_t *message,
        uint8_t *cause_value, uint8_t *offending_ie_value);

ogs_pfcp_bar_t *ogs_pfcp_handle_create_bar(ogs_pfcp_sess_t *sess,
        ogs_pfcp_tlv_create_bar_t *message,
        uint8_t *cause_value, uint8_t *offending_ie_value);
bool ogs_pfcp_handle_remove_bar(ogs_pfcp_sess_t *sess,
        ogs_pfcp_tlv_remove_bar_t *message,
        uint8_t *cause_value, uint8_t *offending_ie_value);

ogs_pfcp_urr_t *ogs_pfcp_handle_create_urr(ogs_pfcp_sess_t *sess,
        ogs_pfcp_tlv_create_urr_t *message,
        uint8_t *cause_value, uint8_t *offending_ie_value);
ogs_pfcp_urr_t *ogs_pfcp_handle_update_urr(ogs_pfcp_sess_t *sess,
        ogs_pfcp_tlv_update_urr_t *message,
        uint8_t *cause_value, uint8_t *offending_ie_value);
bool ogs_pfcp_handle_remove_urr(ogs_pfcp_sess_t *sess,
        ogs_pfcp_tlv_remove_urr_t *message,
        uint8_t *cause_value, uint8_t *offending_ie_value);

#ifdef __cplusplus
}
#endif

#endif /* OGS_PFCP_HANDLER_H */
===== meson.build =====
# Copyright (C) 2019 by Sukchan Lee <acetcom@gmail.com>

# This file is part of Open5GS.

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

pfcp_conf = configuration_data()

pfcp_headers = ('''
    netinet/ip.h
    netinet/ip6.h
    netinet/udp.h
    netinet/tcp.h
'''.split())

foreach h : pfcp_headers
    if cc.has_header(h)
        define = 'HAVE_' + h.underscorify().to_upper()
        pfcp_conf.set(define, 1)
    endif
endforeach

configure_file(output : 'pfcp-config.h', configuration : pfcp_conf)

libpfcp_sources = files('''
    ogs-pfcp.h

    message.h
    types.h
    conv.h
    build.h
    handler.h
    path.h
    xact.h
    context.h
    rule-match.h
    util.h

    message.c
    types.c
    conv.c
    build.c
    handler.c
    path.c
    xact.c
    context.c
    rule-match.c
    util.c
'''.split())

libpfcp_inc = include_directories('.')

libpfcp = library('ogspfcp',
    sources : libpfcp_sources,
    version : libogslib_version,
    c_args : '-DOGS_PFCP_COMPILATION',
    include_directories : [libpfcp_inc, libinc],
    dependencies : libgtp_dep,
    install_rpath : libdir,
    install : true)

libpfcp_dep = declare_dependency(
    link_with : libpfcp,
    include_directories : [libpfcp_inc, libinc],
    dependencies : libgtp_dep)
===== message.c =====

/*******************************************************************************
 * This file had been created by pfcp-tlv.py script v0.1.0
 * Please do not modify this file but regenerate it via script.
 * Created on: 2024-10-20 22:37:02.550243 by acetcom
 * from 29244-h71-modified.docx
 ******************************************************************************/

#include "ogs-pfcp.h"

ogs_tlv_desc_t ogs_pfcp_tlv_desc_cause =
{
    OGS_TLV_UINT8,
    "Cause",
    OGS_PFCP_CAUSE_TYPE,
    1,
    0,
    sizeof(ogs_pfcp_tlv_cause_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_source_interface =
{
    OGS_TLV_UINT8,
    "Source Interface",
    OGS_PFCP_SOURCE_INTERFACE_TYPE,
    1,
    0,
    sizeof(ogs_pfcp_tlv_source_interface_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_f_teid =
{
    OGS_TLV_VAR_STR,
    "F-TEID",
    OGS_PFCP_F_TEID_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_f_teid_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_network_instance =
{
    OGS_TLV_VAR_STR,
    "Network Instance",
    OGS_PFCP_NETWORK_INSTANCE_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_network_instance_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_sdf_filter =
{
    OGS_TLV_VAR_STR,
    "SDF Filter",
    OGS_PFCP_SDF_FILTER_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_sdf_filter_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_application_id =
{
    OGS_TLV_VAR_STR,
    "Application ID",
    OGS_PFCP_APPLICATION_ID_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_application_id_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_gate_status =
{
    OGS_TLV_UINT8,
    "Gate Status",
    OGS_PFCP_GATE_STATUS_TYPE,
    1,
    0,
    sizeof(ogs_pfcp_tlv_gate_status_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_mbr =
{
    OGS_TLV_VAR_STR,
    "MBR",
    OGS_PFCP_MBR_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_mbr_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_gbr =
{
    OGS_TLV_VAR_STR,
    "GBR",
    OGS_PFCP_GBR_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_gbr_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_qer_correlation_id =
{
    OGS_TLV_UINT32,
    "QER Correlation ID",
    OGS_PFCP_QER_CORRELATION_ID_TYPE,
    4,
    0,
    sizeof(ogs_pfcp_tlv_qer_correlation_id_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_precedence =
{
    OGS_TLV_UINT32,
    "Precedence",
    OGS_PFCP_PRECEDENCE_TYPE,
    4,
    0,
    sizeof(ogs_pfcp_tlv_precedence_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_transport_level_marking =
{
    OGS_TLV_VAR_STR,
    "Transport Level Marking",
    OGS_PFCP_TRANSPORT_LEVEL_MARKING_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_transport_level_marking_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_volume_threshold =
{
    OGS_TLV_VAR_STR,
    "Volume Threshold",
    OGS_PFCP_VOLUME_THRESHOLD_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_volume_threshold_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_time_threshold =
{
    OGS_TLV_UINT32,
    "Time Threshold",
    OGS_PFCP_TIME_THRESHOLD_TYPE,
    4,
    0,
    sizeof(ogs_pfcp_tlv_time_threshold_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_monitoring_time =
{
    OGS_TLV_VAR_STR,
    "Monitoring Time",
    OGS_PFCP_MONITORING_TIME_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_monitoring_time_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_subsequent_volume_threshold =
{
    OGS_TLV_VAR_STR,
    "Subsequent Volume Threshold",
    OGS_PFCP_SUBSEQUENT_VOLUME_THRESHOLD_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_subsequent_volume_threshold_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_subsequent_time_threshold =
{
    OGS_TLV_VAR_STR,
    "Subsequent Time Threshold",
    OGS_PFCP_SUBSEQUENT_TIME_THRESHOLD_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_subsequent_time_threshold_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_inactivity_detection_time =
{
    OGS_TLV_VAR_STR,
    "Inactivity Detection Time",
    OGS_PFCP_INACTIVITY_DETECTION_TIME_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_inactivity_detection_time_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_reporting_triggers =
{
    OGS_TLV_UINT24,
    "Reporting Triggers",
    OGS_PFCP_REPORTING_TRIGGERS_TYPE,
    3,
    0,
    sizeof(ogs_pfcp_tlv_reporting_triggers_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_redirect_information =
{
    OGS_TLV_VAR_STR,
    "Redirect Information",
    OGS_PFCP_REDIRECT_INFORMATION_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_redirect_information_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_report_type =
{
    OGS_TLV_UINT8,
    "Report Type",
    OGS_PFCP_REPORT_TYPE_TYPE,
    1,
    0,
    sizeof(ogs_pfcp_tlv_report_type_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_offending_ie =
{
    OGS_TLV_UINT16,
    "Offending IE",
    OGS_PFCP_OFFENDING_IE_TYPE,
    2,
    0,
    sizeof(ogs_pfcp_tlv_offending_ie_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_forwarding_policy =
{
    OGS_TLV_VAR_STR,
    "Forwarding Policy",
    OGS_PFCP_FORWARDING_POLICY_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_forwarding_policy_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_destination_interface =
{
    OGS_TLV_UINT8,
    "Destination Interface",
    OGS_PFCP_DESTINATION_INTERFACE_TYPE,
    1,
    0,
    sizeof(ogs_pfcp_tlv_destination_interface_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_up_function_features =
{
    OGS_TLV_VAR_STR,
    "UP Function Features",
    OGS_PFCP_UP_FUNCTION_FEATURES_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_up_function_features_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_apply_action =
{
    OGS_TLV_UINT16,
    "Apply Action",
    OGS_PFCP_APPLY_ACTION_TYPE,
    2,
    0,
    sizeof(ogs_pfcp_tlv_apply_action_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_downlink_data_service_information =
{
    OGS_TLV_VAR_STR,
    "Downlink Data Service Information",
    OGS_PFCP_DOWNLINK_DATA_SERVICE_INFORMATION_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_downlink_data_service_information_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_downlink_data_notification_delay =
{
    OGS_TLV_VAR_STR,
    "Downlink Data Notification Delay",
    OGS_PFCP_DOWNLINK_DATA_NOTIFICATION_DELAY_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_downlink_data_notification_delay_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_dl_buffering_duration =
{
    OGS_TLV_VAR_STR,
    "DL Buffering Duration",
    OGS_PFCP_DL_BUFFERING_DURATION_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_dl_buffering_duration_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_dl_buffering_suggested_packet_count =
{
    OGS_TLV_VAR_STR,
    "DL Buffering Suggested Packet Count",
    OGS_PFCP_DL_BUFFERING_SUGGESTED_PACKET_COUNT_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_dl_buffering_suggested_packet_count_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_pfcpsmreq_flags =
{
    OGS_TLV_UINT8,
    "PFCPSMReq-Flags",
    OGS_PFCP_PFCPSMREQ_FLAGS_TYPE,
    1,
    0,
    sizeof(ogs_pfcp_tlv_pfcpsmreq_flags_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_pfcpsrrsp_flags =
{
    OGS_TLV_UINT8,
    "PFCPSRRsp-Flags",
    OGS_PFCP_PFCPSRRSP_FLAGS_TYPE,
    1,
    0,
    sizeof(ogs_pfcp_tlv_pfcpsrrsp_flags_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_sequence_number =
{
    OGS_TLV_VAR_STR,
    "Sequence Number",
    OGS_PFCP_SEQUENCE_NUMBER_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_sequence_number_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_metric =
{
    OGS_TLV_VAR_STR,
    "Metric",
    OGS_PFCP_METRIC_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_metric_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_timer =
{
    OGS_TLV_VAR_STR,
    "Timer",
    OGS_PFCP_TIMER_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_timer_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_pdr_id =
{
    OGS_TLV_UINT16,
    "PDR ID",
    OGS_PFCP_PDR_ID_TYPE,
    2,
    0,
    sizeof(ogs_pfcp_tlv_pdr_id_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_f_seid =
{
    OGS_TLV_VAR_STR,
    "F-SEID",
    OGS_PFCP_F_SEID_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_f_seid_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_node_id =
{
    OGS_TLV_VAR_STR,
    "Node ID",
    OGS_PFCP_NODE_ID_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_node_id_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_pfd_contents =
{
    OGS_TLV_VAR_STR,
    "PFD contents",
    OGS_PFCP_PFD_CONTENTS_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_pfd_contents_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_measurement_method =
{
    OGS_TLV_UINT8,
    "Measurement Method",
    OGS_PFCP_MEASUREMENT_METHOD_TYPE,
    1,
    0,
    sizeof(ogs_pfcp_tlv_measurement_method_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_usage_report_trigger =
{
    OGS_TLV_UINT24,
    "Usage Report Trigger",
    OGS_PFCP_USAGE_REPORT_TRIGGER_TYPE,
    3,
    0,
    sizeof(ogs_pfcp_tlv_usage_report_trigger_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_measurement_period =
{
    OGS_TLV_UINT32,
    "Measurement Period",
    OGS_PFCP_MEASUREMENT_PERIOD_TYPE,
    4,
    0,
    sizeof(ogs_pfcp_tlv_measurement_period_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_fq_csid =
{
    OGS_TLV_VAR_STR,
    "FQ-CSID",
    OGS_PFCP_FQ_CSID_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_fq_csid_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_volume_measurement =
{
    OGS_TLV_VAR_STR,
    "Volume Measurement",
    OGS_PFCP_VOLUME_MEASUREMENT_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_volume_measurement_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_duration_measurement =
{
    OGS_TLV_UINT32,
    "Duration Measurement",
    OGS_PFCP_DURATION_MEASUREMENT_TYPE,
    4,
    0,
    sizeof(ogs_pfcp_tlv_duration_measurement_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_time_of_first_packet =
{
    OGS_TLV_UINT32,
    "Time of First Packet",
    OGS_PFCP_TIME_OF_FIRST_PACKET_TYPE,
    4,
    0,
    sizeof(ogs_pfcp_tlv_time_of_first_packet_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_time_of_last_packet =
{
    OGS_TLV_UINT32,
    "Time of Last Packet",
    OGS_PFCP_TIME_OF_LAST_PACKET_TYPE,
    4,
    0,
    sizeof(ogs_pfcp_tlv_time_of_last_packet_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_quota_holding_time =
{
    OGS_TLV_UINT32,
    "Quota Holding Time",
    OGS_PFCP_QUOTA_HOLDING_TIME_TYPE,
    4,
    0,
    sizeof(ogs_pfcp_tlv_quota_holding_time_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_dropped_dl_traffic_threshold =
{
    OGS_TLV_VAR_STR,
    "Dropped DL Traffic Threshold",
    OGS_PFCP_DROPPED_DL_TRAFFIC_THRESHOLD_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_dropped_dl_traffic_threshold_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_volume_quota =
{
    OGS_TLV_VAR_STR,
    "Volume Quota",
    OGS_PFCP_VOLUME_QUOTA_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_volume_quota_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_time_quota =
{
    OGS_TLV_UINT32,
    "Time Quota",
    OGS_PFCP_TIME_QUOTA_TYPE,
    4,
    0,
    sizeof(ogs_pfcp_tlv_time_quota_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_start_time =
{
    OGS_TLV_UINT32,
    "Start Time",
    OGS_PFCP_START_TIME_TYPE,
    4,
    0,
    sizeof(ogs_pfcp_tlv_start_time_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_end_time =
{
    OGS_TLV_UINT32,
    "End Time",
    OGS_PFCP_END_TIME_TYPE,
    4,
    0,
    sizeof(ogs_pfcp_tlv_end_time_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_urr_id =
{
    OGS_TLV_UINT32,
    "URR ID",
    OGS_PFCP_URR_ID_TYPE,
    4,
    0,
    sizeof(ogs_pfcp_tlv_urr_id_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_linked_urr_id =
{
    OGS_TLV_VAR_STR,
    "Linked URR ID",
    OGS_PFCP_LINKED_URR_ID_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_linked_urr_id_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_outer_header_creation =
{
    OGS_TLV_VAR_STR,
    "Outer Header Creation",
    OGS_PFCP_OUTER_HEADER_CREATION_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_outer_header_creation_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_bar_id =
{
    OGS_TLV_UINT8,
    "BAR ID",
    OGS_PFCP_BAR_ID_TYPE,
    1,
    0,
    sizeof(ogs_pfcp_tlv_bar_id_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_cp_function_features =
{
    OGS_TLV_UINT8,
    "CP Function Features",
    OGS_PFCP_CP_FUNCTION_FEATURES_TYPE,
    1,
    0,
    sizeof(ogs_pfcp_tlv_cp_function_features_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_usage_information =
{
    OGS_TLV_VAR_STR,
    "Usage Information",
    OGS_PFCP_USAGE_INFORMATION_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_usage_information_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_application_instance_id =
{
    OGS_TLV_VAR_STR,
    "Application Instance ID",
    OGS_PFCP_APPLICATION_INSTANCE_ID_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_application_instance_id_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_flow_information =
{
    OGS_TLV_VAR_STR,
    "Flow Information",
    OGS_PFCP_FLOW_INFORMATION_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_flow_information_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_ue_ip_address =
{
    OGS_TLV_VAR_STR,
    "UE IP Address",
    OGS_PFCP_UE_IP_ADDRESS_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_ue_ip_address_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_packet_rate =
{
    OGS_TLV_VAR_STR,
    "Packet Rate",
    OGS_PFCP_PACKET_RATE_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_packet_rate_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_outer_header_removal =
{
    OGS_TLV_VAR_STR,
    "Outer Header Removal",
    OGS_PFCP_OUTER_HEADER_REMOVAL_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_outer_header_removal_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_recovery_time_stamp =
{
    OGS_TLV_UINT32,
    "Recovery Time Stamp",
    OGS_PFCP_RECOVERY_TIME_STAMP_TYPE,
    4,
    0,
    sizeof(ogs_pfcp_tlv_recovery_time_stamp_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_dl_flow_level_marking =
{
    OGS_TLV_VAR_STR,
    "DL Flow Level Marking",
    OGS_PFCP_DL_FLOW_LEVEL_MARKING_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_dl_flow_level_marking_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_header_enrichment =
{
    OGS_TLV_VAR_STR,
    "Header Enrichment",
    OGS_PFCP_HEADER_ENRICHMENT_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_header_enrichment_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_measurement_information =
{
    OGS_TLV_VAR_STR,
    "Measurement Information",
    OGS_PFCP_MEASUREMENT_INFORMATION_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_measurement_information_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_node_report_type =
{
    OGS_TLV_VAR_STR,
    "Node Report Type",
    OGS_PFCP_NODE_REPORT_TYPE_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_node_report_type_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_remote_gtp_u_peer =
{
    OGS_TLV_VAR_STR,
    "Remote GTP-U Peer",
    OGS_PFCP_REMOTE_GTP_U_PEER_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_remote_gtp_u_peer_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_ur_seqn =
{
    OGS_TLV_UINT32,
    "UR-SEQN",
    OGS_PFCP_UR_SEQN_TYPE,
    4,
    0,
    sizeof(ogs_pfcp_tlv_ur_seqn_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_activate_predefined_rules =
{
    OGS_TLV_VAR_STR,
    "Activate Predefined Rules",
    OGS_PFCP_ACTIVATE_PREDEFINED_RULES_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_activate_predefined_rules_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_deactivate_predefined_rules =
{
    OGS_TLV_VAR_STR,
    "Deactivate Predefined Rules",
    OGS_PFCP_DEACTIVATE_PREDEFINED_RULES_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_deactivate_predefined_rules_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_far_id =
{
    OGS_TLV_UINT32,
    "FAR ID",
    OGS_PFCP_FAR_ID_TYPE,
    4,
    0,
    sizeof(ogs_pfcp_tlv_far_id_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_qer_id =
{
    OGS_TLV_UINT32,
    "QER ID",
    OGS_PFCP_QER_ID_TYPE,
    4,
    0,
    sizeof(ogs_pfcp_tlv_qer_id_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_oci_flags =
{
    OGS_TLV_VAR_STR,
    "OCI Flags",
    OGS_PFCP_OCI_FLAGS_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_oci_flags_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_pfcp_association_release_request =
{
    OGS_TLV_VAR_STR,
    "PFCP Association Release Request",
    OGS_PFCP_PFCP_ASSOCIATION_RELEASE_REQUEST_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_pfcp_association_release_request_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_graceful_release_period =
{
    OGS_TLV_VAR_STR,
    "Graceful Release Period",
    OGS_PFCP_GRACEFUL_RELEASE_PERIOD_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_graceful_release_period_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_pdn_type =
{
    OGS_TLV_UINT8,
    "PDN Type",
    OGS_PFCP_PDN_TYPE_TYPE,
    1,
    0,
    sizeof(ogs_pfcp_tlv_pdn_type_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_failed_rule_id =
{
    OGS_TLV_VAR_STR,
    "Failed Rule ID",
    OGS_PFCP_FAILED_RULE_ID_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_failed_rule_id_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_time_quota_mechanism =
{
    OGS_TLV_VAR_STR,
    "Time Quota Mechanism",
    OGS_PFCP_TIME_QUOTA_MECHANISM_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_time_quota_mechanism_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_user_plane_ip_resource_information =
{
    OGS_TLV_VAR_STR,
    "User Plane IP Resource Information",
    OGS_PFCP_USER_PLANE_IP_RESOURCE_INFORMATION_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_user_plane_ip_resource_information_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_user_plane_inactivity_timer =
{
    OGS_TLV_VAR_STR,
    "User Plane Inactivity Timer",
    OGS_PFCP_USER_PLANE_INACTIVITY_TIMER_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_user_plane_inactivity_timer_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_aggregated_urrs =
{
    OGS_TLV_VAR_STR,
    "Aggregated URRs",
    OGS_PFCP_AGGREGATED_URRS_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_aggregated_urrs_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_multiplier =
{
    OGS_TLV_VAR_STR,
    "Multiplier",
    OGS_PFCP_MULTIPLIER_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_multiplier_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_aggregated_urr_id =
{
    OGS_TLV_VAR_STR,
    "Aggregated URR ID",
    OGS_PFCP_AGGREGATED_URR_ID_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_aggregated_urr_id_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_subsequent_volume_quota =
{
    OGS_TLV_VAR_STR,
    "Subsequent Volume Quota",
    OGS_PFCP_SUBSEQUENT_VOLUME_QUOTA_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_subsequent_volume_quota_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_subsequent_time_quota =
{
    OGS_TLV_VAR_STR,
    "Subsequent Time Quota",
    OGS_PFCP_SUBSEQUENT_TIME_QUOTA_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_subsequent_time_quota_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_rqi =
{
    OGS_TLV_UINT8,
    "RQI",
    OGS_PFCP_RQI_TYPE,
    1,
    0,
    sizeof(ogs_pfcp_tlv_rqi_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_qfi =
{
    OGS_TLV_UINT8,
    "QFI",
    OGS_PFCP_QFI_TYPE,
    1,
    0,
    sizeof(ogs_pfcp_tlv_qfi_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_query_urr_reference =
{
    OGS_TLV_VAR_STR,
    "Query URR Reference",
    OGS_PFCP_QUERY_URR_REFERENCE_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_query_urr_reference_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_additional_usage_reports_information =
{
    OGS_TLV_VAR_STR,
    "Additional Usage Reports Information",
    OGS_PFCP_ADDITIONAL_USAGE_REPORTS_INFORMATION_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_additional_usage_reports_information_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_update_traffic_endpoint =
{
    OGS_TLV_VAR_STR,
    "Update Traffic Endpoint",
    OGS_PFCP_UPDATE_TRAFFIC_ENDPOINT_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_update_traffic_endpoint_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_traffic_endpoint_id =
{
    OGS_TLV_VAR_STR,
    "Traffic Endpoint ID",
    OGS_PFCP_TRAFFIC_ENDPOINT_ID_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_traffic_endpoint_id_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_mac_address =
{
    OGS_TLV_VAR_STR,
    "MAC address",
    OGS_PFCP_MAC_ADDRESS_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_mac_address_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_c_tag =
{
    OGS_TLV_VAR_STR,
    "C-TAG",
    OGS_PFCP_C_TAG_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_c_tag_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_s_tag =
{
    OGS_TLV_VAR_STR,
    "S-TAG",
    OGS_PFCP_S_TAG_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_s_tag_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_ethertype =
{
    OGS_TLV_VAR_STR,
    "Ethertype",
    OGS_PFCP_ETHERTYPE_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_ethertype_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_proxying =
{
    OGS_TLV_VAR_STR,
    "Proxying",
    OGS_PFCP_PROXYING_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_proxying_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_ethernet_filter_id =
{
    OGS_TLV_VAR_STR,
    "Ethernet Filter ID",
    OGS_PFCP_ETHERNET_FILTER_ID_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_ethernet_filter_id_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_ethernet_filter_properties =
{
    OGS_TLV_VAR_STR,
    "Ethernet Filter Properties",
    OGS_PFCP_ETHERNET_FILTER_PROPERTIES_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_ethernet_filter_properties_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_suggested_buffering_packets_count =
{
    OGS_TLV_VAR_STR,
    "Suggested Buffering Packets Count",
    OGS_PFCP_SUGGESTED_BUFFERING_PACKETS_COUNT_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_suggested_buffering_packets_count_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_user_id =
{
    OGS_TLV_VAR_STR,
    "User ID",
    OGS_PFCP_USER_ID_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_user_id_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_ethernet_pdu_session_information =
{
    OGS_TLV_VAR_STR,
    "Ethernet PDU Session Information",
    OGS_PFCP_ETHERNET_PDU_SESSION_INFORMATION_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_ethernet_pdu_session_information_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_mac_addresses_detected =
{
    OGS_TLV_VAR_STR,
    "MAC Addresses Detected",
    OGS_PFCP_MAC_ADDRESSES_DETECTED_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_mac_addresses_detected_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_mac_addresses_removed =
{
    OGS_TLV_VAR_STR,
    "MAC Addresses Removed",
    OGS_PFCP_MAC_ADDRESSES_REMOVED_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_mac_addresses_removed_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_ethernet_inactivity_timer =
{
    OGS_TLV_VAR_STR,
    "Ethernet Inactivity Timer",
    OGS_PFCP_ETHERNET_INACTIVITY_TIMER_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_ethernet_inactivity_timer_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_additional_monitoring_time =
{
    OGS_TLV_VAR_STR,
    "Additional Monitoring Time",
    OGS_PFCP_ADDITIONAL_MONITORING_TIME_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_additional_monitoring_time_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_event_quota =
{
    OGS_TLV_UINT32,
    "Event Quota",
    OGS_PFCP_EVENT_QUOTA_TYPE,
    4,
    0,
    sizeof(ogs_pfcp_tlv_event_quota_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_event_threshold =
{
    OGS_TLV_UINT32,
    "Event Threshold",
    OGS_PFCP_EVENT_THRESHOLD_TYPE,
    4,
    0,
    sizeof(ogs_pfcp_tlv_event_threshold_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_subsequent_event_quota =
{
    OGS_TLV_VAR_STR,
    "Subsequent Event Quota",
    OGS_PFCP_SUBSEQUENT_EVENT_QUOTA_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_subsequent_event_quota_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_subsequent_event_threshold =
{
    OGS_TLV_VAR_STR,
    "Subsequent Event Threshold",
    OGS_PFCP_SUBSEQUENT_EVENT_THRESHOLD_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_subsequent_event_threshold_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_trace_information =
{
    OGS_TLV_VAR_STR,
    "Trace Information",
    OGS_PFCP_TRACE_INFORMATION_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_trace_information_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_framed_route =
{
    OGS_TLV_VAR_STR,
    "Framed-Route",
    OGS_PFCP_FRAMED_ROUTE_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_framed_route_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_framed_routing =
{
    OGS_TLV_VAR_STR,
    "Framed-Routing",
    OGS_PFCP_FRAMED_ROUTING_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_framed_routing_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_framed_ipv6_route =
{
    OGS_TLV_VAR_STR,
    "Framed-IPv6-Route",
    OGS_PFCP_FRAMED_IPV6_ROUTE_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_framed_ipv6_route_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_time_stamp =
{
    OGS_TLV_VAR_STR,
    "Time Stamp",
    OGS_PFCP_TIME_STAMP_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_time_stamp_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_averaging_window =
{
    OGS_TLV_UINT32,
    "Averaging Window",
    OGS_PFCP_AVERAGING_WINDOW_TYPE,
    4,
    0,
    sizeof(ogs_pfcp_tlv_averaging_window_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_paging_policy_indicator =
{
    OGS_TLV_UINT8,
    "Paging Policy Indicator",
    OGS_PFCP_PAGING_POLICY_INDICATOR_TYPE,
    1,
    0,
    sizeof(ogs_pfcp_tlv_paging_policy_indicator_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_apn_dnn =
{
    OGS_TLV_VAR_STR,
    "APN/DNN",
    OGS_PFCP_APN_DNN_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_apn_dnn_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc__interface_type =
{
    OGS_TLV_UINT8,
    "3GPP Interface Type",
    OGS_PFCP__INTERFACE_TYPE_TYPE,
    1,
    0,
    sizeof(ogs_pfcp_tlv__interface_type_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_pfcpsrreq_flags =
{
    OGS_TLV_UINT8,
    "PFCPSRReq-Flags",
    OGS_PFCP_PFCPSRREQ_FLAGS_TYPE,
    1,
    0,
    sizeof(ogs_pfcp_tlv_pfcpsrreq_flags_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_pfcpaureq_flags =
{
    OGS_TLV_UINT8,
    "PFCPAUReq-Flags",
    OGS_PFCP_PFCPAUREQ_FLAGS_TYPE,
    1,
    0,
    sizeof(ogs_pfcp_tlv_pfcpaureq_flags_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_activation_time =
{
    OGS_TLV_VAR_STR,
    "Activation Time",
    OGS_PFCP_ACTIVATION_TIME_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_activation_time_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_deactivation_time =
{
    OGS_TLV_VAR_STR,
    "Deactivation Time",
    OGS_PFCP_DEACTIVATION_TIME_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_deactivation_time_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_mar_id =
{
    OGS_TLV_VAR_STR,
    "MAR ID",
    OGS_PFCP_MAR_ID_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_mar_id_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_steering_functionality =
{
    OGS_TLV_VAR_STR,
    "Steering Functionality",
    OGS_PFCP_STEERING_FUNCTIONALITY_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_steering_functionality_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_steering_mode =
{
    OGS_TLV_VAR_STR,
    "Steering Mode",
    OGS_PFCP_STEERING_MODE_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_steering_mode_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_weight =
{
    OGS_TLV_VAR_STR,
    "Weight",
    OGS_PFCP_WEIGHT_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_weight_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_priority =
{
    OGS_TLV_VAR_STR,
    "Priority",
    OGS_PFCP_PRIORITY_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_priority_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_ue_ip_address_pool_identity =
{
    OGS_TLV_VAR_STR,
    "UE IP address Pool Identity",
    OGS_PFCP_UE_IP_ADDRESS_POOL_IDENTITY_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_ue_ip_address_pool_identity_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_alternative_smf_ip_address =
{
    OGS_TLV_VAR_STR,
    "Alternative SMF IP Address",
    OGS_PFCP_ALTERNATIVE_SMF_IP_ADDRESS_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_alternative_smf_ip_address_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_packet_replication_and_detection_carry_on_information =
{
    OGS_TLV_VAR_STR,
    "Packet Replication and Detection Carry-On Information",
    OGS_PFCP_PACKET_REPLICATION_AND_DETECTION_CARRY_ON_INFORMATION_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_packet_replication_and_detection_carry_on_information_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_smf_set_id =
{
    OGS_TLV_VAR_STR,
    "SMF Set ID",
    OGS_PFCP_SMF_SET_ID_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_smf_set_id_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_quota_validity_time =
{
    OGS_TLV_UINT32,
    "Quota Validity Time",
    OGS_PFCP_QUOTA_VALIDITY_TIME_TYPE,
    4,
    0,
    sizeof(ogs_pfcp_tlv_quota_validity_time_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_number_of_reports =
{
    OGS_TLV_VAR_STR,
    "Number of Reports",
    OGS_PFCP_NUMBER_OF_REPORTS_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_number_of_reports_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_pfcpasrsp_flags =
{
    OGS_TLV_VAR_STR,
    "PFCPASRsp-Flags",
    OGS_PFCP_PFCPASRSP_FLAGS_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_pfcpasrsp_flags_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_cp_pfcp_entity_ip_address =
{
    OGS_TLV_VAR_STR,
    "CP PFCP Entity IP Address",
    OGS_PFCP_CP_PFCP_ENTITY_IP_ADDRESS_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_cp_pfcp_entity_ip_address_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_pfcpsereq_flags =
{
    OGS_TLV_UINT8,
    "PFCPSEReq-Flags",
    OGS_PFCP_PFCPSEREQ_FLAGS_TYPE,
    1,
    0,
    sizeof(ogs_pfcp_tlv_pfcpsereq_flags_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_ip_multicast_address =
{
    OGS_TLV_VAR_STR,
    "IP Multicast Address",
    OGS_PFCP_IP_MULTICAST_ADDRESS_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_ip_multicast_address_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_source_ip_address =
{
    OGS_TLV_VAR_STR,
    "Source IP Address",
    OGS_PFCP_SOURCE_IP_ADDRESS_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_source_ip_address_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_packet_rate_status =
{
    OGS_TLV_VAR_STR,
    "Packet Rate Status",
    OGS_PFCP_PACKET_RATE_STATUS_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_packet_rate_status_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_create_bridge_info_for_tsc =
{
    OGS_TLV_VAR_STR,
    "Create Bridge Info for TSC",
    OGS_PFCP_CREATE_BRIDGE_INFO_FOR_TSC_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_create_bridge_info_for_tsc_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_ds_tt_port_number =
{
    OGS_TLV_VAR_STR,
    "DS-TT Port Number",
    OGS_PFCP_DS_TT_PORT_NUMBER_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_ds_tt_port_number_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_nw_tt_port_number =
{
    OGS_TLV_VAR_STR,
    "NW-TT Port Number",
    OGS_PFCP_NW_TT_PORT_NUMBER_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_nw_tt_port_number_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_fivegs_user_plane_node =
{
    OGS_TLV_VAR_STR,
    "5GS User Plane Node",
    OGS_PFCP_FiveGS_USER_PLANE_NODE_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_fivegs_user_plane_node_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_port_management_information_container =
{
    OGS_TLV_VAR_STR,
    "Port Management Information Container",
    OGS_PFCP_PORT_MANAGEMENT_INFORMATION_CONTAINER_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_port_management_information_container_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_requested_clock_drift_information =
{
    OGS_TLV_VAR_STR,
    "Requested Clock Drift Information",
    OGS_PFCP_REQUESTED_CLOCK_DRIFT_INFORMATION_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_requested_clock_drift_information_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_time_domain_number =
{
    OGS_TLV_VAR_STR,
    "Time Domain Number",
    OGS_PFCP_TIME_DOMAIN_NUMBER_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_time_domain_number_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_time_offset_threshold =
{
    OGS_TLV_VAR_STR,
    "Time Offset Threshold",
    OGS_PFCP_TIME_OFFSET_THRESHOLD_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_time_offset_threshold_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_cumulative_rateratio_threshold =
{
    OGS_TLV_VAR_STR,
    "Cumulative rateRatio Threshold",
    OGS_PFCP_CUMULATIVE_RATERATIO_THRESHOLD_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_cumulative_rateratio_threshold_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_time_offset_measurement =
{
    OGS_TLV_VAR_STR,
    "Time Offset Measurement",
    OGS_PFCP_TIME_OFFSET_MEASUREMENT_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_time_offset_measurement_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_cumulative_rateratio_measurement =
{
    OGS_TLV_VAR_STR,
    "Cumulative rateRatio Measurement",
    OGS_PFCP_CUMULATIVE_RATERATIO_MEASUREMENT_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_cumulative_rateratio_measurement_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_srr_id =
{
    OGS_TLV_VAR_STR,
    "SRR ID",
    OGS_PFCP_SRR_ID_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_srr_id_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_access_availability_control_information =
{
    OGS_TLV_VAR_STR,
    "Access Availability Control Information",
    OGS_PFCP_ACCESS_AVAILABILITY_CONTROL_INFORMATION_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_access_availability_control_information_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_requested_access_availability_information =
{
    OGS_TLV_VAR_STR,
    "Requested Access Availability Information",
    OGS_PFCP_REQUESTED_ACCESS_AVAILABILITY_INFORMATION_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_requested_access_availability_information_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_access_availability_information =
{
    OGS_TLV_VAR_STR,
    "Access Availability Information",
    OGS_PFCP_ACCESS_AVAILABILITY_INFORMATION_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_access_availability_information_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_mptcp_control_information =
{
    OGS_TLV_VAR_STR,
    "MPTCP Control Information",
    OGS_PFCP_MPTCP_CONTROL_INFORMATION_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_mptcp_control_information_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_atsss_ll_control_information =
{
    OGS_TLV_VAR_STR,
    "ATSSS-LL Control Information",
    OGS_PFCP_ATSSS_LL_CONTROL_INFORMATION_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_atsss_ll_control_information_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_pmf_control_information =
{
    OGS_TLV_VAR_STR,
    "PMF Control Information",
    OGS_PFCP_PMF_CONTROL_INFORMATION_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_pmf_control_information_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_mptcp_address_information =
{
    OGS_TLV_VAR_STR,
    "MPTCP Address Information",
    OGS_PFCP_MPTCP_ADDRESS_INFORMATION_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_mptcp_address_information_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_ue_link_specific_ip_address =
{
    OGS_TLV_VAR_STR,
    "UE Link-Specific IP Address",
    OGS_PFCP_UE_LINK_SPECIFIC_IP_ADDRESS_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_ue_link_specific_ip_address_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_pmf_address_information =
{
    OGS_TLV_VAR_STR,
    "PMF Address Information",
    OGS_PFCP_PMF_ADDRESS_INFORMATION_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_pmf_address_information_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_atsss_ll_information =
{
    OGS_TLV_VAR_STR,
    "ATSSS-LL Information",
    OGS_PFCP_ATSSS_LL_INFORMATION_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_atsss_ll_information_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_data_network_access_identifier =
{
    OGS_TLV_VAR_STR,
    "Data Network Access Identifier",
    OGS_PFCP_DATA_NETWORK_ACCESS_IDENTIFIER_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_data_network_access_identifier_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_average_packet_delay =
{
    OGS_TLV_VAR_STR,
    "Average Packet Delay",
    OGS_PFCP_AVERAGE_PACKET_DELAY_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_average_packet_delay_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_minimum_packet_delay =
{
    OGS_TLV_VAR_STR,
    "Minimum Packet Delay",
    OGS_PFCP_MINIMUM_PACKET_DELAY_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_minimum_packet_delay_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_maximum_packet_delay =
{
    OGS_TLV_VAR_STR,
    "Maximum Packet Delay",
    OGS_PFCP_MAXIMUM_PACKET_DELAY_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_maximum_packet_delay_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_qos_report_trigger =
{
    OGS_TLV_VAR_STR,
    "QoS Report Trigger",
    OGS_PFCP_QOS_REPORT_TRIGGER_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_qos_report_trigger_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_gtp_u_path_qos_control_information =
{
    OGS_TLV_VAR_STR,
    "GTP-U Path QoS Control Information",
    OGS_PFCP_GTP_U_PATH_QOS_CONTROL_INFORMATION_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_gtp_u_path_qos_control_information_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_gtp_u_path_interface_type =
{
    OGS_TLV_VAR_STR,
    "GTP-U Path Interface Type",
    OGS_PFCP_GTP_U_PATH_INTERFACE_TYPE_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_gtp_u_path_interface_type_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_qos_monitoring_per_qos_flow_control_information =
{
    OGS_TLV_VAR_STR,
    "QoS Monitoring per QoS flow Control Information",
    OGS_PFCP_QOS_MONITORING_PER_QOS_FLOW_CONTROL_INFORMATION_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_qos_monitoring_per_qos_flow_control_information_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_requested_qos_monitoring =
{
    OGS_TLV_VAR_STR,
    "Requested QoS Monitoring",
    OGS_PFCP_REQUESTED_QOS_MONITORING_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_requested_qos_monitoring_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_reporting_frequency =
{
    OGS_TLV_VAR_STR,
    "Reporting Frequency",
    OGS_PFCP_REPORTING_FREQUENCY_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_reporting_frequency_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_packet_delay_thresholds =
{
    OGS_TLV_VAR_STR,
    "Packet Delay Thresholds",
    OGS_PFCP_PACKET_DELAY_THRESHOLDS_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_packet_delay_thresholds_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_minimum_wait_time =
{
    OGS_TLV_VAR_STR,
    "Minimum Wait Time",
    OGS_PFCP_MINIMUM_WAIT_TIME_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_minimum_wait_time_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_qos_monitoring_measurement =
{
    OGS_TLV_VAR_STR,
    "QoS Monitoring Measurement",
    OGS_PFCP_QOS_MONITORING_MEASUREMENT_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_qos_monitoring_measurement_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_mt_edt_control_information =
{
    OGS_TLV_VAR_STR,
    "MT-EDT Control Information",
    OGS_PFCP_MT_EDT_CONTROL_INFORMATION_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_mt_edt_control_information_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_dl_data_packets_size =
{
    OGS_TLV_VAR_STR,
    "DL Data Packets Size",
    OGS_PFCP_DL_DATA_PACKETS_SIZE_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_dl_data_packets_size_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_qer_control_indications =
{
    OGS_TLV_VAR_STR,
    "QER Control Indications",
    OGS_PFCP_QER_CONTROL_INDICATIONS_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_qer_control_indications_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_nf_instance_id =
{
    OGS_TLV_VAR_STR,
    "NF Instance ID",
    OGS_PFCP_NF_INSTANCE_ID_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_nf_instance_id_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_s_nssai =
{
    OGS_TLV_VAR_STR,
    "S-NSSAI",
    OGS_PFCP_S_NSSAI_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_s_nssai_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_ip_version =
{
    OGS_TLV_VAR_STR,
    "IP version",
    OGS_PFCP_IP_VERSION_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_ip_version_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_pfcpasreq_flags =
{
    OGS_TLV_VAR_STR,
    "PFCPASReq-Flags",
    OGS_PFCP_PFCPASREQ_FLAGS_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_pfcpasreq_flags_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_data_status =
{
    OGS_TLV_UINT8,
    "Data Status",
    OGS_PFCP_DATA_STATUS_TYPE,
    1,
    0,
    sizeof(ogs_pfcp_tlv_data_status_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_rds_configuration_information =
{
    OGS_TLV_VAR_STR,
    "RDS Configuration Information",
    OGS_PFCP_RDS_CONFIGURATION_INFORMATION_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_rds_configuration_information_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_mptcp_applicable_indication =
{
    OGS_TLV_VAR_STR,
    "MPTCP Applicable Indication",
    OGS_PFCP_MPTCP_APPLICABLE_INDICATION_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_mptcp_applicable_indication_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_bridge_management_information_container =
{
    OGS_TLV_VAR_STR,
    "Bridge Management Information Container",
    OGS_PFCP_BRIDGE_MANAGEMENT_INFORMATION_CONTAINER_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_bridge_management_information_container_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_number_of_ue_ip_addresses =
{
    OGS_TLV_VAR_STR,
    "Number of UE IP Addresses",
    OGS_PFCP_NUMBER_OF_UE_IP_ADDRESSES_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_number_of_ue_ip_addresses_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_validity_timer =
{
    OGS_TLV_VAR_STR,
    "Validity Timer",
    OGS_PFCP_VALIDITY_TIMER_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_validity_timer_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_spare =
{
    OGS_TLV_VAR_STR,
    "Spare",
    OGS_PFCP_SPARE_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_spare_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_offending_ie_information =
{
    OGS_TLV_VAR_STR,
    "Offending IE Information",
    OGS_PFCP_OFFENDING_IE_INFORMATION_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_offending_ie_information_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_rat_type =
{
    OGS_TLV_VAR_STR,
    "RAT Type",
    OGS_PFCP_RAT_TYPE_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_rat_type_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_l2tp_user_authentication_ie =
{
    OGS_TLV_VAR_STR,
    "L2TP User Authentication IE",
    OGS_PFCP_L2TP_USER_AUTHENTICATION_IE_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_l2tp_user_authentication_ie_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_lns_address =
{
    OGS_TLV_VAR_STR,
    "LNS Address",
    OGS_PFCP_LNS_ADDRESS_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_lns_address_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_tunnel_preference =
{
    OGS_TLV_VAR_STR,
    "Tunnel Preference",
    OGS_PFCP_TUNNEL_PREFERENCE_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_tunnel_preference_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_calling_number =
{
    OGS_TLV_VAR_STR,
    "Calling Number",
    OGS_PFCP_CALLING_NUMBER_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_calling_number_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_called_number =
{
    OGS_TLV_VAR_STR,
    "Called Number",
    OGS_PFCP_CALLED_NUMBER_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_called_number_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_l2tp_session_indications =
{
    OGS_TLV_VAR_STR,
    "L2TP Session Indications",
    OGS_PFCP_L2TP_SESSION_INDICATIONS_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_l2tp_session_indications_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_dns_server_address =
{
    OGS_TLV_VAR_STR,
    "DNS Server Address",
    OGS_PFCP_DNS_SERVER_ADDRESS_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_dns_server_address_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_nbns_server_address =
{
    OGS_TLV_VAR_STR,
    "NBNS Server Address",
    OGS_PFCP_NBNS_SERVER_ADDRESS_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_nbns_server_address_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_maximum_receive_unit =
{
    OGS_TLV_VAR_STR,
    "Maximum Receive Unit",
    OGS_PFCP_MAXIMUM_RECEIVE_UNIT_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_maximum_receive_unit_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_thresholds =
{
    OGS_TLV_VAR_STR,
    "Thresholds",
    OGS_PFCP_THRESHOLDS_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_thresholds_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_steering_mode_indicator =
{
    OGS_TLV_VAR_STR,
    "Steering Mode Indicator",
    OGS_PFCP_STEERING_MODE_INDICATOR_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_steering_mode_indicator_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_group_id =
{
    OGS_TLV_VAR_STR,
    "Group ID",
    OGS_PFCP_GROUP_ID_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_group_id_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_cp_ip_address =
{
    OGS_TLV_VAR_STR,
    "CP IP Address",
    OGS_PFCP_CP_IP_ADDRESS_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_cp_ip_address_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_ip_address_and_port_number_replacement =
{
    OGS_TLV_VAR_STR,
    "IP Address and Port number Replacement",
    OGS_PFCP_IP_ADDRESS_AND_PORT_NUMBER_REPLACEMENT_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_ip_address_and_port_number_replacement_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_dns_query_filter =
{
    OGS_TLV_VAR_STR,
    "DNS Query Filter",
    OGS_PFCP_DNS_QUERY_FILTER_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_dns_query_filter_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_direct_reporting_information =
{
    OGS_TLV_VAR_STR,
    "Direct Reporting Information",
    OGS_PFCP_DIRECT_REPORTING_INFORMATION_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_direct_reporting_information_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_event_notification_uri =
{
    OGS_TLV_VAR_STR,
    "Event Notification URI",
    OGS_PFCP_EVENT_NOTIFICATION_URI_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_event_notification_uri_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_notification_correlation_id =
{
    OGS_TLV_VAR_STR,
    "Notification Correlation ID",
    OGS_PFCP_NOTIFICATION_CORRELATION_ID_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_notification_correlation_id_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_reporting_flags =
{
    OGS_TLV_VAR_STR,
    "Reporting Flags",
    OGS_PFCP_REPORTING_FLAGS_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_reporting_flags_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_predefined_rules_name =
{
    OGS_TLV_VAR_STR,
    "Predefined Rules Name",
    OGS_PFCP_PREDEFINED_RULES_NAME_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_predefined_rules_name_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_remove_mbs_unicast_parameters =
{
    OGS_TLV_VAR_STR,
    "Remove MBS Unicast Parameters",
    OGS_PFCP_REMOVE_MBS_UNICAST_PARAMETERS_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_remove_mbs_unicast_parameters_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_mbs_session_identifier =
{
    OGS_TLV_VAR_STR,
    "MBS Session Identifier",
    OGS_PFCP_MBS_SESSION_IDENTIFIER_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_mbs_session_identifier_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_multicast_transport_information =
{
    OGS_TLV_VAR_STR,
    "Multicast Transport Information",
    OGS_PFCP_MULTICAST_TRANSPORT_INFORMATION_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_multicast_transport_information_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_mbsn4mbreq_flags =
{
    OGS_TLV_VAR_STR,
    "MBSN4mbReq-Flags",
    OGS_PFCP_MBSN4MBREQ_FLAGS_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_mbsn4mbreq_flags_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_local_ingress_tunnel =
{
    OGS_TLV_VAR_STR,
    "Local Ingress Tunnel",
    OGS_PFCP_LOCAL_INGRESS_TUNNEL_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_local_ingress_tunnel_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_mbs_unicast_parameters_id =
{
    OGS_TLV_VAR_STR,
    "MBS Unicast Parameters ID",
    OGS_PFCP_MBS_UNICAST_PARAMETERS_ID_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_mbs_unicast_parameters_id_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_mbsn4resp_flags =
{
    OGS_TLV_VAR_STR,
    "MBSN4Resp-Flags",
    OGS_PFCP_MBSN4RESP_FLAGS_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_mbsn4resp_flags_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_tunnel_password =
{
    OGS_TLV_VAR_STR,
    "Tunnel Password",
    OGS_PFCP_TUNNEL_PASSWORD_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_tunnel_password_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_area_session_id =
{
    OGS_TLV_VAR_STR,
    "Area Session ID",
    OGS_PFCP_AREA_SESSION_ID_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_area_session_id_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_peer_up_restart_report =
{
    OGS_TLV_VAR_STR,
    "Peer UP Restart Report",
    OGS_PFCP_PEER_UP_RESTART_REPORT_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_peer_up_restart_report_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_dscp_to_ppi_mapping_information =
{
    OGS_TLV_VAR_STR,
    "DSCP to PPI Mapping Information",
    OGS_PFCP_DSCP_TO_PPI_MAPPING_INFORMATION_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_dscp_to_ppi_mapping_information_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_pfcpsdrsp_flags =
{
    OGS_TLV_VAR_STR,
    "PFCPSDRsp-Flags",
    OGS_PFCP_PFCPSDRSP_FLAGS_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_pfcpsdrsp_flags_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_qer_indications =
{
    OGS_TLV_VAR_STR,
    "QER Indications",
    OGS_PFCP_QER_INDICATIONS_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_qer_indications_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_vendor_specific_node_report_type =
{
    OGS_TLV_VAR_STR,
    "Vendor-Specific Node Report Type",
    OGS_PFCP_VENDOR_SPECIFIC_NODE_REPORT_TYPE_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_vendor_specific_node_report_type_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_configured_time_domain =
{
    OGS_TLV_VAR_STR,
    "Configured Time Domain",
    OGS_PFCP_CONFIGURED_TIME_DOMAIN_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_configured_time_domain_t),
    { NULL }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_ethernet_packet_filter =
{
    OGS_TLV_COMPOUND,
    "Ethernet Packet Filter",
    OGS_PFCP_ETHERNET_PACKET_FILTER_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_ethernet_packet_filter_t),
    {
        &ogs_pfcp_tlv_desc_ethernet_filter_id,
        &ogs_pfcp_tlv_desc_ethernet_filter_properties,
        &ogs_pfcp_tlv_desc_mac_address,
        &ogs_pfcp_tlv_desc_ethertype,
        &ogs_pfcp_tlv_desc_c_tag,
        &ogs_pfcp_tlv_desc_s_tag,
        &ogs_pfcp_tlv_desc_sdf_filter,
        &ogs_tlv_desc_more8,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_redundant_transmission_parameters =
{
    OGS_TLV_COMPOUND,
    "Redundant Transmission Parameters",
    OGS_PFCP_REDUNDANT_TRANSMISSION_PARAMETERS_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_redundant_transmission_parameters_t),
    {
        &ogs_pfcp_tlv_desc_f_teid,
        &ogs_pfcp_tlv_desc_network_instance,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_ip_multicast_addressing_info_within_pfcp_session_establishment_request =
{
    OGS_TLV_COMPOUND,
    "IP Multicast Addressing Info within PFCP Session Establishment Request",
    OGS_PFCP_IP_MULTICAST_ADDRESSING_INFO_WITHIN_PFCP_SESSION_ESTABLISHMENT_REQUEST_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_ip_multicast_addressing_info_within_pfcp_session_establishment_request_t),
    {
        &ogs_pfcp_tlv_desc_ip_multicast_address,
        &ogs_pfcp_tlv_desc_source_ip_address,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_pdi =
{
    OGS_TLV_COMPOUND,
    "PDI",
    OGS_PFCP_PDI_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_pdi_t),
    {
        &ogs_pfcp_tlv_desc_source_interface,
        &ogs_pfcp_tlv_desc_f_teid,
        &ogs_pfcp_tlv_desc_local_ingress_tunnel,
        &ogs_pfcp_tlv_desc_network_instance,
        &ogs_pfcp_tlv_desc_redundant_transmission_parameters,
        &ogs_pfcp_tlv_desc_ue_ip_address,
        &ogs_pfcp_tlv_desc_traffic_endpoint_id,
        &ogs_pfcp_tlv_desc_sdf_filter,
        &ogs_tlv_desc_more8,
        &ogs_pfcp_tlv_desc_application_id,
        &ogs_pfcp_tlv_desc_ethernet_pdu_session_information,
        &ogs_pfcp_tlv_desc_ethernet_packet_filter,
        &ogs_pfcp_tlv_desc_qfi,
        &ogs_pfcp_tlv_desc_framed_route,
        &ogs_tlv_desc_more8,
        &ogs_pfcp_tlv_desc_framed_routing,
        &ogs_pfcp_tlv_desc_framed_ipv6_route,
        &ogs_tlv_desc_more8,
        &ogs_pfcp_tlv_desc__interface_type,
        &ogs_pfcp_tlv_desc_ip_multicast_addressing_info_within_pfcp_session_establishment_request,
        &ogs_pfcp_tlv_desc_dns_query_filter,
        &ogs_pfcp_tlv_desc_mbs_session_identifier,
        &ogs_pfcp_tlv_desc_area_session_id,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_transport_delay_reporting =
{
    OGS_TLV_COMPOUND,
    "Transport Delay Reporting",
    OGS_PFCP_TRANSPORT_DELAY_REPORTING_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_transport_delay_reporting_t),
    {
        &ogs_pfcp_tlv_desc_remote_gtp_u_peer,
        &ogs_pfcp_tlv_desc_transport_level_marking,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_create_pdr =
{
    OGS_TLV_COMPOUND,
    "Create PDR",
    OGS_PFCP_CREATE_PDR_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_create_pdr_t),
    {
        &ogs_pfcp_tlv_desc_pdr_id,
        &ogs_pfcp_tlv_desc_precedence,
        &ogs_pfcp_tlv_desc_pdi,
        &ogs_pfcp_tlv_desc_outer_header_removal,
        &ogs_pfcp_tlv_desc_far_id,
        &ogs_pfcp_tlv_desc_urr_id,
        &ogs_tlv_desc_more8,
        &ogs_pfcp_tlv_desc_qer_id,
        &ogs_pfcp_tlv_desc_activate_predefined_rules,
        &ogs_pfcp_tlv_desc_activation_time,
        &ogs_pfcp_tlv_desc_deactivation_time,
        &ogs_pfcp_tlv_desc_mar_id,
        &ogs_pfcp_tlv_desc_packet_replication_and_detection_carry_on_information,
        &ogs_pfcp_tlv_desc_ip_multicast_addressing_info_within_pfcp_session_establishment_request,
        &ogs_pfcp_tlv_desc_ue_ip_address,
        &ogs_pfcp_tlv_desc_mptcp_applicable_indication,
        &ogs_pfcp_tlv_desc_transport_delay_reporting,
        &ogs_pfcp_tlv_desc_rat_type,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_forwarding_parameters =
{
    OGS_TLV_COMPOUND,
    "Forwarding Parameters",
    OGS_PFCP_FORWARDING_PARAMETERS_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_forwarding_parameters_t),
    {
        &ogs_pfcp_tlv_desc_destination_interface,
        &ogs_pfcp_tlv_desc_network_instance,
        &ogs_pfcp_tlv_desc_redirect_information,
        &ogs_pfcp_tlv_desc_outer_header_creation,
        &ogs_pfcp_tlv_desc_transport_level_marking,
        &ogs_pfcp_tlv_desc_forwarding_policy,
        &ogs_pfcp_tlv_desc_header_enrichment,
        &ogs_pfcp_tlv_desc_traffic_endpoint_id,
        &ogs_pfcp_tlv_desc_proxying,
        &ogs_pfcp_tlv_desc__interface_type,
        &ogs_pfcp_tlv_desc_data_network_access_identifier,
        &ogs_pfcp_tlv_desc_ip_address_and_port_number_replacement,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_duplicating_parameters =
{
    OGS_TLV_COMPOUND,
    "Duplicating Parameters",
    OGS_PFCP_DUPLICATING_PARAMETERS_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_duplicating_parameters_t),
    {
        &ogs_pfcp_tlv_desc_destination_interface,
        &ogs_pfcp_tlv_desc_outer_header_creation,
        &ogs_pfcp_tlv_desc_transport_level_marking,
        &ogs_pfcp_tlv_desc_forwarding_policy,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_redundant_transmission_forwarding_parameters =
{
    OGS_TLV_COMPOUND,
    "Redundant Transmission Forwarding Parameters",
    OGS_PFCP_REDUNDANT_TRANSMISSION_FORWARDING_PARAMETERS_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_redundant_transmission_forwarding_parameters_t),
    {
        &ogs_pfcp_tlv_desc_outer_header_creation,
        &ogs_pfcp_tlv_desc_network_instance,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_mbs_multicast_parameters =
{
    OGS_TLV_COMPOUND,
    "MBS Multicast Parameters",
    OGS_PFCP_MBS_MULTICAST_PARAMETERS_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_mbs_multicast_parameters_t),
    {
        &ogs_pfcp_tlv_desc_destination_interface,
        &ogs_pfcp_tlv_desc_network_instance,
        &ogs_pfcp_tlv_desc_outer_header_creation,
        &ogs_pfcp_tlv_desc_transport_level_marking,
        &ogs_pfcp_tlv_desc__interface_type,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_add_mbs_unicast_parameters =
{
    OGS_TLV_COMPOUND,
    "Add MBS Unicast Parameters",
    OGS_PFCP_ADD_MBS_UNICAST_PARAMETERS_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_add_mbs_unicast_parameters_t),
    {
        &ogs_pfcp_tlv_desc_destination_interface,
        &ogs_pfcp_tlv_desc_mbs_unicast_parameters_id,
        &ogs_pfcp_tlv_desc_network_instance,
        &ogs_pfcp_tlv_desc_outer_header_creation,
        &ogs_pfcp_tlv_desc_transport_level_marking,
        &ogs_pfcp_tlv_desc__interface_type,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_create_far =
{
    OGS_TLV_COMPOUND,
    "Create FAR",
    OGS_PFCP_CREATE_FAR_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_create_far_t),
    {
        &ogs_pfcp_tlv_desc_far_id,
        &ogs_pfcp_tlv_desc_apply_action,
        &ogs_pfcp_tlv_desc_forwarding_parameters,
        &ogs_pfcp_tlv_desc_duplicating_parameters,
        &ogs_pfcp_tlv_desc_bar_id,
        &ogs_pfcp_tlv_desc_redundant_transmission_forwarding_parameters,
        &ogs_pfcp_tlv_desc_mbs_multicast_parameters,
        &ogs_pfcp_tlv_desc_add_mbs_unicast_parameters,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_update_forwarding_parameters =
{
    OGS_TLV_COMPOUND,
    "Update Forwarding Parameters",
    OGS_PFCP_UPDATE_FORWARDING_PARAMETERS_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_update_forwarding_parameters_t),
    {
        &ogs_pfcp_tlv_desc_destination_interface,
        &ogs_pfcp_tlv_desc_network_instance,
        &ogs_pfcp_tlv_desc_redirect_information,
        &ogs_pfcp_tlv_desc_outer_header_creation,
        &ogs_pfcp_tlv_desc_transport_level_marking,
        &ogs_pfcp_tlv_desc_forwarding_policy,
        &ogs_pfcp_tlv_desc_header_enrichment,
        &ogs_pfcp_tlv_desc_pfcpsmreq_flags,
        &ogs_pfcp_tlv_desc_traffic_endpoint_id,
        &ogs_pfcp_tlv_desc__interface_type,
        &ogs_pfcp_tlv_desc_data_network_access_identifier,
        &ogs_pfcp_tlv_desc_ip_address_and_port_number_replacement,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_update_duplicating_parameters =
{
    OGS_TLV_COMPOUND,
    "Update Duplicating Parameters",
    OGS_PFCP_UPDATE_DUPLICATING_PARAMETERS_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_update_duplicating_parameters_t),
    {
        &ogs_pfcp_tlv_desc_destination_interface,
        &ogs_pfcp_tlv_desc_outer_header_creation,
        &ogs_pfcp_tlv_desc_transport_level_marking,
        &ogs_pfcp_tlv_desc_forwarding_policy,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_update_far =
{
    OGS_TLV_COMPOUND,
    "Update FAR",
    OGS_PFCP_UPDATE_FAR_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_update_far_t),
    {
        &ogs_pfcp_tlv_desc_far_id,
        &ogs_pfcp_tlv_desc_apply_action,
        &ogs_pfcp_tlv_desc_update_forwarding_parameters,
        &ogs_pfcp_tlv_desc_update_duplicating_parameters,
        &ogs_pfcp_tlv_desc_redundant_transmission_forwarding_parameters,
        &ogs_pfcp_tlv_desc_bar_id,
        &ogs_pfcp_tlv_desc_add_mbs_unicast_parameters,
        &ogs_pfcp_tlv_desc_remove_mbs_unicast_parameters,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_pfd_context =
{
    OGS_TLV_COMPOUND,
    "PFD context",
    OGS_PFCP_PFD_CONTEXT_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_pfd_context_t),
    {
        &ogs_pfcp_tlv_desc_pfd_contents,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_application_id_s_pfds =
{
    OGS_TLV_COMPOUND,
    "Application ID's PFDs",
    OGS_PFCP_APPLICATION_ID_S_PFDS_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_application_id_s_pfds_t),
    {
        &ogs_pfcp_tlv_desc_application_id,
        &ogs_pfcp_tlv_desc_pfd_context,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_ethernet_traffic_information =
{
    OGS_TLV_COMPOUND,
    "Ethernet Traffic Information",
    OGS_PFCP_ETHERNET_TRAFFIC_INFORMATION_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_ethernet_traffic_information_t),
    {
        &ogs_pfcp_tlv_desc_mac_addresses_detected,
        &ogs_pfcp_tlv_desc_mac_addresses_removed,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc__access_forwarding_action_information =
{
    OGS_TLV_COMPOUND,
    "3GPP Access Forwarding Action Information",
    OGS_PFCP__ACCESS_FORWARDING_ACTION_INFORMATION_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv__access_forwarding_action_information_t),
    {
        &ogs_pfcp_tlv_desc_far_id,
        &ogs_pfcp_tlv_desc_weight,
        &ogs_pfcp_tlv_desc_priority,
        &ogs_pfcp_tlv_desc_urr_id,
        &ogs_tlv_desc_more8,
        &ogs_pfcp_tlv_desc_rat_type,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_non__access_forwarding_action_information =
{
    OGS_TLV_COMPOUND,
    "Non-3GPP Access Forwarding Action Information",
    OGS_PFCP_NON__ACCESS_FORWARDING_ACTION_INFORMATION_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_non__access_forwarding_action_information_t),
    {
        &ogs_pfcp_tlv_desc_far_id,
        &ogs_pfcp_tlv_desc_weight,
        &ogs_pfcp_tlv_desc_priority,
        &ogs_pfcp_tlv_desc_urr_id,
        &ogs_tlv_desc_more8,
        &ogs_pfcp_tlv_desc_rat_type,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_update__access_forwarding_action_information =
{
    OGS_TLV_COMPOUND,
    "Update 3GPP Access Forwarding Action Information",
    OGS_PFCP_UPDATE__ACCESS_FORWARDING_ACTION_INFORMATION_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_update__access_forwarding_action_information_t),
    {
        &ogs_pfcp_tlv_desc_far_id,
        &ogs_pfcp_tlv_desc_weight,
        &ogs_pfcp_tlv_desc_priority,
        &ogs_pfcp_tlv_desc_urr_id,
        &ogs_pfcp_tlv_desc_rat_type,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_update_non__access_forwarding_action_information =
{
    OGS_TLV_COMPOUND,
    "Update Non-3GPP Access Forwarding Action Information",
    OGS_PFCP_UPDATE_NON__ACCESS_FORWARDING_ACTION_INFORMATION_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_update_non__access_forwarding_action_information_t),
    {
        &ogs_pfcp_tlv_desc_far_id,
        &ogs_pfcp_tlv_desc_weight,
        &ogs_pfcp_tlv_desc_priority,
        &ogs_pfcp_tlv_desc_urr_id,
        &ogs_pfcp_tlv_desc_rat_type,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_access_availability_report =
{
    OGS_TLV_COMPOUND,
    "Access Availability Report",
    OGS_PFCP_ACCESS_AVAILABILITY_REPORT_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_access_availability_report_t),
    {
        &ogs_pfcp_tlv_desc_access_availability_information,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_qos_monitoring_report =
{
    OGS_TLV_COMPOUND,
    "QoS Monitoring Report",
    OGS_PFCP_QOS_MONITORING_REPORT_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_qos_monitoring_report_t),
    {
        &ogs_pfcp_tlv_desc_qfi,
        &ogs_pfcp_tlv_desc_qos_monitoring_measurement,
        &ogs_pfcp_tlv_desc_time_stamp,
        &ogs_pfcp_tlv_desc_start_time,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_mptcp_parameters =
{
    OGS_TLV_COMPOUND,
    "MPTCP Parameters",
    OGS_PFCP_MPTCP_PARAMETERS_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_mptcp_parameters_t),
    {
        &ogs_pfcp_tlv_desc_mptcp_address_information,
        &ogs_pfcp_tlv_desc_ue_link_specific_ip_address,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_atsss_ll_parameters =
{
    OGS_TLV_COMPOUND,
    "ATSSS-LL Parameters",
    OGS_PFCP_ATSSS_LL_PARAMETERS_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_atsss_ll_parameters_t),
    {
        &ogs_pfcp_tlv_desc_atsss_ll_information,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_pmf_parameters =
{
    OGS_TLV_COMPOUND,
    "PMF Parameters",
    OGS_PFCP_PMF_PARAMETERS_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_pmf_parameters_t),
    {
        &ogs_pfcp_tlv_desc_pmf_address_information,
        &ogs_pfcp_tlv_desc_qfi,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_join_ip_multicast_information_ie_within_usage_report =
{
    OGS_TLV_COMPOUND,
    "Join IP Multicast Information IE within Usage Report",
    OGS_PFCP_JOIN_IP_MULTICAST_INFORMATION_IE_WITHIN_USAGE_REPORT_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_join_ip_multicast_information_ie_within_usage_report_t),
    {
        &ogs_pfcp_tlv_desc_ip_multicast_address,
        &ogs_pfcp_tlv_desc_source_ip_address,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_leave_ip_multicast_information_ie_within_usage_report =
{
    OGS_TLV_COMPOUND,
    "Leave IP Multicast Information IE within Usage Report",
    OGS_PFCP_LEAVE_IP_MULTICAST_INFORMATION_IE_WITHIN_USAGE_REPORT_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_leave_ip_multicast_information_ie_within_usage_report_t),
    {
        &ogs_pfcp_tlv_desc_ip_multicast_address,
        &ogs_pfcp_tlv_desc_source_ip_address,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_create_urr =
{
    OGS_TLV_COMPOUND,
    "Create URR",
    OGS_PFCP_CREATE_URR_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_create_urr_t),
    {
        &ogs_pfcp_tlv_desc_urr_id,
        &ogs_pfcp_tlv_desc_measurement_method,
        &ogs_pfcp_tlv_desc_reporting_triggers,
        &ogs_pfcp_tlv_desc_measurement_period,
        &ogs_pfcp_tlv_desc_volume_threshold,
        &ogs_pfcp_tlv_desc_volume_quota,
        &ogs_pfcp_tlv_desc_event_threshold,
        &ogs_pfcp_tlv_desc_event_quota,
        &ogs_pfcp_tlv_desc_time_threshold,
        &ogs_pfcp_tlv_desc_time_quota,
        &ogs_pfcp_tlv_desc_quota_holding_time,
        &ogs_pfcp_tlv_desc_dropped_dl_traffic_threshold,
        &ogs_pfcp_tlv_desc_quota_validity_time,
        &ogs_pfcp_tlv_desc_monitoring_time,
        &ogs_pfcp_tlv_desc_subsequent_volume_threshold,
        &ogs_pfcp_tlv_desc_subsequent_time_threshold,
        &ogs_pfcp_tlv_desc_subsequent_volume_quota,
        &ogs_pfcp_tlv_desc_subsequent_time_quota,
        &ogs_pfcp_tlv_desc_subsequent_event_threshold,
        &ogs_pfcp_tlv_desc_subsequent_event_quota,
        &ogs_pfcp_tlv_desc_inactivity_detection_time,
        &ogs_pfcp_tlv_desc_linked_urr_id,
        &ogs_pfcp_tlv_desc_measurement_information,
        &ogs_pfcp_tlv_desc_time_quota_mechanism,
        &ogs_pfcp_tlv_desc_aggregated_urrs,
        &ogs_pfcp_tlv_desc_far_id,
        &ogs_pfcp_tlv_desc_ethernet_inactivity_timer,
        &ogs_pfcp_tlv_desc_additional_monitoring_time,
        &ogs_pfcp_tlv_desc_number_of_reports,
        &ogs_pfcp_tlv_desc_application_id,
        &ogs_pfcp_tlv_desc_sdf_filter,
        &ogs_tlv_desc_more8,
        &ogs_pfcp_tlv_desc_user_plane_inactivity_timer,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_create_qer =
{
    OGS_TLV_COMPOUND,
    "Create QER",
    OGS_PFCP_CREATE_QER_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_create_qer_t),
    {
        &ogs_pfcp_tlv_desc_qer_id,
        &ogs_pfcp_tlv_desc_qer_correlation_id,
        &ogs_pfcp_tlv_desc_gate_status,
        &ogs_pfcp_tlv_desc_mbr,
        &ogs_pfcp_tlv_desc_gbr,
        &ogs_pfcp_tlv_desc_packet_rate,
        &ogs_pfcp_tlv_desc_packet_rate_status,
        &ogs_pfcp_tlv_desc_dl_flow_level_marking,
        &ogs_pfcp_tlv_desc_qfi,
        &ogs_pfcp_tlv_desc_rqi,
        &ogs_pfcp_tlv_desc_paging_policy_indicator,
        &ogs_pfcp_tlv_desc_averaging_window,
        &ogs_pfcp_tlv_desc_qer_control_indications,
        &ogs_pfcp_tlv_desc_qer_indications,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_created_pdr =
{
    OGS_TLV_COMPOUND,
    "Created PDR",
    OGS_PFCP_CREATED_PDR_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_created_pdr_t),
    {
        &ogs_pfcp_tlv_desc_pdr_id,
        &ogs_pfcp_tlv_desc_f_teid,
        &ogs_pfcp_tlv_desc_f_teid,
        &ogs_pfcp_tlv_desc_ue_ip_address,
        &ogs_pfcp_tlv_desc_local_ingress_tunnel,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_update_pdr =
{
    OGS_TLV_COMPOUND,
    "Update PDR",
    OGS_PFCP_UPDATE_PDR_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_update_pdr_t),
    {
        &ogs_pfcp_tlv_desc_pdr_id,
        &ogs_pfcp_tlv_desc_outer_header_removal,
        &ogs_pfcp_tlv_desc_precedence,
        &ogs_pfcp_tlv_desc_pdi,
        &ogs_pfcp_tlv_desc_far_id,
        &ogs_pfcp_tlv_desc_urr_id,
        &ogs_pfcp_tlv_desc_qer_id,
        &ogs_pfcp_tlv_desc_activate_predefined_rules,
        &ogs_pfcp_tlv_desc_deactivate_predefined_rules,
        &ogs_pfcp_tlv_desc_activation_time,
        &ogs_pfcp_tlv_desc_deactivation_time,
        &ogs_pfcp_tlv_desc_ip_multicast_addressing_info_within_pfcp_session_establishment_request,
        &ogs_pfcp_tlv_desc_transport_delay_reporting,
        &ogs_pfcp_tlv_desc_rat_type,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_update_bar_pfcp_session_report_response =
{
    OGS_TLV_COMPOUND,
    "Update BAR PFCP Session Report Response",
    OGS_PFCP_UPDATE_BAR_PFCP_SESSION_REPORT_RESPONSE_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_update_bar_pfcp_session_report_response_t),
    {
        &ogs_pfcp_tlv_desc_bar_id,
        &ogs_pfcp_tlv_desc_downlink_data_notification_delay,
        &ogs_pfcp_tlv_desc_dl_buffering_duration,
        &ogs_pfcp_tlv_desc_dl_buffering_suggested_packet_count,
        &ogs_pfcp_tlv_desc_suggested_buffering_packets_count,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_update_urr =
{
    OGS_TLV_COMPOUND,
    "Update URR",
    OGS_PFCP_UPDATE_URR_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_update_urr_t),
    {
        &ogs_pfcp_tlv_desc_urr_id,
        &ogs_pfcp_tlv_desc_measurement_method,
        &ogs_pfcp_tlv_desc_reporting_triggers,
        &ogs_pfcp_tlv_desc_measurement_period,
        &ogs_pfcp_tlv_desc_volume_threshold,
        &ogs_pfcp_tlv_desc_volume_quota,
        &ogs_pfcp_tlv_desc_time_threshold,
        &ogs_pfcp_tlv_desc_time_quota,
        &ogs_pfcp_tlv_desc_event_threshold,
        &ogs_pfcp_tlv_desc_event_quota,
        &ogs_pfcp_tlv_desc_quota_holding_time,
        &ogs_pfcp_tlv_desc_dropped_dl_traffic_threshold,
        &ogs_pfcp_tlv_desc_quota_validity_time,
        &ogs_pfcp_tlv_desc_monitoring_time,
        &ogs_pfcp_tlv_desc_subsequent_volume_threshold,
        &ogs_pfcp_tlv_desc_subsequent_time_threshold,
        &ogs_pfcp_tlv_desc_subsequent_volume_quota,
        &ogs_pfcp_tlv_desc_subsequent_time_quota,
        &ogs_pfcp_tlv_desc_subsequent_event_threshold,
        &ogs_pfcp_tlv_desc_subsequent_event_quota,
        &ogs_pfcp_tlv_desc_inactivity_detection_time,
        &ogs_pfcp_tlv_desc_linked_urr_id,
        &ogs_pfcp_tlv_desc_measurement_information,
        &ogs_pfcp_tlv_desc_time_quota_mechanism,
        &ogs_pfcp_tlv_desc_aggregated_urrs,
        &ogs_pfcp_tlv_desc_far_id,
        &ogs_pfcp_tlv_desc_ethernet_inactivity_timer,
        &ogs_pfcp_tlv_desc_additional_monitoring_time,
        &ogs_pfcp_tlv_desc_number_of_reports,
        &ogs_pfcp_tlv_desc_application_id,
        &ogs_pfcp_tlv_desc_sdf_filter,
        &ogs_tlv_desc_more8,
        &ogs_pfcp_tlv_desc_user_plane_inactivity_timer,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_update_qer =
{
    OGS_TLV_COMPOUND,
    "Update QER",
    OGS_PFCP_UPDATE_QER_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_update_qer_t),
    {
        &ogs_pfcp_tlv_desc_qer_id,
        &ogs_pfcp_tlv_desc_qer_correlation_id,
        &ogs_pfcp_tlv_desc_gate_status,
        &ogs_pfcp_tlv_desc_mbr,
        &ogs_pfcp_tlv_desc_gbr,
        &ogs_pfcp_tlv_desc_packet_rate,
        &ogs_pfcp_tlv_desc_dl_flow_level_marking,
        &ogs_pfcp_tlv_desc_qfi,
        &ogs_pfcp_tlv_desc_rqi,
        &ogs_pfcp_tlv_desc_paging_policy_indicator,
        &ogs_pfcp_tlv_desc_averaging_window,
        &ogs_pfcp_tlv_desc_qer_control_indications,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_remove_pdr =
{
    OGS_TLV_COMPOUND,
    "Remove PDR",
    OGS_PFCP_REMOVE_PDR_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_remove_pdr_t),
    {
        &ogs_pfcp_tlv_desc_pdr_id,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_remove_far =
{
    OGS_TLV_COMPOUND,
    "Remove FAR",
    OGS_PFCP_REMOVE_FAR_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_remove_far_t),
    {
        &ogs_pfcp_tlv_desc_far_id,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_remove_urr =
{
    OGS_TLV_COMPOUND,
    "Remove URR",
    OGS_PFCP_REMOVE_URR_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_remove_urr_t),
    {
        &ogs_pfcp_tlv_desc_urr_id,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_remove_qer =
{
    OGS_TLV_COMPOUND,
    "Remove QER",
    OGS_PFCP_REMOVE_QER_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_remove_qer_t),
    {
        &ogs_pfcp_tlv_desc_qer_id,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_load_control_information =
{
    OGS_TLV_COMPOUND,
    "Load Control Information",
    OGS_PFCP_LOAD_CONTROL_INFORMATION_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_load_control_information_t),
    {
        &ogs_pfcp_tlv_desc_sequence_number,
        &ogs_pfcp_tlv_desc_metric,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_overload_control_information =
{
    OGS_TLV_COMPOUND,
    "Overload Control Information",
    OGS_PFCP_OVERLOAD_CONTROL_INFORMATION_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_overload_control_information_t),
    {
        &ogs_pfcp_tlv_desc_sequence_number,
        &ogs_pfcp_tlv_desc_metric,
        &ogs_pfcp_tlv_desc_timer,
        &ogs_pfcp_tlv_desc_oci_flags,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_application_detection_information =
{
    OGS_TLV_COMPOUND,
    "Application Detection Information",
    OGS_PFCP_APPLICATION_DETECTION_INFORMATION_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_application_detection_information_t),
    {
        &ogs_pfcp_tlv_desc_application_id,
        &ogs_pfcp_tlv_desc_application_instance_id,
        &ogs_pfcp_tlv_desc_flow_information,
        &ogs_pfcp_tlv_desc_pdr_id,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_query_urr =
{
    OGS_TLV_COMPOUND,
    "Query URR",
    OGS_PFCP_QUERY_URR_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_query_urr_t),
    {
        &ogs_pfcp_tlv_desc_urr_id,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_usage_report_session_modification_response =
{
    OGS_TLV_COMPOUND,
    "Usage Report Session Modification Response",
    OGS_PFCP_USAGE_REPORT_SESSION_MODIFICATION_RESPONSE_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_usage_report_session_modification_response_t),
    {
        &ogs_pfcp_tlv_desc_urr_id,
        &ogs_pfcp_tlv_desc_ur_seqn,
        &ogs_pfcp_tlv_desc_usage_report_trigger,
        &ogs_pfcp_tlv_desc_start_time,
        &ogs_pfcp_tlv_desc_end_time,
        &ogs_pfcp_tlv_desc_volume_measurement,
        &ogs_pfcp_tlv_desc_duration_measurement,
        &ogs_pfcp_tlv_desc_time_of_first_packet,
        &ogs_pfcp_tlv_desc_time_of_last_packet,
        &ogs_pfcp_tlv_desc_usage_information,
        &ogs_pfcp_tlv_desc_query_urr_reference,
        &ogs_pfcp_tlv_desc_ethernet_traffic_information,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_usage_report_session_deletion_response =
{
    OGS_TLV_COMPOUND,
    "Usage Report Session Deletion Response",
    OGS_PFCP_USAGE_REPORT_SESSION_DELETION_RESPONSE_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_usage_report_session_deletion_response_t),
    {
        &ogs_pfcp_tlv_desc_urr_id,
        &ogs_pfcp_tlv_desc_ur_seqn,
        &ogs_pfcp_tlv_desc_usage_report_trigger,
        &ogs_pfcp_tlv_desc_start_time,
        &ogs_pfcp_tlv_desc_end_time,
        &ogs_pfcp_tlv_desc_volume_measurement,
        &ogs_pfcp_tlv_desc_duration_measurement,
        &ogs_pfcp_tlv_desc_time_of_first_packet,
        &ogs_pfcp_tlv_desc_time_of_last_packet,
        &ogs_pfcp_tlv_desc_usage_information,
        &ogs_pfcp_tlv_desc_ethernet_traffic_information,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_usage_report_session_report_request =
{
    OGS_TLV_COMPOUND,
    "Usage Report Session Report Request",
    OGS_PFCP_USAGE_REPORT_SESSION_REPORT_REQUEST_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_usage_report_session_report_request_t),
    {
        &ogs_pfcp_tlv_desc_urr_id,
        &ogs_pfcp_tlv_desc_ur_seqn,
        &ogs_pfcp_tlv_desc_usage_report_trigger,
        &ogs_pfcp_tlv_desc_start_time,
        &ogs_pfcp_tlv_desc_end_time,
        &ogs_pfcp_tlv_desc_volume_measurement,
        &ogs_pfcp_tlv_desc_duration_measurement,
        &ogs_pfcp_tlv_desc_application_detection_information,
        &ogs_pfcp_tlv_desc_ue_ip_address,
        &ogs_pfcp_tlv_desc_network_instance,
        &ogs_pfcp_tlv_desc_time_of_first_packet,
        &ogs_pfcp_tlv_desc_time_of_last_packet,
        &ogs_pfcp_tlv_desc_usage_information,
        &ogs_pfcp_tlv_desc_query_urr_reference,
        &ogs_pfcp_tlv_desc_time_stamp,
        &ogs_pfcp_tlv_desc_ethernet_traffic_information,
        &ogs_pfcp_tlv_desc_join_ip_multicast_information_ie_within_usage_report,
        &ogs_pfcp_tlv_desc_leave_ip_multicast_information_ie_within_usage_report,
        &ogs_pfcp_tlv_desc_predefined_rules_name,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_downlink_data_report =
{
    OGS_TLV_COMPOUND,
    "Downlink Data Report",
    OGS_PFCP_DOWNLINK_DATA_REPORT_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_downlink_data_report_t),
    {
        &ogs_pfcp_tlv_desc_pdr_id,
        &ogs_pfcp_tlv_desc_downlink_data_service_information,
        &ogs_pfcp_tlv_desc_dl_data_packets_size,
        &ogs_pfcp_tlv_desc_data_status,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_create_bar =
{
    OGS_TLV_COMPOUND,
    "Create BAR",
    OGS_PFCP_CREATE_BAR_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_create_bar_t),
    {
        &ogs_pfcp_tlv_desc_bar_id,
        &ogs_pfcp_tlv_desc_downlink_data_notification_delay,
        &ogs_pfcp_tlv_desc_suggested_buffering_packets_count,
        &ogs_pfcp_tlv_desc_mt_edt_control_information,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_update_bar_session_modification_request =
{
    OGS_TLV_COMPOUND,
    "Update BAR Session Modification Request",
    OGS_PFCP_UPDATE_BAR_SESSION_MODIFICATION_REQUEST_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_update_bar_session_modification_request_t),
    {
        &ogs_pfcp_tlv_desc_bar_id,
        &ogs_pfcp_tlv_desc_downlink_data_notification_delay,
        &ogs_pfcp_tlv_desc_suggested_buffering_packets_count,
        &ogs_pfcp_tlv_desc_mt_edt_control_information,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_remove_bar =
{
    OGS_TLV_COMPOUND,
    "Remove BAR",
    OGS_PFCP_REMOVE_BAR_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_remove_bar_t),
    {
        &ogs_pfcp_tlv_desc_bar_id,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_error_indication_report =
{
    OGS_TLV_COMPOUND,
    "Error Indication Report",
    OGS_PFCP_ERROR_INDICATION_REPORT_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_error_indication_report_t),
    {
        &ogs_pfcp_tlv_desc_f_teid,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_user_plane_path_failure_report =
{
    OGS_TLV_COMPOUND,
    "User Plane Path Failure Report",
    OGS_PFCP_USER_PLANE_PATH_FAILURE_REPORT_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_user_plane_path_failure_report_t),
    {
        &ogs_pfcp_tlv_desc_remote_gtp_u_peer,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_create_traffic_endpoint =
{
    OGS_TLV_COMPOUND,
    "Create Traffic Endpoint",
    OGS_PFCP_CREATE_TRAFFIC_ENDPOINT_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_create_traffic_endpoint_t),
    {
        &ogs_pfcp_tlv_desc_traffic_endpoint_id,
        &ogs_pfcp_tlv_desc_f_teid,
        &ogs_pfcp_tlv_desc_network_instance,
        &ogs_pfcp_tlv_desc_redundant_transmission_parameters,
        &ogs_pfcp_tlv_desc_ue_ip_address,
        &ogs_pfcp_tlv_desc_ethernet_pdu_session_information,
        &ogs_pfcp_tlv_desc_framed_route,
        &ogs_tlv_desc_more8,
        &ogs_pfcp_tlv_desc_framed_routing,
        &ogs_pfcp_tlv_desc_framed_ipv6_route,
        &ogs_tlv_desc_more8,
        &ogs_pfcp_tlv_desc_qfi,
        &ogs_pfcp_tlv_desc__interface_type,
        &ogs_pfcp_tlv_desc_local_ingress_tunnel,
        &ogs_pfcp_tlv_desc_ip_multicast_addressing_info_within_pfcp_session_establishment_request,
        &ogs_pfcp_tlv_desc_mbs_session_identifier,
        &ogs_pfcp_tlv_desc_area_session_id,
        &ogs_pfcp_tlv_desc_rat_type,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_created_traffic_endpoint =
{
    OGS_TLV_COMPOUND,
    "Created Traffic Endpoint",
    OGS_PFCP_CREATED_TRAFFIC_ENDPOINT_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_created_traffic_endpoint_t),
    {
        &ogs_pfcp_tlv_desc_traffic_endpoint_id,
        &ogs_pfcp_tlv_desc_f_teid,
        &ogs_pfcp_tlv_desc_f_teid,
        &ogs_pfcp_tlv_desc_ue_ip_address,
        &ogs_pfcp_tlv_desc_local_ingress_tunnel,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_remove_traffic_endpoint =
{
    OGS_TLV_COMPOUND,
    "Remove Traffic Endpoint",
    OGS_PFCP_REMOVE_TRAFFIC_ENDPOINT_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_remove_traffic_endpoint_t),
    {
        &ogs_pfcp_tlv_desc_traffic_endpoint_id,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_create_mar =
{
    OGS_TLV_COMPOUND,
    "Create MAR",
    OGS_PFCP_CREATE_MAR_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_create_mar_t),
    {
        &ogs_pfcp_tlv_desc_mar_id,
        &ogs_pfcp_tlv_desc_steering_functionality,
        &ogs_pfcp_tlv_desc_steering_mode,
        &ogs_pfcp_tlv_desc__access_forwarding_action_information,
        &ogs_pfcp_tlv_desc_non__access_forwarding_action_information,
        &ogs_pfcp_tlv_desc_thresholds,
        &ogs_pfcp_tlv_desc_steering_mode_indicator,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_remove_mar =
{
    OGS_TLV_COMPOUND,
    "Remove MAR",
    OGS_PFCP_REMOVE_MAR_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_remove_mar_t),
    {
        &ogs_pfcp_tlv_desc_mar_id,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_update_mar =
{
    OGS_TLV_COMPOUND,
    "Update MAR",
    OGS_PFCP_UPDATE_MAR_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_update_mar_t),
    {
        &ogs_pfcp_tlv_desc_mar_id,
        &ogs_pfcp_tlv_desc_steering_functionality,
        &ogs_pfcp_tlv_desc_steering_mode,
        &ogs_pfcp_tlv_desc_update__access_forwarding_action_information,
        &ogs_pfcp_tlv_desc_update_non__access_forwarding_action_information,
        &ogs_pfcp_tlv_desc__access_forwarding_action_information,
        &ogs_pfcp_tlv_desc_non__access_forwarding_action_information,
        &ogs_pfcp_tlv_desc_thresholds,
        &ogs_pfcp_tlv_desc_steering_mode_indicator,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_pfcp_session_retention_information_within_pfcp_association_setup_request =
{
    OGS_TLV_COMPOUND,
    "PFCP Session Retention Information within PFCP Association Setup Request",
    OGS_PFCP_PFCP_SESSION_RETENTION_INFORMATION_WITHIN_PFCP_ASSOCIATION_SETUP_REQUEST_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_pfcp_session_retention_information_within_pfcp_association_setup_request_t),
    {
        &ogs_pfcp_tlv_desc_cp_pfcp_entity_ip_address,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_user_plane_path_recovery_report =
{
    OGS_TLV_COMPOUND,
    "User Plane Path Recovery Report",
    OGS_PFCP_USER_PLANE_PATH_RECOVERY_REPORT_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_user_plane_path_recovery_report_t),
    {
        &ogs_pfcp_tlv_desc_remote_gtp_u_peer,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_created_bridge_info_for_tsc =
{
    OGS_TLV_COMPOUND,
    "Created Bridge Info for TSC",
    OGS_PFCP_CREATED_BRIDGE_INFO_FOR_TSC_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_created_bridge_info_for_tsc_t),
    {
        &ogs_pfcp_tlv_desc_ds_tt_port_number,
        &ogs_pfcp_tlv_desc_fivegs_user_plane_node,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_tsc_management_information_ie_within_pfcp_session_modification_request =
{
    OGS_TLV_COMPOUND,
    "TSC Management Information IE within PFCP Session Modification Request",
    OGS_PFCP_TSC_MANAGEMENT_INFORMATION_IE_WITHIN_PFCP_SESSION_MODIFICATION_REQUEST_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_tsc_management_information_ie_within_pfcp_session_modification_request_t),
    {
        &ogs_pfcp_tlv_desc_port_management_information_container,
        &ogs_pfcp_tlv_desc_bridge_management_information_container,
        &ogs_pfcp_tlv_desc_nw_tt_port_number,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_tsc_management_information_ie_within_pfcp_session_modification_response =
{
    OGS_TLV_COMPOUND,
    "TSC Management Information IE within PFCP Session Modification Response",
    OGS_PFCP_TSC_MANAGEMENT_INFORMATION_IE_WITHIN_PFCP_SESSION_MODIFICATION_RESPONSE_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_tsc_management_information_ie_within_pfcp_session_modification_response_t),
    {
        &ogs_pfcp_tlv_desc_port_management_information_container,
        &ogs_pfcp_tlv_desc_bridge_management_information_container,
        &ogs_pfcp_tlv_desc_nw_tt_port_number,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_tsc_management_information_ie_within_pfcp_session_report_request =
{
    OGS_TLV_COMPOUND,
    "TSC Management Information IE within PFCP Session Report Request",
    OGS_PFCP_TSC_MANAGEMENT_INFORMATION_IE_WITHIN_PFCP_SESSION_REPORT_REQUEST_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_tsc_management_information_ie_within_pfcp_session_report_request_t),
    {
        &ogs_pfcp_tlv_desc_port_management_information_container,
        &ogs_pfcp_tlv_desc_bridge_management_information_container,
        &ogs_pfcp_tlv_desc_nw_tt_port_number,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_clock_drift_control_information =
{
    OGS_TLV_COMPOUND,
    "Clock Drift Control Information",
    OGS_PFCP_CLOCK_DRIFT_CONTROL_INFORMATION_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_clock_drift_control_information_t),
    {
        &ogs_pfcp_tlv_desc_requested_clock_drift_information,
        &ogs_pfcp_tlv_desc_time_domain_number,
        &ogs_pfcp_tlv_desc_configured_time_domain,
        &ogs_pfcp_tlv_desc_time_offset_threshold,
        &ogs_pfcp_tlv_desc_cumulative_rateratio_threshold,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_clock_drift_report =
{
    OGS_TLV_COMPOUND,
    "Clock Drift Report",
    OGS_PFCP_CLOCK_DRIFT_REPORT_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_clock_drift_report_t),
    {
        &ogs_pfcp_tlv_desc_time_domain_number,
        &ogs_pfcp_tlv_desc_time_offset_measurement,
        &ogs_pfcp_tlv_desc_cumulative_rateratio_measurement,
        &ogs_pfcp_tlv_desc_time_stamp,
        &ogs_pfcp_tlv_desc_network_instance,
        &ogs_pfcp_tlv_desc_apn_dnn,
        &ogs_pfcp_tlv_desc_s_nssai,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_remove_srr =
{
    OGS_TLV_COMPOUND,
    "Remove SRR",
    OGS_PFCP_REMOVE_SRR_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_remove_srr_t),
    {
        &ogs_pfcp_tlv_desc_srr_id,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_create_srr =
{
    OGS_TLV_COMPOUND,
    "Create SRR",
    OGS_PFCP_CREATE_SRR_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_create_srr_t),
    {
        &ogs_pfcp_tlv_desc_srr_id,
        &ogs_pfcp_tlv_desc_access_availability_control_information,
        &ogs_pfcp_tlv_desc_qos_monitoring_per_qos_flow_control_information,
        &ogs_pfcp_tlv_desc_direct_reporting_information,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_update_srr =
{
    OGS_TLV_COMPOUND,
    "Update SRR",
    OGS_PFCP_UPDATE_SRR_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_update_srr_t),
    {
        &ogs_pfcp_tlv_desc_srr_id,
        &ogs_pfcp_tlv_desc_access_availability_control_information,
        &ogs_pfcp_tlv_desc_qos_monitoring_per_qos_flow_control_information,
        &ogs_pfcp_tlv_desc_direct_reporting_information,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_session_report =
{
    OGS_TLV_COMPOUND,
    "Session Report",
    OGS_PFCP_SESSION_REPORT_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_session_report_t),
    {
        &ogs_pfcp_tlv_desc_srr_id,
        &ogs_pfcp_tlv_desc_access_availability_report,
        &ogs_pfcp_tlv_desc_qos_monitoring_report,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_provide_atsss_control_information =
{
    OGS_TLV_COMPOUND,
    "Provide ATSSS Control Information",
    OGS_PFCP_PROVIDE_ATSSS_CONTROL_INFORMATION_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_provide_atsss_control_information_t),
    {
        &ogs_pfcp_tlv_desc_mptcp_control_information,
        &ogs_pfcp_tlv_desc_atsss_ll_control_information,
        &ogs_pfcp_tlv_desc_pmf_control_information,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_atsss_control_parameters =
{
    OGS_TLV_COMPOUND,
    "ATSSS Control Parameters",
    OGS_PFCP_ATSSS_CONTROL_PARAMETERS_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_atsss_control_parameters_t),
    {
        &ogs_pfcp_tlv_desc_mptcp_parameters,
        &ogs_pfcp_tlv_desc_atsss_ll_parameters,
        &ogs_pfcp_tlv_desc_pmf_parameters,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_ue_ip_address_pool_information =
{
    OGS_TLV_COMPOUND,
    "UE IP address Pool Information",
    OGS_PFCP_UE_IP_ADDRESS_POOL_INFORMATION_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_ue_ip_address_pool_information_t),
    {
        &ogs_pfcp_tlv_desc_ue_ip_address,
        &ogs_pfcp_tlv_desc_network_instance,
        &ogs_pfcp_tlv_desc_s_nssai,
        &ogs_pfcp_tlv_desc_ip_version,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_gtp_u_path_qos_report_pfcp_node_report_request =
{
    OGS_TLV_COMPOUND,
    "GTP-U Path QoS Report PFCP Node Report Request",
    OGS_PFCP_GTP_U_PATH_QOS_REPORT_PFCP_NODE_REPORT_REQUEST_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_gtp_u_path_qos_report_pfcp_node_report_request_t),
    {
        &ogs_pfcp_tlv_desc_remote_gtp_u_peer,
        &ogs_pfcp_tlv_desc_gtp_u_path_interface_type,
        &ogs_pfcp_tlv_desc_qos_report_trigger,
        &ogs_pfcp_tlv_desc_transport_level_marking,
        &ogs_pfcp_tlv_desc_measurement_period,
        &ogs_pfcp_tlv_desc_average_packet_delay,
        &ogs_pfcp_tlv_desc_minimum_packet_delay,
        &ogs_pfcp_tlv_desc_maximum_packet_delay,
        &ogs_pfcp_tlv_desc_timer,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_qos_information_in_gtp_u_path_qos_report =
{
    OGS_TLV_COMPOUND,
    "QoS Information in GTP-U Path QoS Report",
    OGS_PFCP_QOS_INFORMATION_IN_GTP_U_PATH_QOS_REPORT_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_qos_information_in_gtp_u_path_qos_report_t),
    {
        &ogs_pfcp_tlv_desc_average_packet_delay,
        &ogs_pfcp_tlv_desc_minimum_packet_delay,
        &ogs_pfcp_tlv_desc_maximum_packet_delay,
        &ogs_pfcp_tlv_desc_transport_level_marking,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_packet_rate_status_report =
{
    OGS_TLV_COMPOUND,
    "Packet Rate Status Report",
    OGS_PFCP_PACKET_RATE_STATUS_REPORT_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_packet_rate_status_report_t),
    {
        &ogs_pfcp_tlv_desc_qer_id,
        &ogs_pfcp_tlv_desc_packet_rate_status,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_ethernet_context_information =
{
    OGS_TLV_COMPOUND,
    "Ethernet Context Information",
    OGS_PFCP_ETHERNET_CONTEXT_INFORMATION_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_ethernet_context_information_t),
    {
        &ogs_pfcp_tlv_desc_mac_addresses_detected,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_updated_pdr =
{
    OGS_TLV_COMPOUND,
    "Updated PDR",
    OGS_PFCP_UPDATED_PDR_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_updated_pdr_t),
    {
        &ogs_pfcp_tlv_desc_pdr_id,
        &ogs_pfcp_tlv_desc_f_teid,
        &ogs_pfcp_tlv_desc_f_teid,
        &ogs_pfcp_tlv_desc_ue_ip_address,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_provide_rds_configuration_information =
{
    OGS_TLV_COMPOUND,
    "Provide RDS Configuration Information",
    OGS_PFCP_PROVIDE_RDS_CONFIGURATION_INFORMATION_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_provide_rds_configuration_information_t),
    {
        &ogs_pfcp_tlv_desc_rds_configuration_information,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_query_packet_rate_status_ie_within_pfcp_session_modification_request =
{
    OGS_TLV_COMPOUND,
    "Query Packet Rate Status IE within PFCP Session Modification Request",
    OGS_PFCP_QUERY_PACKET_RATE_STATUS_IE_WITHIN_PFCP_SESSION_MODIFICATION_REQUEST_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_query_packet_rate_status_ie_within_pfcp_session_modification_request_t),
    {
        &ogs_pfcp_tlv_desc_qer_id,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_packet_rate_status_report_ie_within_pfcp_session_modification_response =
{
    OGS_TLV_COMPOUND,
    "Packet Rate Status Report IE within PFCP Session Modification Response",
    OGS_PFCP_PACKET_RATE_STATUS_REPORT_IE_WITHIN_PFCP_SESSION_MODIFICATION_RESPONSE_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_packet_rate_status_report_ie_within_pfcp_session_modification_response_t),
    {
        &ogs_pfcp_tlv_desc_qer_id,
        &ogs_pfcp_tlv_desc_packet_rate_status,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_ue_ip_address_usage_information =
{
    OGS_TLV_COMPOUND,
    "UE IP Address Usage Information",
    OGS_PFCP_UE_IP_ADDRESS_USAGE_INFORMATION_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_ue_ip_address_usage_information_t),
    {
        &ogs_pfcp_tlv_desc_sequence_number,
        &ogs_pfcp_tlv_desc_metric,
        &ogs_pfcp_tlv_desc_validity_timer,
        &ogs_pfcp_tlv_desc_number_of_ue_ip_addresses,
        &ogs_pfcp_tlv_desc_network_instance,
        &ogs_pfcp_tlv_desc_ue_ip_address,
        &ogs_pfcp_tlv_desc_s_nssai,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_partial_failure_information =
{
    OGS_TLV_COMPOUND,
    "Partial Failure Information",
    OGS_PFCP_PARTIAL_FAILURE_INFORMATION_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_partial_failure_information_t),
    {
        &ogs_pfcp_tlv_desc_failed_rule_id,
        &ogs_pfcp_tlv_desc_cause,
        &ogs_pfcp_tlv_desc_offending_ie_information,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_l2tp_tunnel_information =
{
    OGS_TLV_COMPOUND,
    "L2TP Tunnel Information",
    OGS_PFCP_L2TP_TUNNEL_INFORMATION_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_l2tp_tunnel_information_t),
    {
        &ogs_pfcp_tlv_desc_lns_address,
        &ogs_pfcp_tlv_desc_tunnel_password,
        &ogs_pfcp_tlv_desc_tunnel_preference,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_l2tp_session_information =
{
    OGS_TLV_COMPOUND,
    "L2TP Session Information",
    OGS_PFCP_L2TP_SESSION_INFORMATION_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_l2tp_session_information_t),
    {
        &ogs_pfcp_tlv_desc_calling_number,
        &ogs_pfcp_tlv_desc_called_number,
        &ogs_pfcp_tlv_desc_maximum_receive_unit,
        &ogs_pfcp_tlv_desc_l2tp_session_indications,
        &ogs_pfcp_tlv_desc_l2tp_user_authentication_ie,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_created_l2tp_session =
{
    OGS_TLV_COMPOUND,
    "Created L2TP Session",
    OGS_PFCP_CREATED_L2TP_SESSION_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_created_l2tp_session_t),
    {
        &ogs_pfcp_tlv_desc_dns_server_address,
        &ogs_pfcp_tlv_desc_nbns_server_address,
        &ogs_pfcp_tlv_desc_lns_address,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_pfcp_session_change_info =
{
    OGS_TLV_COMPOUND,
    "PFCP Session Change Info",
    OGS_PFCP_PFCP_SESSION_CHANGE_INFO_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_pfcp_session_change_info_t),
    {
        &ogs_pfcp_tlv_desc_fq_csid,
        &ogs_pfcp_tlv_desc_group_id,
        &ogs_pfcp_tlv_desc_cp_ip_address,
        &ogs_pfcp_tlv_desc_alternative_smf_ip_address,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_mbs_session_n4mb_control_information =
{
    OGS_TLV_COMPOUND,
    "MBS Session N4mb Control Information",
    OGS_PFCP_MBS_SESSION_N4MB_CONTROL_INFORMATION_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_mbs_session_n4mb_control_information_t),
    {
        &ogs_pfcp_tlv_desc_mbs_session_identifier,
        &ogs_pfcp_tlv_desc_area_session_id,
        &ogs_pfcp_tlv_desc_mbsn4mbreq_flags,
        &ogs_pfcp_tlv_desc_multicast_transport_information,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_mbs_session_n4mb_information =
{
    OGS_TLV_COMPOUND,
    "MBS Session N4mb Information",
    OGS_PFCP_MBS_SESSION_N4MB_INFORMATION_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_mbs_session_n4mb_information_t),
    {
        &ogs_pfcp_tlv_desc_multicast_transport_information,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_mbs_session_n4_control_information =
{
    OGS_TLV_COMPOUND,
    "MBS Session N4 Control Information",
    OGS_PFCP_MBS_SESSION_N4_CONTROL_INFORMATION_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_mbs_session_n4_control_information_t),
    {
        &ogs_pfcp_tlv_desc_mbs_session_identifier,
        &ogs_pfcp_tlv_desc_area_session_id,
        &ogs_pfcp_tlv_desc_multicast_transport_information,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_mbs_session_n4_information =
{
    OGS_TLV_COMPOUND,
    "MBS Session N4 Information",
    OGS_PFCP_MBS_SESSION_N4_INFORMATION_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_mbs_session_n4_information_t),
    {
        &ogs_pfcp_tlv_desc_mbs_session_identifier,
        &ogs_pfcp_tlv_desc_area_session_id,
        &ogs_pfcp_tlv_desc_f_teid,
        &ogs_pfcp_tlv_desc_mbsn4resp_flags,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_tlv_desc_dscp_to_ppi_control_information =
{
    OGS_TLV_COMPOUND,
    "DSCP to PPI Control Information",
    OGS_PFCP_DSCP_TO_PPI_CONTROL_INFORMATION_TYPE,
    0,
    0,
    sizeof(ogs_pfcp_tlv_dscp_to_ppi_control_information_t),
    {
        &ogs_pfcp_tlv_desc_dscp_to_ppi_mapping_information,
        &ogs_pfcp_tlv_desc_qfi,
        NULL,
    }
};

ogs_tlv_desc_t ogs_pfcp_msg_desc_pfcp_heartbeat_request =
{
    OGS_TLV_MESSAGE,
    "PFCP Heartbeat Request",
    0, 0, 0, 0, {
        &ogs_pfcp_tlv_desc_recovery_time_stamp,
        &ogs_pfcp_tlv_desc_source_ip_address,
    NULL,
}};

ogs_tlv_desc_t ogs_pfcp_msg_desc_pfcp_heartbeat_response =
{
    OGS_TLV_MESSAGE,
    "PFCP Heartbeat Response",
    0, 0, 0, 0, {
        &ogs_pfcp_tlv_desc_recovery_time_stamp,
    NULL,
}};

ogs_tlv_desc_t ogs_pfcp_msg_desc_pfcp_pfd_management_request =
{
    OGS_TLV_MESSAGE,
    "PFCP PFD Management Request",
    0, 0, 0, 0, {
        &ogs_pfcp_tlv_desc_application_id_s_pfds,
        &ogs_pfcp_tlv_desc_node_id,
    NULL,
}};

ogs_tlv_desc_t ogs_pfcp_msg_desc_pfcp_pfd_management_response =
{
    OGS_TLV_MESSAGE,
    "PFCP PFD Management Response",
    0, 0, 0, 0, {
        &ogs_pfcp_tlv_desc_cause,
        &ogs_pfcp_tlv_desc_offending_ie,
        &ogs_pfcp_tlv_desc_node_id,
    NULL,
}};

ogs_tlv_desc_t ogs_pfcp_msg_desc_pfcp_association_setup_request =
{
    OGS_TLV_MESSAGE,
    "PFCP Association Setup Request",
    0, 0, 0, 0, {
        &ogs_pfcp_tlv_desc_node_id,
        &ogs_pfcp_tlv_desc_recovery_time_stamp,
        &ogs_pfcp_tlv_desc_up_function_features,
        &ogs_pfcp_tlv_desc_cp_function_features,
        &ogs_pfcp_tlv_desc_user_plane_ip_resource_information,
        &ogs_tlv_desc_more4,
        &ogs_pfcp_tlv_desc_alternative_smf_ip_address,
        &ogs_pfcp_tlv_desc_smf_set_id,
        &ogs_pfcp_tlv_desc_pfcp_session_retention_information_within_pfcp_association_setup_request,
        &ogs_pfcp_tlv_desc_ue_ip_address,
        &ogs_pfcp_tlv_desc_gtp_u_path_qos_control_information,
        &ogs_pfcp_tlv_desc_clock_drift_control_information,
        &ogs_pfcp_tlv_desc_nf_instance_id,
        &ogs_pfcp_tlv_desc_pfcpasreq_flags,
    NULL,
}};

ogs_tlv_desc_t ogs_pfcp_msg_desc_pfcp_association_setup_response =
{
    OGS_TLV_MESSAGE,
    "PFCP Association Setup Response",
    0, 0, 0, 0, {
        &ogs_pfcp_tlv_desc_node_id,
        &ogs_pfcp_tlv_desc_cause,
        &ogs_pfcp_tlv_desc_recovery_time_stamp,
        &ogs_pfcp_tlv_desc_up_function_features,
        &ogs_pfcp_tlv_desc_cp_function_features,
        &ogs_pfcp_tlv_desc_user_plane_ip_resource_information,
        &ogs_tlv_desc_more4,
        &ogs_pfcp_tlv_desc_alternative_smf_ip_address,
        &ogs_pfcp_tlv_desc_smf_set_id,
        &ogs_pfcp_tlv_desc_pfcpasrsp_flags,
        &ogs_pfcp_tlv_desc_clock_drift_control_information,
        &ogs_pfcp_tlv_desc_ue_ip_address,
        &ogs_pfcp_tlv_desc_gtp_u_path_qos_control_information,
        &ogs_pfcp_tlv_desc_nf_instance_id,
    NULL,
}};

ogs_tlv_desc_t ogs_pfcp_msg_desc_pfcp_association_update_request =
{
    OGS_TLV_MESSAGE,
    "PFCP Association Update Request",
    0, 0, 0, 0, {
        &ogs_pfcp_tlv_desc_node_id,
        &ogs_pfcp_tlv_desc_up_function_features,
        &ogs_pfcp_tlv_desc_cp_function_features,
        &ogs_pfcp_tlv_desc_user_plane_ip_resource_information,
        &ogs_tlv_desc_more4,
        &ogs_pfcp_tlv_desc_pfcp_association_release_request,
        &ogs_pfcp_tlv_desc_graceful_release_period,
        &ogs_pfcp_tlv_desc_pfcpaureq_flags,
        &ogs_pfcp_tlv_desc_alternative_smf_ip_address,
        &ogs_pfcp_tlv_desc_smf_set_id,
        &ogs_pfcp_tlv_desc_clock_drift_control_information,
        &ogs_pfcp_tlv_desc_ue_ip_address,
        &ogs_pfcp_tlv_desc_gtp_u_path_qos_control_information,
        &ogs_pfcp_tlv_desc_ue_ip_address_usage_information,
    NULL,
}};

ogs_tlv_desc_t ogs_pfcp_msg_desc_pfcp_association_update_response =
{
    OGS_TLV_MESSAGE,
    "PFCP Association Update Response",
    0, 0, 0, 0, {
        &ogs_pfcp_tlv_desc_node_id,
        &ogs_pfcp_tlv_desc_cause,
        &ogs_pfcp_tlv_desc_up_function_features,
        &ogs_pfcp_tlv_desc_cp_function_features,
        &ogs_pfcp_tlv_desc_user_plane_ip_resource_information,
        &ogs_tlv_desc_more4,
        &ogs_pfcp_tlv_desc_ue_ip_address_usage_information,
    NULL,
}};

ogs_tlv_desc_t ogs_pfcp_msg_desc_pfcp_association_release_request =
{
    OGS_TLV_MESSAGE,
    "PFCP Association Release Request",
    0, 0, 0, 0, {
        &ogs_pfcp_tlv_desc_node_id,
    NULL,
}};

ogs_tlv_desc_t ogs_pfcp_msg_desc_pfcp_association_release_response =
{
    OGS_TLV_MESSAGE,
    "PFCP Association Release Response",
    0, 0, 0, 0, {
        &ogs_pfcp_tlv_desc_node_id,
        &ogs_pfcp_tlv_desc_cause,
    NULL,
}};

ogs_tlv_desc_t ogs_pfcp_msg_desc_pfcp_version_not_supported_response =
{
    OGS_TLV_MESSAGE,
    "PFCP Version Not Supported Response",
    0, 0, 0, 0, {
    NULL,
}};

ogs_tlv_desc_t ogs_pfcp_msg_desc_pfcp_node_report_request =
{
    OGS_TLV_MESSAGE,
    "PFCP Node Report Request",
    0, 0, 0, 0, {
        &ogs_pfcp_tlv_desc_node_id,
        &ogs_pfcp_tlv_desc_node_report_type,
        &ogs_pfcp_tlv_desc_vendor_specific_node_report_type,
        &ogs_pfcp_tlv_desc_user_plane_path_failure_report,
        &ogs_pfcp_tlv_desc_user_plane_path_recovery_report,
        &ogs_pfcp_tlv_desc_clock_drift_report,
        &ogs_pfcp_tlv_desc_gtp_u_path_qos_report_pfcp_node_report_request,
        &ogs_pfcp_tlv_desc_peer_up_restart_report,
    NULL,
}};

ogs_tlv_desc_t ogs_pfcp_msg_desc_pfcp_node_report_response =
{
    OGS_TLV_MESSAGE,
    "PFCP Node Report Response",
    0, 0, 0, 0, {
        &ogs_pfcp_tlv_desc_node_id,
        &ogs_pfcp_tlv_desc_cause,
        &ogs_pfcp_tlv_desc_offending_ie,
    NULL,
}};

ogs_tlv_desc_t ogs_pfcp_msg_desc_pfcp_session_set_deletion_request =
{
    OGS_TLV_MESSAGE,
    "PFCP Session Set Deletion Request",
    0, 0, 0, 0, {
        &ogs_pfcp_tlv_desc_node_id,
        &ogs_pfcp_tlv_desc_fq_csid,
        &ogs_pfcp_tlv_desc_fq_csid,
        &ogs_pfcp_tlv_desc_fq_csid,
        &ogs_pfcp_tlv_desc_fq_csid,
        &ogs_pfcp_tlv_desc_fq_csid,
        &ogs_pfcp_tlv_desc_fq_csid,
    NULL,
}};

ogs_tlv_desc_t ogs_pfcp_msg_desc_pfcp_session_set_deletion_response =
{
    OGS_TLV_MESSAGE,
    "PFCP Session Set Deletion Response",
    0, 0, 0, 0, {
        &ogs_pfcp_tlv_desc_node_id,
        &ogs_pfcp_tlv_desc_cause,
        &ogs_pfcp_tlv_desc_offending_ie,
    NULL,
}};

ogs_tlv_desc_t ogs_pfcp_msg_desc_pfcp_session_set_modification_request =
{
    OGS_TLV_MESSAGE,
    "PFCP Session Set Modification Request",
    0, 0, 0, 0, {
        &ogs_pfcp_tlv_desc_node_id,
        &ogs_pfcp_tlv_desc_pfcp_session_change_info,
    NULL,
}};

ogs_tlv_desc_t ogs_pfcp_msg_desc_pfcp_session_set_modification_response =
{
    OGS_TLV_MESSAGE,
    "PFCP Session Set Modification Response",
    0, 0, 0, 0, {
        &ogs_pfcp_tlv_desc_node_id,
        &ogs_pfcp_tlv_desc_cause,
        &ogs_pfcp_tlv_desc_offending_ie,
    NULL,
}};

ogs_tlv_desc_t ogs_pfcp_msg_desc_pfcp_session_establishment_request =
{
    OGS_TLV_MESSAGE,
    "PFCP Session Establishment Request",
    0, 0, 0, 0, {
        &ogs_pfcp_tlv_desc_node_id,
        &ogs_pfcp_tlv_desc_f_seid,
        &ogs_pfcp_tlv_desc_create_pdr,
        &ogs_tlv_desc_more16,
        &ogs_pfcp_tlv_desc_create_far,
        &ogs_tlv_desc_more16,
        &ogs_pfcp_tlv_desc_create_urr,
        &ogs_tlv_desc_more16,
        &ogs_pfcp_tlv_desc_create_qer,
        &ogs_tlv_desc_more4,
        &ogs_pfcp_tlv_desc_create_bar,
        &ogs_pfcp_tlv_desc_create_traffic_endpoint,
        &ogs_pfcp_tlv_desc_pdn_type,
        &ogs_pfcp_tlv_desc_fq_csid,
        &ogs_pfcp_tlv_desc_fq_csid,
        &ogs_pfcp_tlv_desc_fq_csid,
        &ogs_pfcp_tlv_desc_fq_csid,
        &ogs_pfcp_tlv_desc_fq_csid,
        &ogs_pfcp_tlv_desc_user_plane_inactivity_timer,
        &ogs_pfcp_tlv_desc_user_id,
        &ogs_pfcp_tlv_desc_trace_information,
        &ogs_pfcp_tlv_desc_apn_dnn,
        &ogs_pfcp_tlv_desc_create_mar,
        &ogs_pfcp_tlv_desc_pfcpsereq_flags,
        &ogs_pfcp_tlv_desc_create_bridge_info_for_tsc,
        &ogs_pfcp_tlv_desc_create_srr,
        &ogs_pfcp_tlv_desc_provide_atsss_control_information,
        &ogs_pfcp_tlv_desc_recovery_time_stamp,
        &ogs_pfcp_tlv_desc_s_nssai,
        &ogs_pfcp_tlv_desc_provide_rds_configuration_information,
        &ogs_pfcp_tlv_desc_rat_type,
        &ogs_pfcp_tlv_desc_l2tp_tunnel_information,
        &ogs_pfcp_tlv_desc_l2tp_session_information,
        &ogs_pfcp_tlv_desc_group_id,
        &ogs_pfcp_tlv_desc_mbs_session_n4mb_control_information,
        &ogs_pfcp_tlv_desc_mbs_session_n4_control_information,
        &ogs_pfcp_tlv_desc_dscp_to_ppi_control_information,
    NULL,
}};

ogs_tlv_desc_t ogs_pfcp_msg_desc_pfcp_session_establishment_response =
{
    OGS_TLV_MESSAGE,
    "PFCP Session Establishment Response",
    0, 0, 0, 0, {
        &ogs_pfcp_tlv_desc_node_id,
        &ogs_pfcp_tlv_desc_cause,
        &ogs_pfcp_tlv_desc_offending_ie,
        &ogs_pfcp_tlv_desc_f_seid,
        &ogs_pfcp_tlv_desc_created_pdr,
        &ogs_tlv_desc_more16,
        &ogs_pfcp_tlv_desc_load_control_information,
        &ogs_pfcp_tlv_desc_overload_control_information,
        &ogs_pfcp_tlv_desc_fq_csid,
        &ogs_pfcp_tlv_desc_failed_rule_id,
        &ogs_pfcp_tlv_desc_created_traffic_endpoint,
        &ogs_pfcp_tlv_desc_created_bridge_info_for_tsc,
        &ogs_pfcp_tlv_desc_atsss_control_parameters,
        &ogs_pfcp_tlv_desc_rds_configuration_information,
        &ogs_pfcp_tlv_desc_partial_failure_information,
        &ogs_pfcp_tlv_desc_created_l2tp_session,
        &ogs_pfcp_tlv_desc_mbs_session_n4mb_information,
        &ogs_pfcp_tlv_desc_mbs_session_n4_information,
    NULL,
}};

ogs_tlv_desc_t ogs_pfcp_msg_desc_pfcp_session_modification_request =
{
    OGS_TLV_MESSAGE,
    "PFCP Session Modification Request",
    0, 0, 0, 0, {
        &ogs_pfcp_tlv_desc_f_seid,
        &ogs_pfcp_tlv_desc_remove_pdr,
        &ogs_tlv_desc_more16,
        &ogs_pfcp_tlv_desc_remove_far,
        &ogs_tlv_desc_more16,
        &ogs_pfcp_tlv_desc_remove_urr,
        &ogs_tlv_desc_more16,
        &ogs_pfcp_tlv_desc_remove_qer,
        &ogs_tlv_desc_more4,
        &ogs_pfcp_tlv_desc_remove_bar,
        &ogs_pfcp_tlv_desc_remove_traffic_endpoint,
        &ogs_pfcp_tlv_desc_create_pdr,
        &ogs_tlv_desc_more16,
        &ogs_pfcp_tlv_desc_create_far,
        &ogs_tlv_desc_more16,
        &ogs_pfcp_tlv_desc_create_urr,
        &ogs_tlv_desc_more16,
        &ogs_pfcp_tlv_desc_create_qer,
        &ogs_tlv_desc_more4,
        &ogs_pfcp_tlv_desc_create_bar,
        &ogs_pfcp_tlv_desc_create_traffic_endpoint,
        &ogs_pfcp_tlv_desc_update_pdr,
        &ogs_tlv_desc_more16,
        &ogs_pfcp_tlv_desc_update_far,
        &ogs_tlv_desc_more16,
        &ogs_pfcp_tlv_desc_update_urr,
        &ogs_tlv_desc_more16,
        &ogs_pfcp_tlv_desc_update_qer,
        &ogs_tlv_desc_more4,
        &ogs_pfcp_tlv_desc_update_bar_session_modification_request,
        &ogs_pfcp_tlv_desc_update_traffic_endpoint,
        &ogs_pfcp_tlv_desc_pfcpsmreq_flags,
        &ogs_pfcp_tlv_desc_query_urr,
        &ogs_pfcp_tlv_desc_fq_csid,
        &ogs_pfcp_tlv_desc_fq_csid,
        &ogs_pfcp_tlv_desc_fq_csid,
        &ogs_pfcp_tlv_desc_fq_csid,
        &ogs_pfcp_tlv_desc_fq_csid,
        &ogs_pfcp_tlv_desc_user_plane_inactivity_timer,
        &ogs_pfcp_tlv_desc_query_urr_reference,
        &ogs_pfcp_tlv_desc_trace_information,
        &ogs_pfcp_tlv_desc_remove_mar,
        &ogs_pfcp_tlv_desc_update_mar,
        &ogs_pfcp_tlv_desc_create_mar,
        &ogs_pfcp_tlv_desc_node_id,
        &ogs_pfcp_tlv_desc_tsc_management_information_ie_within_pfcp_session_modification_request,
        &ogs_pfcp_tlv_desc_remove_srr,
        &ogs_pfcp_tlv_desc_create_srr,
        &ogs_pfcp_tlv_desc_update_srr,
        &ogs_pfcp_tlv_desc_provide_atsss_control_information,
        &ogs_pfcp_tlv_desc_ethernet_context_information,
        &ogs_pfcp_tlv_desc_access_availability_information,
        &ogs_pfcp_tlv_desc_query_packet_rate_status_ie_within_pfcp_session_modification_request,
        &ogs_pfcp_tlv_desc_s_nssai,
        &ogs_pfcp_tlv_desc_rat_type,
        &ogs_pfcp_tlv_desc_group_id,
        &ogs_pfcp_tlv_desc_mbs_session_n4_control_information,
        &ogs_pfcp_tlv_desc_dscp_to_ppi_control_information,
    NULL,
}};

ogs_tlv_desc_t ogs_pfcp_msg_desc_pfcp_session_modification_response =
{
    OGS_TLV_MESSAGE,
    "PFCP Session Modification Response",
    0, 0, 0, 0, {
        &ogs_pfcp_tlv_desc_cause,
        &ogs_pfcp_tlv_desc_offending_ie,
        &ogs_pfcp_tlv_desc_created_pdr,
        &ogs_tlv_desc_more16,
        &ogs_pfcp_tlv_desc_load_control_information,
        &ogs_pfcp_tlv_desc_overload_control_information,
        &ogs_pfcp_tlv_desc_usage_report_session_modification_response,
        &ogs_tlv_desc_more8,
        &ogs_pfcp_tlv_desc_failed_rule_id,
        &ogs_pfcp_tlv_desc_additional_usage_reports_information,
        &ogs_pfcp_tlv_desc_created_traffic_endpoint,
        &ogs_pfcp_tlv_desc_tsc_management_information_ie_within_pfcp_session_modification_request,
        &ogs_pfcp_tlv_desc_atsss_control_parameters,
        &ogs_pfcp_tlv_desc_updated_pdr,
        &ogs_pfcp_tlv_desc_packet_rate_status_report,
        &ogs_pfcp_tlv_desc_partial_failure_information,
        &ogs_pfcp_tlv_desc_mbs_session_n4_information,
    NULL,
}};

ogs_tlv_desc_t ogs_pfcp_msg_desc_pfcp_session_deletion_request =
{
    OGS_TLV_MESSAGE,
    "PFCP Session Deletion Request",
    0, 0, 0, 0, {
    NULL,
}};

ogs_tlv_desc_t ogs_pfcp_msg_desc_pfcp_session_deletion_response =
{
    OGS_TLV_MESSAGE,
    "PFCP Session Deletion Response",
    0, 0, 0, 0, {
        &ogs_pfcp_tlv_desc_cause,
        &ogs_pfcp_tlv_desc_offending_ie,
        &ogs_pfcp_tlv_desc_load_control_information,
        &ogs_pfcp_tlv_desc_overload_control_information,
        &ogs_pfcp_tlv_desc_usage_report_session_deletion_response,
        &ogs_tlv_desc_more8,
        &ogs_pfcp_tlv_desc_additional_usage_reports_information,
        &ogs_pfcp_tlv_desc_packet_rate_status_report,
        &ogs_pfcp_tlv_desc_session_report,
        &ogs_pfcp_tlv_desc_mbs_session_n4_information,
        &ogs_pfcp_tlv_desc_pfcpsdrsp_flags,
    NULL,
}};

ogs_tlv_desc_t ogs_pfcp_msg_desc_pfcp_session_report_request =
{
    OGS_TLV_MESSAGE,
    "PFCP Session Report Request",
    0, 0, 0, 0, {
        &ogs_pfcp_tlv_desc_report_type,
        &ogs_pfcp_tlv_desc_downlink_data_report,
        &ogs_pfcp_tlv_desc_usage_report_session_report_request,
        &ogs_tlv_desc_more8,
        &ogs_pfcp_tlv_desc_error_indication_report,
        &ogs_pfcp_tlv_desc_load_control_information,
        &ogs_pfcp_tlv_desc_overload_control_information,
        &ogs_pfcp_tlv_desc_additional_usage_reports_information,
        &ogs_pfcp_tlv_desc_pfcpsrreq_flags,
        &ogs_pfcp_tlv_desc_f_seid,
        &ogs_pfcp_tlv_desc_packet_rate_status_report,
        &ogs_pfcp_tlv_desc_tsc_management_information_ie_within_pfcp_session_modification_request,
        &ogs_pfcp_tlv_desc_session_report,
        &ogs_pfcp_tlv_desc_cause,
    NULL,
}};

ogs_tlv_desc_t ogs_pfcp_msg_desc_pfcp_session_report_response =
{
    OGS_TLV_MESSAGE,
    "PFCP Session Report Response",
    0, 0, 0, 0, {
        &ogs_pfcp_tlv_desc_cause,
        &ogs_pfcp_tlv_desc_offending_ie,
        &ogs_pfcp_tlv_desc_update_bar_pfcp_session_report_response,
        &ogs_pfcp_tlv_desc_pfcpsrrsp_flags,
        &ogs_pfcp_tlv_desc_f_seid,
        &ogs_pfcp_tlv_desc_f_teid,
        &ogs_pfcp_tlv_desc_alternative_smf_ip_address,
        &ogs_pfcp_tlv_desc_fq_csid,
        &ogs_pfcp_tlv_desc_group_id,
        &ogs_pfcp_tlv_desc_node_id,
    NULL,
}};


ogs_pfcp_message_t *ogs_pfcp_parse_msg(ogs_pkbuf_t *pkbuf)
{
    int rv = OGS_ERROR;
    ogs_pfcp_header_t *h = NULL;
    uint16_t size = 0;

    ogs_pfcp_message_t *pfcp_message = NULL;

    ogs_assert(pkbuf);
    ogs_assert(pkbuf->len);

    h = (ogs_pfcp_header_t *)pkbuf->data;
    ogs_assert(h);

    pfcp_message = ogs_calloc(1, sizeof(*pfcp_message));
    if (!pfcp_message) {
        ogs_error("No memory");
        return NULL;
    }

    if (h->seid_presence)
        size = OGS_PFCP_HEADER_LEN;
    else
        size = OGS_PFCP_HEADER_LEN-OGS_PFCP_SEID_LEN;

    if (ogs_pkbuf_pull(pkbuf, size) == NULL) {
        ogs_error("ogs_pkbuf_pull() failed [len:%d]", pkbuf->len);
        ogs_pfcp_message_free(pfcp_message);
        return NULL;
    }
    memcpy(&pfcp_message->h, pkbuf->data - size, size);

    if (h->seid_presence) {
        pfcp_message->h.seid = be64toh(pfcp_message->h.seid);
    } else {
        pfcp_message->h.sqn = pfcp_message->h.sqn_only;
    }

    if (pkbuf->len == 0)
        return pfcp_message;

    switch(pfcp_message->h.type)
    {
        case OGS_PFCP_HEARTBEAT_REQUEST_TYPE:
            rv = ogs_tlv_parse_msg(&pfcp_message->pfcp_heartbeat_request,
                    &ogs_pfcp_msg_desc_pfcp_heartbeat_request, pkbuf, OGS_TLV_MODE_T2_L2);
            ogs_expect(rv == OGS_OK);
            break;
        case OGS_PFCP_HEARTBEAT_RESPONSE_TYPE:
            rv = ogs_tlv_parse_msg(&pfcp_message->pfcp_heartbeat_response,
                    &ogs_pfcp_msg_desc_pfcp_heartbeat_response, pkbuf, OGS_TLV_MODE_T2_L2);
            ogs_expect(rv == OGS_OK);
            break;
        case OGS_PFCP_PFD_MANAGEMENT_REQUEST_TYPE:
            rv = ogs_tlv_parse_msg(&pfcp_message->pfcp_pfd_management_request,
                    &ogs_pfcp_msg_desc_pfcp_pfd_management_request, pkbuf, OGS_TLV_MODE_T2_L2);
            ogs_expect(rv == OGS_OK);
            break;
        case OGS_PFCP_PFD_MANAGEMENT_RESPONSE_TYPE:
            rv = ogs_tlv_parse_msg(&pfcp_message->pfcp_pfd_management_response,
                    &ogs_pfcp_msg_desc_pfcp_pfd_management_response, pkbuf, OGS_TLV_MODE_T2_L2);
            ogs_expect(rv == OGS_OK);
            break;
        case OGS_PFCP_ASSOCIATION_SETUP_REQUEST_TYPE:
            rv = ogs_tlv_parse_msg(&pfcp_message->pfcp_association_setup_request,
                    &ogs_pfcp_msg_desc_pfcp_association_setup_request, pkbuf, OGS_TLV_MODE_T2_L2);
            ogs_expect(rv == OGS_OK);
            break;
        case OGS_PFCP_ASSOCIATION_SETUP_RESPONSE_TYPE:
            rv = ogs_tlv_parse_msg(&pfcp_message->pfcp_association_setup_response,
                    &ogs_pfcp_msg_desc_pfcp_association_setup_response, pkbuf, OGS_TLV_MODE_T2_L2);
            ogs_expect(rv == OGS_OK);
            break;
        case OGS_PFCP_ASSOCIATION_UPDATE_REQUEST_TYPE:
            rv = ogs_tlv_parse_msg(&pfcp_message->pfcp_association_update_request,
                    &ogs_pfcp_msg_desc_pfcp_association_update_request, pkbuf, OGS_TLV_MODE_T2_L2);
            ogs_expect(rv == OGS_OK);
            break;
        case OGS_PFCP_ASSOCIATION_UPDATE_RESPONSE_TYPE:
            rv = ogs_tlv_parse_msg(&pfcp_message->pfcp_association_update_response,
                    &ogs_pfcp_msg_desc_pfcp_association_update_response, pkbuf, OGS_TLV_MODE_T2_L2);
            ogs_expect(rv == OGS_OK);
            break;
        case OGS_PFCP_ASSOCIATION_RELEASE_REQUEST_TYPE:
            rv = ogs_tlv_parse_msg(&pfcp_message->pfcp_association_release_request,
                    &ogs_pfcp_msg_desc_pfcp_association_release_request, pkbuf, OGS_TLV_MODE_T2_L2);
            ogs_expect(rv == OGS_OK);
            break;
        case OGS_PFCP_ASSOCIATION_RELEASE_RESPONSE_TYPE:
            rv = ogs_tlv_parse_msg(&pfcp_message->pfcp_association_release_response,
                    &ogs_pfcp_msg_desc_pfcp_association_release_response, pkbuf, OGS_TLV_MODE_T2_L2);
            ogs_expect(rv == OGS_OK);
            break;
        case OGS_PFCP_VERSION_NOT_SUPPORTED_RESPONSE_TYPE:
            break;
        case OGS_PFCP_NODE_REPORT_REQUEST_TYPE:
            rv = ogs_tlv_parse_msg(&pfcp_message->pfcp_node_report_request,
                    &ogs_pfcp_msg_desc_pfcp_node_report_request, pkbuf, OGS_TLV_MODE_T2_L2);
            ogs_expect(rv == OGS_OK);
            break;
        case OGS_PFCP_NODE_REPORT_RESPONSE_TYPE:
            rv = ogs_tlv_parse_msg(&pfcp_message->pfcp_node_report_response,
                    &ogs_pfcp_msg_desc_pfcp_node_report_response, pkbuf, OGS_TLV_MODE_T2_L2);
            ogs_expect(rv == OGS_OK);
            break;
        case OGS_PFCP_SESSION_SET_DELETION_REQUEST_TYPE:
            rv = ogs_tlv_parse_msg(&pfcp_message->pfcp_session_set_deletion_request,
                    &ogs_pfcp_msg_desc_pfcp_session_set_deletion_request, pkbuf, OGS_TLV_MODE_T2_L2);
            ogs_expect(rv == OGS_OK);
            break;
        case OGS_PFCP_SESSION_SET_DELETION_RESPONSE_TYPE:
            rv = ogs_tlv_parse_msg(&pfcp_message->pfcp_session_set_deletion_response,
                    &ogs_pfcp_msg_desc_pfcp_session_set_deletion_response, pkbuf, OGS_TLV_MODE_T2_L2);
            ogs_expect(rv == OGS_OK);
            break;
        case OGS_PFCP_SESSION_SET_MODIFICATION_REQUEST_TYPE:
            rv = ogs_tlv_parse_msg(&pfcp_message->pfcp_session_set_modification_request,
                    &ogs_pfcp_msg_desc_pfcp_session_set_modification_request, pkbuf, OGS_TLV_MODE_T2_L2);
            ogs_expect(rv == OGS_OK);
            break;
        case OGS_PFCP_SESSION_SET_MODIFICATION_RESPONSE_TYPE:
            rv = ogs_tlv_parse_msg(&pfcp_message->pfcp_session_set_modification_response,
                    &ogs_pfcp_msg_desc_pfcp_session_set_modification_response, pkbuf, OGS_TLV_MODE_T2_L2);
            ogs_expect(rv == OGS_OK);
            break;
        case OGS_PFCP_SESSION_ESTABLISHMENT_REQUEST_TYPE:
            rv = ogs_tlv_parse_msg(&pfcp_message->pfcp_session_establishment_request,
                    &ogs_pfcp_msg_desc_pfcp_session_establishment_request, pkbuf, OGS_TLV_MODE_T2_L2);
            ogs_expect(rv == OGS_OK);
            break;
        case OGS_PFCP_SESSION_ESTABLISHMENT_RESPONSE_TYPE:
            rv = ogs_tlv_parse_msg(&pfcp_message->pfcp_session_establishment_response,
                    &ogs_pfcp_msg_desc_pfcp_session_establishment_response, pkbuf, OGS_TLV_MODE_T2_L2);
            ogs_expect(rv == OGS_OK);
            break;
        case OGS_PFCP_SESSION_MODIFICATION_REQUEST_TYPE:
            rv = ogs_tlv_parse_msg(&pfcp_message->pfcp_session_modification_request,
                    &ogs_pfcp_msg_desc_pfcp_session_modification_request, pkbuf, OGS_TLV_MODE_T2_L2);
            ogs_expect(rv == OGS_OK);
            break;
        case OGS_PFCP_SESSION_MODIFICATION_RESPONSE_TYPE:
            rv = ogs_tlv_parse_msg(&pfcp_message->pfcp_session_modification_response,
                    &ogs_pfcp_msg_desc_pfcp_session_modification_response, pkbuf, OGS_TLV_MODE_T2_L2);
            ogs_expect(rv == OGS_OK);
            break;
        case OGS_PFCP_SESSION_DELETION_REQUEST_TYPE:
            break;
        case OGS_PFCP_SESSION_DELETION_RESPONSE_TYPE:
            rv = ogs_tlv_parse_msg(&pfcp_message->pfcp_session_deletion_response,
                    &ogs_pfcp_msg_desc_pfcp_session_deletion_response, pkbuf, OGS_TLV_MODE_T2_L2);
            ogs_expect(rv == OGS_OK);
            break;
        case OGS_PFCP_SESSION_REPORT_REQUEST_TYPE:
            rv = ogs_tlv_parse_msg(&pfcp_message->pfcp_session_report_request,
                    &ogs_pfcp_msg_desc_pfcp_session_report_request, pkbuf, OGS_TLV_MODE_T2_L2);
            ogs_expect(rv == OGS_OK);
            break;
        case OGS_PFCP_SESSION_REPORT_RESPONSE_TYPE:
            rv = ogs_tlv_parse_msg(&pfcp_message->pfcp_session_report_response,
                    &ogs_pfcp_msg_desc_pfcp_session_report_response, pkbuf, OGS_TLV_MODE_T2_L2);
            ogs_expect(rv == OGS_OK);
            break;
        default:
            ogs_warn("Not implemented(type:%d)", pfcp_message->h.type);
            break;
    }

    if (rv != OGS_OK) {
        ogs_pfcp_message_free(pfcp_message);
        return NULL;
    }

    return pfcp_message;
}

void ogs_pfcp_message_free(ogs_pfcp_message_t *pfcp_message)
{
    ogs_assert(pfcp_message);
    ogs_free(pfcp_message);
}

ogs_pkbuf_t *ogs_pfcp_build_msg(ogs_pfcp_message_t *pfcp_message)
{
    ogs_pkbuf_t *pkbuf = NULL;

    ogs_assert(pfcp_message);
    switch(pfcp_message->h.type)
    {
        case OGS_PFCP_HEARTBEAT_REQUEST_TYPE:
            pkbuf = ogs_tlv_build_msg(&ogs_pfcp_msg_desc_pfcp_heartbeat_request,
                    &pfcp_message->pfcp_heartbeat_request, OGS_TLV_MODE_T2_L2);
            break;
        case OGS_PFCP_HEARTBEAT_RESPONSE_TYPE:
            pkbuf = ogs_tlv_build_msg(&ogs_pfcp_msg_desc_pfcp_heartbeat_response,
                    &pfcp_message->pfcp_heartbeat_response, OGS_TLV_MODE_T2_L2);
            break;
        case OGS_PFCP_PFD_MANAGEMENT_REQUEST_TYPE:
            pkbuf = ogs_tlv_build_msg(&ogs_pfcp_msg_desc_pfcp_pfd_management_request,
                    &pfcp_message->pfcp_pfd_management_request, OGS_TLV_MODE_T2_L2);
            break;
        case OGS_PFCP_PFD_MANAGEMENT_RESPONSE_TYPE:
            pkbuf = ogs_tlv_build_msg(&ogs_pfcp_msg_desc_pfcp_pfd_management_response,
                    &pfcp_message->pfcp_pfd_management_response, OGS_TLV_MODE_T2_L2);
            break;
        case OGS_PFCP_ASSOCIATION_SETUP_REQUEST_TYPE:
            pkbuf = ogs_tlv_build_msg(&ogs_pfcp_msg_desc_pfcp_association_setup_request,
                    &pfcp_message->pfcp_association_setup_request, OGS_TLV_MODE_T2_L2);
            break;
        case OGS_PFCP_ASSOCIATION_SETUP_RESPONSE_TYPE:
            pkbuf = ogs_tlv_build_msg(&ogs_pfcp_msg_desc_pfcp_association_setup_response,
                    &pfcp_message->pfcp_association_setup_response, OGS_TLV_MODE_T2_L2);
            break;
        case OGS_PFCP_ASSOCIATION_UPDATE_REQUEST_TYPE:
            pkbuf = ogs_tlv_build_msg(&ogs_pfcp_msg_desc_pfcp_association_update_request,
                    &pfcp_message->pfcp_association_update_request, OGS_TLV_MODE_T2_L2);
            break;
        case OGS_PFCP_ASSOCIATION_UPDATE_RESPONSE_TYPE:
            pkbuf = ogs_tlv_build_msg(&ogs_pfcp_msg_desc_pfcp_association_update_response,
                    &pfcp_message->pfcp_association_update_response, OGS_TLV_MODE_T2_L2);
            break;
        case OGS_PFCP_ASSOCIATION_RELEASE_REQUEST_TYPE:
            pkbuf = ogs_tlv_build_msg(&ogs_pfcp_msg_desc_pfcp_association_release_request,
                    &pfcp_message->pfcp_association_release_request, OGS_TLV_MODE_T2_L2);
            break;
        case OGS_PFCP_ASSOCIATION_RELEASE_RESPONSE_TYPE:
            pkbuf = ogs_tlv_build_msg(&ogs_pfcp_msg_desc_pfcp_association_release_response,
                    &pfcp_message->pfcp_association_release_response, OGS_TLV_MODE_T2_L2);
            break;
        case OGS_PFCP_VERSION_NOT_SUPPORTED_RESPONSE_TYPE:
            pkbuf = ogs_tlv_build_msg(&ogs_pfcp_msg_desc_pfcp_version_not_supported_response,
                    &pfcp_message->pfcp_version_not_supported_response, OGS_TLV_MODE_T2_L2);
            break;
        case OGS_PFCP_NODE_REPORT_REQUEST_TYPE:
            pkbuf = ogs_tlv_build_msg(&ogs_pfcp_msg_desc_pfcp_node_report_request,
                    &pfcp_message->pfcp_node_report_request, OGS_TLV_MODE_T2_L2);
            break;
        case OGS_PFCP_NODE_REPORT_RESPONSE_TYPE:
            pkbuf = ogs_tlv_build_msg(&ogs_pfcp_msg_desc_pfcp_node_report_response,
                    &pfcp_message->pfcp_node_report_response, OGS_TLV_MODE_T2_L2);
            break;
        case OGS_PFCP_SESSION_SET_DELETION_REQUEST_TYPE:
            pkbuf = ogs_tlv_build_msg(&ogs_pfcp_msg_desc_pfcp_session_set_deletion_request,
                    &pfcp_message->pfcp_session_set_deletion_request, OGS_TLV_MODE_T2_L2);
            break;
        case OGS_PFCP_SESSION_SET_DELETION_RESPONSE_TYPE:
            pkbuf = ogs_tlv_build_msg(&ogs_pfcp_msg_desc_pfcp_session_set_deletion_response,
                    &pfcp_message->pfcp_session_set_deletion_response, OGS_TLV_MODE_T2_L2);
            break;
        case OGS_PFCP_SESSION_SET_MODIFICATION_REQUEST_TYPE:
            pkbuf = ogs_tlv_build_msg(&ogs_pfcp_msg_desc_pfcp_session_set_modification_request,
                    &pfcp_message->pfcp_session_set_modification_request, OGS_TLV_MODE_T2_L2);
            break;
        case OGS_PFCP_SESSION_SET_MODIFICATION_RESPONSE_TYPE:
            pkbuf = ogs_tlv_build_msg(&ogs_pfcp_msg_desc_pfcp_session_set_modification_response,
                    &pfcp_message->pfcp_session_set_modification_response, OGS_TLV_MODE_T2_L2);
            break;
        case OGS_PFCP_SESSION_ESTABLISHMENT_REQUEST_TYPE:
            pkbuf = ogs_tlv_build_msg(&ogs_pfcp_msg_desc_pfcp_session_establishment_request,
                    &pfcp_message->pfcp_session_establishment_request, OGS_TLV_MODE_T2_L2);
            break;
        case OGS_PFCP_SESSION_ESTABLISHMENT_RESPONSE_TYPE:
            pkbuf = ogs_tlv_build_msg(&ogs_pfcp_msg_desc_pfcp_session_establishment_response,
                    &pfcp_message->pfcp_session_establishment_response, OGS_TLV_MODE_T2_L2);
            break;
        case OGS_PFCP_SESSION_MODIFICATION_REQUEST_TYPE:
            pkbuf = ogs_tlv_build_msg(&ogs_pfcp_msg_desc_pfcp_session_modification_request,
                    &pfcp_message->pfcp_session_modification_request, OGS_TLV_MODE_T2_L2);
            break;
        case OGS_PFCP_SESSION_MODIFICATION_RESPONSE_TYPE:
            pkbuf = ogs_tlv_build_msg(&ogs_pfcp_msg_desc_pfcp_session_modification_response,
                    &pfcp_message->pfcp_session_modification_response, OGS_TLV_MODE_T2_L2);
            break;
        case OGS_PFCP_SESSION_DELETION_REQUEST_TYPE:
            pkbuf = ogs_tlv_build_msg(&ogs_pfcp_msg_desc_pfcp_session_deletion_request,
                    &pfcp_message->pfcp_session_deletion_request, OGS_TLV_MODE_T2_L2);
            break;
        case OGS_PFCP_SESSION_DELETION_RESPONSE_TYPE:
            pkbuf = ogs_tlv_build_msg(&ogs_pfcp_msg_desc_pfcp_session_deletion_response,
                    &pfcp_message->pfcp_session_deletion_response, OGS_TLV_MODE_T2_L2);
            break;
        case OGS_PFCP_SESSION_REPORT_REQUEST_TYPE:
            pkbuf = ogs_tlv_build_msg(&ogs_pfcp_msg_desc_pfcp_session_report_request,
                    &pfcp_message->pfcp_session_report_request, OGS_TLV_MODE_T2_L2);
            break;
        case OGS_PFCP_SESSION_REPORT_RESPONSE_TYPE:
            pkbuf = ogs_tlv_build_msg(&ogs_pfcp_msg_desc_pfcp_session_report_response,
                    &pfcp_message->pfcp_session_report_response, OGS_TLV_MODE_T2_L2);
            break;
        default:
            ogs_warn("Not implemented(type:%d)", pfcp_message->h.type);
            break;
    }

    return pkbuf;
}

===== message.h =====

/*******************************************************************************
 * This file had been created by pfcp-tlv.py script v0.1.0
 * Please do not modify this file but regenerate it via script.
 * Created on: 2024-10-20 22:37:02.530796 by acetcom
 * from 29244-h71-modified.docx
 ******************************************************************************/

#if !defined(OGS_PFCP_INSIDE) && !defined(OGS_PFCP_COMPILATION)
#error "This header cannot be included directly."
#endif

#ifndef OGS_PFCP_MESSAGE_H
#define OGS_PFCP_MESSAGE_H

#ifdef __cplusplus
extern "C" {
#endif

/* 5.1 General format */
#define OGS_PFCP_HEADER_LEN 16
#define OGS_PFCP_SEID_LEN   8
typedef struct ogs_pfcp_header_s {
    union {
        struct {
        ED4(uint8_t version:3;,
            uint8_t spare1:3;,
            uint8_t mp:1;,
            uint8_t seid_presence:1;)
        };
        uint8_t flags;
    };
    uint8_t type;
    uint16_t length;
    union {
        struct {
            uint64_t seid;
            /* sqn : 31bit ~ 8bit, spare : 7bit ~ 0bit */
#define OGS_PFCP_XID_TO_SQN(__xid) htobe32(((__xid) << 8))
#define OGS_PFCP_SQN_TO_XID(__sqn) (be32toh(__sqn) >> 8)
            uint32_t sqn;
        };
        /* sqn : 31bit ~ 8bit, spare : 7bit ~ 0bit */
        uint32_t sqn_only;
    };
} __attribute__ ((packed)) ogs_pfcp_header_t;

/* PFCP message type */
#define OGS_PFCP_HEARTBEAT_REQUEST_TYPE 1
#define OGS_PFCP_HEARTBEAT_RESPONSE_TYPE 2
#define OGS_PFCP_PFD_MANAGEMENT_REQUEST_TYPE 3
#define OGS_PFCP_PFD_MANAGEMENT_RESPONSE_TYPE 4
#define OGS_PFCP_ASSOCIATION_SETUP_REQUEST_TYPE 5
#define OGS_PFCP_ASSOCIATION_SETUP_RESPONSE_TYPE 6
#define OGS_PFCP_ASSOCIATION_UPDATE_REQUEST_TYPE 7
#define OGS_PFCP_ASSOCIATION_UPDATE_RESPONSE_TYPE 8
#define OGS_PFCP_ASSOCIATION_RELEASE_REQUEST_TYPE 9
#define OGS_PFCP_ASSOCIATION_RELEASE_RESPONSE_TYPE 10
#define OGS_PFCP_VERSION_NOT_SUPPORTED_RESPONSE_TYPE 11
#define OGS_PFCP_NODE_REPORT_REQUEST_TYPE 12
#define OGS_PFCP_NODE_REPORT_RESPONSE_TYPE 13
#define OGS_PFCP_SESSION_SET_DELETION_REQUEST_TYPE 14
#define OGS_PFCP_SESSION_SET_DELETION_RESPONSE_TYPE 15
#define OGS_PFCP_SESSION_SET_MODIFICATION_REQUEST_TYPE 16
#define OGS_PFCP_SESSION_SET_MODIFICATION_RESPONSE_TYPE 17
#define OGS_PFCP_SESSION_ESTABLISHMENT_REQUEST_TYPE 50
#define OGS_PFCP_SESSION_ESTABLISHMENT_RESPONSE_TYPE 51
#define OGS_PFCP_SESSION_MODIFICATION_REQUEST_TYPE 52
#define OGS_PFCP_SESSION_MODIFICATION_RESPONSE_TYPE 53
#define OGS_PFCP_SESSION_DELETION_REQUEST_TYPE 54
#define OGS_PFCP_SESSION_DELETION_RESPONSE_TYPE 55
#define OGS_PFCP_SESSION_REPORT_REQUEST_TYPE 56
#define OGS_PFCP_SESSION_REPORT_RESPONSE_TYPE 57

#define OGS_PFCP_CREATE_PDR_TYPE 1
#define OGS_PFCP_PDI_TYPE 2
#define OGS_PFCP_CREATE_FAR_TYPE 3
#define OGS_PFCP_FORWARDING_PARAMETERS_TYPE 4
#define OGS_PFCP_DUPLICATING_PARAMETERS_TYPE 5
#define OGS_PFCP_CREATE_URR_TYPE 6
#define OGS_PFCP_CREATE_QER_TYPE 7
#define OGS_PFCP_CREATED_PDR_TYPE 8
#define OGS_PFCP_UPDATE_PDR_TYPE 9
#define OGS_PFCP_UPDATE_FAR_TYPE 10
#define OGS_PFCP_UPDATE_FORWARDING_PARAMETERS_TYPE 11
#define OGS_PFCP_UPDATE_BAR_PFCP_SESSION_REPORT_RESPONSE_TYPE 12
#define OGS_PFCP_UPDATE_URR_TYPE 13
#define OGS_PFCP_UPDATE_QER_TYPE 14
#define OGS_PFCP_REMOVE_PDR_TYPE 15
#define OGS_PFCP_REMOVE_FAR_TYPE 16
#define OGS_PFCP_REMOVE_URR_TYPE 17
#define OGS_PFCP_REMOVE_QER_TYPE 18
#define OGS_PFCP_CAUSE_TYPE 19
#define OGS_PFCP_SOURCE_INTERFACE_TYPE 20
#define OGS_PFCP_F_TEID_TYPE 21
#define OGS_PFCP_NETWORK_INSTANCE_TYPE 22
#define OGS_PFCP_SDF_FILTER_TYPE 23
#define OGS_PFCP_APPLICATION_ID_TYPE 24
#define OGS_PFCP_GATE_STATUS_TYPE 25
#define OGS_PFCP_MBR_TYPE 26
#define OGS_PFCP_GBR_TYPE 27
#define OGS_PFCP_QER_CORRELATION_ID_TYPE 28
#define OGS_PFCP_PRECEDENCE_TYPE 29
#define OGS_PFCP_TRANSPORT_LEVEL_MARKING_TYPE 30
#define OGS_PFCP_VOLUME_THRESHOLD_TYPE 31
#define OGS_PFCP_TIME_THRESHOLD_TYPE 32
#define OGS_PFCP_MONITORING_TIME_TYPE 33
#define OGS_PFCP_SUBSEQUENT_VOLUME_THRESHOLD_TYPE 34
#define OGS_PFCP_SUBSEQUENT_TIME_THRESHOLD_TYPE 35
#define OGS_PFCP_INACTIVITY_DETECTION_TIME_TYPE 36
#define OGS_PFCP_REPORTING_TRIGGERS_TYPE 37
#define OGS_PFCP_REDIRECT_INFORMATION_TYPE 38
#define OGS_PFCP_REPORT_TYPE_TYPE 39
#define OGS_PFCP_OFFENDING_IE_TYPE 40
#define OGS_PFCP_FORWARDING_POLICY_TYPE 41
#define OGS_PFCP_DESTINATION_INTERFACE_TYPE 42
#define OGS_PFCP_UP_FUNCTION_FEATURES_TYPE 43
#define OGS_PFCP_APPLY_ACTION_TYPE 44
#define OGS_PFCP_DOWNLINK_DATA_SERVICE_INFORMATION_TYPE 45
#define OGS_PFCP_DOWNLINK_DATA_NOTIFICATION_DELAY_TYPE 46
#define OGS_PFCP_DL_BUFFERING_DURATION_TYPE 47
#define OGS_PFCP_DL_BUFFERING_SUGGESTED_PACKET_COUNT_TYPE 48
#define OGS_PFCP_PFCPSMREQ_FLAGS_TYPE 49
#define OGS_PFCP_PFCPSRRSP_FLAGS_TYPE 50
#define OGS_PFCP_LOAD_CONTROL_INFORMATION_TYPE 51
#define OGS_PFCP_SEQUENCE_NUMBER_TYPE 52
#define OGS_PFCP_METRIC_TYPE 53
#define OGS_PFCP_OVERLOAD_CONTROL_INFORMATION_TYPE 54
#define OGS_PFCP_TIMER_TYPE 55
#define OGS_PFCP_PDR_ID_TYPE 56
#define OGS_PFCP_F_SEID_TYPE 57
#define OGS_PFCP_APPLICATION_ID_S_PFDS_TYPE 58
#define OGS_PFCP_PFD_CONTEXT_TYPE 59
#define OGS_PFCP_NODE_ID_TYPE 60
#define OGS_PFCP_PFD_CONTENTS_TYPE 61
#define OGS_PFCP_MEASUREMENT_METHOD_TYPE 62
#define OGS_PFCP_USAGE_REPORT_TRIGGER_TYPE 63
#define OGS_PFCP_MEASUREMENT_PERIOD_TYPE 64
#define OGS_PFCP_FQ_CSID_TYPE 65
#define OGS_PFCP_VOLUME_MEASUREMENT_TYPE 66
#define OGS_PFCP_DURATION_MEASUREMENT_TYPE 67
#define OGS_PFCP_APPLICATION_DETECTION_INFORMATION_TYPE 68
#define OGS_PFCP_TIME_OF_FIRST_PACKET_TYPE 69
#define OGS_PFCP_TIME_OF_LAST_PACKET_TYPE 70
#define OGS_PFCP_QUOTA_HOLDING_TIME_TYPE 71
#define OGS_PFCP_DROPPED_DL_TRAFFIC_THRESHOLD_TYPE 72
#define OGS_PFCP_VOLUME_QUOTA_TYPE 73
#define OGS_PFCP_TIME_QUOTA_TYPE 74
#define OGS_PFCP_START_TIME_TYPE 75
#define OGS_PFCP_END_TIME_TYPE 76
#define OGS_PFCP_QUERY_URR_TYPE 77
#define OGS_PFCP_USAGE_REPORT_SESSION_MODIFICATION_RESPONSE_TYPE 78
#define OGS_PFCP_USAGE_REPORT_SESSION_DELETION_RESPONSE_TYPE 79
#define OGS_PFCP_USAGE_REPORT_SESSION_REPORT_REQUEST_TYPE 80
#define OGS_PFCP_URR_ID_TYPE 81
#define OGS_PFCP_LINKED_URR_ID_TYPE 82
#define OGS_PFCP_DOWNLINK_DATA_REPORT_TYPE 83
#define OGS_PFCP_OUTER_HEADER_CREATION_TYPE 84
#define OGS_PFCP_CREATE_BAR_TYPE 85
#define OGS_PFCP_UPDATE_BAR_SESSION_MODIFICATION_REQUEST_TYPE 86
#define OGS_PFCP_REMOVE_BAR_TYPE 87
#define OGS_PFCP_BAR_ID_TYPE 88
#define OGS_PFCP_CP_FUNCTION_FEATURES_TYPE 89
#define OGS_PFCP_USAGE_INFORMATION_TYPE 90
#define OGS_PFCP_APPLICATION_INSTANCE_ID_TYPE 91
#define OGS_PFCP_FLOW_INFORMATION_TYPE 92
#define OGS_PFCP_UE_IP_ADDRESS_TYPE 93
#define OGS_PFCP_PACKET_RATE_TYPE 94
#define OGS_PFCP_OUTER_HEADER_REMOVAL_TYPE 95
#define OGS_PFCP_RECOVERY_TIME_STAMP_TYPE 96
#define OGS_PFCP_DL_FLOW_LEVEL_MARKING_TYPE 97
#define OGS_PFCP_HEADER_ENRICHMENT_TYPE 98
#define OGS_PFCP_ERROR_INDICATION_REPORT_TYPE 99
#define OGS_PFCP_MEASUREMENT_INFORMATION_TYPE 100
#define OGS_PFCP_NODE_REPORT_TYPE_TYPE 101
#define OGS_PFCP_USER_PLANE_PATH_FAILURE_REPORT_TYPE 102
#define OGS_PFCP_REMOTE_GTP_U_PEER_TYPE 103
#define OGS_PFCP_UR_SEQN_TYPE 104
#define OGS_PFCP_UPDATE_DUPLICATING_PARAMETERS_TYPE 105
#define OGS_PFCP_ACTIVATE_PREDEFINED_RULES_TYPE 106
#define OGS_PFCP_DEACTIVATE_PREDEFINED_RULES_TYPE 107
#define OGS_PFCP_FAR_ID_TYPE 108
#define OGS_PFCP_QER_ID_TYPE 109
#define OGS_PFCP_OCI_FLAGS_TYPE 110
#define OGS_PFCP_PFCP_ASSOCIATION_RELEASE_REQUEST_TYPE 111
#define OGS_PFCP_GRACEFUL_RELEASE_PERIOD_TYPE 112
#define OGS_PFCP_PDN_TYPE_TYPE 113
#define OGS_PFCP_FAILED_RULE_ID_TYPE 114
#define OGS_PFCP_TIME_QUOTA_MECHANISM_TYPE 115
#define OGS_PFCP_USER_PLANE_IP_RESOURCE_INFORMATION_TYPE 116
#define OGS_PFCP_USER_PLANE_INACTIVITY_TIMER_TYPE 117
#define OGS_PFCP_AGGREGATED_URRS_TYPE 118
#define OGS_PFCP_MULTIPLIER_TYPE 119
#define OGS_PFCP_AGGREGATED_URR_ID_TYPE 120
#define OGS_PFCP_SUBSEQUENT_VOLUME_QUOTA_TYPE 121
#define OGS_PFCP_SUBSEQUENT_TIME_QUOTA_TYPE 122
#define OGS_PFCP_RQI_TYPE 123
#define OGS_PFCP_QFI_TYPE 124
#define OGS_PFCP_QUERY_URR_REFERENCE_TYPE 125
#define OGS_PFCP_ADDITIONAL_USAGE_REPORTS_INFORMATION_TYPE 126
#define OGS_PFCP_CREATE_TRAFFIC_ENDPOINT_TYPE 127
#define OGS_PFCP_CREATED_TRAFFIC_ENDPOINT_TYPE 128
#define OGS_PFCP_UPDATE_TRAFFIC_ENDPOINT_TYPE 129
#define OGS_PFCP_REMOVE_TRAFFIC_ENDPOINT_TYPE 130
#define OGS_PFCP_TRAFFIC_ENDPOINT_ID_TYPE 131
#define OGS_PFCP_ETHERNET_PACKET_FILTER_TYPE 132
#define OGS_PFCP_MAC_ADDRESS_TYPE 133
#define OGS_PFCP_C_TAG_TYPE 134
#define OGS_PFCP_S_TAG_TYPE 135
#define OGS_PFCP_ETHERTYPE_TYPE 136
#define OGS_PFCP_PROXYING_TYPE 137
#define OGS_PFCP_ETHERNET_FILTER_ID_TYPE 138
#define OGS_PFCP_ETHERNET_FILTER_PROPERTIES_TYPE 139
#define OGS_PFCP_SUGGESTED_BUFFERING_PACKETS_COUNT_TYPE 140
#define OGS_PFCP_USER_ID_TYPE 141
#define OGS_PFCP_ETHERNET_PDU_SESSION_INFORMATION_TYPE 142
#define OGS_PFCP_ETHERNET_TRAFFIC_INFORMATION_TYPE 143
#define OGS_PFCP_MAC_ADDRESSES_DETECTED_TYPE 144
#define OGS_PFCP_MAC_ADDRESSES_REMOVED_TYPE 145
#define OGS_PFCP_ETHERNET_INACTIVITY_TIMER_TYPE 146
#define OGS_PFCP_ADDITIONAL_MONITORING_TIME_TYPE 147
#define OGS_PFCP_EVENT_QUOTA_TYPE 148
#define OGS_PFCP_EVENT_THRESHOLD_TYPE 149
#define OGS_PFCP_SUBSEQUENT_EVENT_QUOTA_TYPE 150
#define OGS_PFCP_SUBSEQUENT_EVENT_THRESHOLD_TYPE 151
#define OGS_PFCP_TRACE_INFORMATION_TYPE 152
#define OGS_PFCP_FRAMED_ROUTE_TYPE 153
#define OGS_PFCP_FRAMED_ROUTING_TYPE 154
#define OGS_PFCP_FRAMED_IPV6_ROUTE_TYPE 155
#define OGS_PFCP_TIME_STAMP_TYPE 156
#define OGS_PFCP_AVERAGING_WINDOW_TYPE 157
#define OGS_PFCP_PAGING_POLICY_INDICATOR_TYPE 158
#define OGS_PFCP_APN_DNN_TYPE 159
#define OGS_PFCP__INTERFACE_TYPE_TYPE 160
#define OGS_PFCP_PFCPSRREQ_FLAGS_TYPE 161
#define OGS_PFCP_PFCPAUREQ_FLAGS_TYPE 162
#define OGS_PFCP_ACTIVATION_TIME_TYPE 163
#define OGS_PFCP_DEACTIVATION_TIME_TYPE 164
#define OGS_PFCP_CREATE_MAR_TYPE 165
#define OGS_PFCP__ACCESS_FORWARDING_ACTION_INFORMATION_TYPE 166
#define OGS_PFCP_NON__ACCESS_FORWARDING_ACTION_INFORMATION_TYPE 167
#define OGS_PFCP_REMOVE_MAR_TYPE 168
#define OGS_PFCP_UPDATE_MAR_TYPE 169
#define OGS_PFCP_MAR_ID_TYPE 170
#define OGS_PFCP_STEERING_FUNCTIONALITY_TYPE 171
#define OGS_PFCP_STEERING_MODE_TYPE 172
#define OGS_PFCP_WEIGHT_TYPE 173
#define OGS_PFCP_PRIORITY_TYPE 174
#define OGS_PFCP_UPDATE__ACCESS_FORWARDING_ACTION_INFORMATION_TYPE 175
#define OGS_PFCP_UPDATE_NON__ACCESS_FORWARDING_ACTION_INFORMATION_TYPE 176
#define OGS_PFCP_UE_IP_ADDRESS_POOL_IDENTITY_TYPE 177
#define OGS_PFCP_ALTERNATIVE_SMF_IP_ADDRESS_TYPE 178
#define OGS_PFCP_PACKET_REPLICATION_AND_DETECTION_CARRY_ON_INFORMATION_TYPE 179
#define OGS_PFCP_SMF_SET_ID_TYPE 180
#define OGS_PFCP_QUOTA_VALIDITY_TIME_TYPE 181
#define OGS_PFCP_NUMBER_OF_REPORTS_TYPE 182
#define OGS_PFCP_PFCP_SESSION_RETENTION_INFORMATION_WITHIN_PFCP_ASSOCIATION_SETUP_REQUEST_TYPE 183
#define OGS_PFCP_PFCPASRSP_FLAGS_TYPE 184
#define OGS_PFCP_CP_PFCP_ENTITY_IP_ADDRESS_TYPE 185
#define OGS_PFCP_PFCPSEREQ_FLAGS_TYPE 186
#define OGS_PFCP_USER_PLANE_PATH_RECOVERY_REPORT_TYPE 187
#define OGS_PFCP_IP_MULTICAST_ADDRESSING_INFO_WITHIN_PFCP_SESSION_ESTABLISHMENT_REQUEST_TYPE 188
#define OGS_PFCP_JOIN_IP_MULTICAST_INFORMATION_IE_WITHIN_USAGE_REPORT_TYPE 189
#define OGS_PFCP_LEAVE_IP_MULTICAST_INFORMATION_IE_WITHIN_USAGE_REPORT_TYPE 190
#define OGS_PFCP_IP_MULTICAST_ADDRESS_TYPE 191
#define OGS_PFCP_SOURCE_IP_ADDRESS_TYPE 192
#define OGS_PFCP_PACKET_RATE_STATUS_TYPE 193
#define OGS_PFCP_CREATE_BRIDGE_INFO_FOR_TSC_TYPE 194
#define OGS_PFCP_CREATED_BRIDGE_INFO_FOR_TSC_TYPE 195
#define OGS_PFCP_DS_TT_PORT_NUMBER_TYPE 196
#define OGS_PFCP_NW_TT_PORT_NUMBER_TYPE 197
#define OGS_PFCP_FiveGS_USER_PLANE_NODE_TYPE 198
#define OGS_PFCP_TSC_MANAGEMENT_INFORMATION_IE_WITHIN_PFCP_SESSION_MODIFICATION_REQUEST_TYPE 199
#define OGS_PFCP_TSC_MANAGEMENT_INFORMATION_IE_WITHIN_PFCP_SESSION_MODIFICATION_RESPONSE_TYPE 200
#define OGS_PFCP_TSC_MANAGEMENT_INFORMATION_IE_WITHIN_PFCP_SESSION_REPORT_REQUEST_TYPE 201
#define OGS_PFCP_PORT_MANAGEMENT_INFORMATION_CONTAINER_TYPE 202
#define OGS_PFCP_CLOCK_DRIFT_CONTROL_INFORMATION_TYPE 203
#define OGS_PFCP_REQUESTED_CLOCK_DRIFT_INFORMATION_TYPE 204
#define OGS_PFCP_CLOCK_DRIFT_REPORT_TYPE 205
#define OGS_PFCP_TIME_DOMAIN_NUMBER_TYPE 206
#define OGS_PFCP_TIME_OFFSET_THRESHOLD_TYPE 207
#define OGS_PFCP_CUMULATIVE_RATERATIO_THRESHOLD_TYPE 208
#define OGS_PFCP_TIME_OFFSET_MEASUREMENT_TYPE 209
#define OGS_PFCP_CUMULATIVE_RATERATIO_MEASUREMENT_TYPE 210
#define OGS_PFCP_REMOVE_SRR_TYPE 211
#define OGS_PFCP_CREATE_SRR_TYPE 212
#define OGS_PFCP_UPDATE_SRR_TYPE 213
#define OGS_PFCP_SESSION_REPORT_TYPE 214
#define OGS_PFCP_SRR_ID_TYPE 215
#define OGS_PFCP_ACCESS_AVAILABILITY_CONTROL_INFORMATION_TYPE 216
#define OGS_PFCP_REQUESTED_ACCESS_AVAILABILITY_INFORMATION_TYPE 217
#define OGS_PFCP_ACCESS_AVAILABILITY_REPORT_TYPE 218
#define OGS_PFCP_ACCESS_AVAILABILITY_INFORMATION_TYPE 219
#define OGS_PFCP_PROVIDE_ATSSS_CONTROL_INFORMATION_TYPE 220
#define OGS_PFCP_ATSSS_CONTROL_PARAMETERS_TYPE 221
#define OGS_PFCP_MPTCP_CONTROL_INFORMATION_TYPE 222
#define OGS_PFCP_ATSSS_LL_CONTROL_INFORMATION_TYPE 223
#define OGS_PFCP_PMF_CONTROL_INFORMATION_TYPE 224
#define OGS_PFCP_MPTCP_PARAMETERS_TYPE 225
#define OGS_PFCP_ATSSS_LL_PARAMETERS_TYPE 226
#define OGS_PFCP_PMF_PARAMETERS_TYPE 227
#define OGS_PFCP_MPTCP_ADDRESS_INFORMATION_TYPE 228
#define OGS_PFCP_UE_LINK_SPECIFIC_IP_ADDRESS_TYPE 229
#define OGS_PFCP_PMF_ADDRESS_INFORMATION_TYPE 230
#define OGS_PFCP_ATSSS_LL_INFORMATION_TYPE 231
#define OGS_PFCP_DATA_NETWORK_ACCESS_IDENTIFIER_TYPE 232
#define OGS_PFCP_UE_IP_ADDRESS_POOL_INFORMATION_TYPE 233
#define OGS_PFCP_AVERAGE_PACKET_DELAY_TYPE 234
#define OGS_PFCP_MINIMUM_PACKET_DELAY_TYPE 235
#define OGS_PFCP_MAXIMUM_PACKET_DELAY_TYPE 236
#define OGS_PFCP_QOS_REPORT_TRIGGER_TYPE 237
#define OGS_PFCP_GTP_U_PATH_QOS_CONTROL_INFORMATION_TYPE 238
#define OGS_PFCP_GTP_U_PATH_QOS_REPORT_PFCP_NODE_REPORT_REQUEST_TYPE 239
#define OGS_PFCP_QOS_INFORMATION_IN_GTP_U_PATH_QOS_REPORT_TYPE 240
#define OGS_PFCP_GTP_U_PATH_INTERFACE_TYPE_TYPE 241
#define OGS_PFCP_QOS_MONITORING_PER_QOS_FLOW_CONTROL_INFORMATION_TYPE 242
#define OGS_PFCP_REQUESTED_QOS_MONITORING_TYPE 243
#define OGS_PFCP_REPORTING_FREQUENCY_TYPE 244
#define OGS_PFCP_PACKET_DELAY_THRESHOLDS_TYPE 245
#define OGS_PFCP_MINIMUM_WAIT_TIME_TYPE 246
#define OGS_PFCP_QOS_MONITORING_REPORT_TYPE 247
#define OGS_PFCP_QOS_MONITORING_MEASUREMENT_TYPE 248
#define OGS_PFCP_MT_EDT_CONTROL_INFORMATION_TYPE 249
#define OGS_PFCP_DL_DATA_PACKETS_SIZE_TYPE 250
#define OGS_PFCP_QER_CONTROL_INDICATIONS_TYPE 251
#define OGS_PFCP_PACKET_RATE_STATUS_REPORT_TYPE 252
#define OGS_PFCP_NF_INSTANCE_ID_TYPE 253
#define OGS_PFCP_ETHERNET_CONTEXT_INFORMATION_TYPE 254
#define OGS_PFCP_REDUNDANT_TRANSMISSION_PARAMETERS_TYPE 255
#define OGS_PFCP_UPDATED_PDR_TYPE 256
#define OGS_PFCP_S_NSSAI_TYPE 257
#define OGS_PFCP_IP_VERSION_TYPE 258
#define OGS_PFCP_PFCPASREQ_FLAGS_TYPE 259
#define OGS_PFCP_DATA_STATUS_TYPE 260
#define OGS_PFCP_PROVIDE_RDS_CONFIGURATION_INFORMATION_TYPE 261
#define OGS_PFCP_RDS_CONFIGURATION_INFORMATION_TYPE 262
#define OGS_PFCP_QUERY_PACKET_RATE_STATUS_IE_WITHIN_PFCP_SESSION_MODIFICATION_REQUEST_TYPE 263
#define OGS_PFCP_PACKET_RATE_STATUS_REPORT_IE_WITHIN_PFCP_SESSION_MODIFICATION_RESPONSE_TYPE 264
#define OGS_PFCP_MPTCP_APPLICABLE_INDICATION_TYPE 265
#define OGS_PFCP_BRIDGE_MANAGEMENT_INFORMATION_CONTAINER_TYPE 266
#define OGS_PFCP_UE_IP_ADDRESS_USAGE_INFORMATION_TYPE 267
#define OGS_PFCP_NUMBER_OF_UE_IP_ADDRESSES_TYPE 268
#define OGS_PFCP_VALIDITY_TIMER_TYPE 269
#define OGS_PFCP_REDUNDANT_TRANSMISSION_FORWARDING_PARAMETERS_TYPE 270
#define OGS_PFCP_TRANSPORT_DELAY_REPORTING_TYPE 271
#define OGS_PFCP_PARTIAL_FAILURE_INFORMATION_TYPE 272
#define OGS_PFCP_SPARE_TYPE 273
#define OGS_PFCP_OFFENDING_IE_INFORMATION_TYPE 274
#define OGS_PFCP_RAT_TYPE_TYPE 275
#define OGS_PFCP_L2TP_TUNNEL_INFORMATION_TYPE 276
#define OGS_PFCP_L2TP_SESSION_INFORMATION_TYPE 277
#define OGS_PFCP_L2TP_USER_AUTHENTICATION_IE_TYPE 278
#define OGS_PFCP_CREATED_L2TP_SESSION_TYPE 279
#define OGS_PFCP_LNS_ADDRESS_TYPE 280
#define OGS_PFCP_TUNNEL_PREFERENCE_TYPE 281
#define OGS_PFCP_CALLING_NUMBER_TYPE 282
#define OGS_PFCP_CALLED_NUMBER_TYPE 283
#define OGS_PFCP_L2TP_SESSION_INDICATIONS_TYPE 284
#define OGS_PFCP_DNS_SERVER_ADDRESS_TYPE 285
#define OGS_PFCP_NBNS_SERVER_ADDRESS_TYPE 286
#define OGS_PFCP_MAXIMUM_RECEIVE_UNIT_TYPE 287
#define OGS_PFCP_THRESHOLDS_TYPE 288
#define OGS_PFCP_STEERING_MODE_INDICATOR_TYPE 289
#define OGS_PFCP_PFCP_SESSION_CHANGE_INFO_TYPE 290
#define OGS_PFCP_GROUP_ID_TYPE 291
#define OGS_PFCP_CP_IP_ADDRESS_TYPE 292
#define OGS_PFCP_IP_ADDRESS_AND_PORT_NUMBER_REPLACEMENT_TYPE 293
#define OGS_PFCP_DNS_QUERY_FILTER_TYPE 294
#define OGS_PFCP_DIRECT_REPORTING_INFORMATION_TYPE 295
#define OGS_PFCP_EVENT_NOTIFICATION_URI_TYPE 296
#define OGS_PFCP_NOTIFICATION_CORRELATION_ID_TYPE 297
#define OGS_PFCP_REPORTING_FLAGS_TYPE 298
#define OGS_PFCP_PREDEFINED_RULES_NAME_TYPE 299
#define OGS_PFCP_MBS_SESSION_N4MB_CONTROL_INFORMATION_TYPE 300
#define OGS_PFCP_MBS_MULTICAST_PARAMETERS_TYPE 301
#define OGS_PFCP_ADD_MBS_UNICAST_PARAMETERS_TYPE 302
#define OGS_PFCP_MBS_SESSION_N4MB_INFORMATION_TYPE 303
#define OGS_PFCP_REMOVE_MBS_UNICAST_PARAMETERS_TYPE 304
#define OGS_PFCP_MBS_SESSION_IDENTIFIER_TYPE 305
#define OGS_PFCP_MULTICAST_TRANSPORT_INFORMATION_TYPE 306
#define OGS_PFCP_MBSN4MBREQ_FLAGS_TYPE 307
#define OGS_PFCP_LOCAL_INGRESS_TUNNEL_TYPE 308
#define OGS_PFCP_MBS_UNICAST_PARAMETERS_ID_TYPE 309
#define OGS_PFCP_MBS_SESSION_N4_CONTROL_INFORMATION_TYPE 310
#define OGS_PFCP_MBS_SESSION_N4_INFORMATION_TYPE 311
#define OGS_PFCP_MBSN4RESP_FLAGS_TYPE 312
#define OGS_PFCP_TUNNEL_PASSWORD_TYPE 313
#define OGS_PFCP_AREA_SESSION_ID_TYPE 314
#define OGS_PFCP_PEER_UP_RESTART_REPORT_TYPE 315
#define OGS_PFCP_DSCP_TO_PPI_CONTROL_INFORMATION_TYPE 316
#define OGS_PFCP_DSCP_TO_PPI_MAPPING_INFORMATION_TYPE 317
#define OGS_PFCP_PFCPSDRSP_FLAGS_TYPE 318
#define OGS_PFCP_QER_INDICATIONS_TYPE 319
#define OGS_PFCP_VENDOR_SPECIFIC_NODE_REPORT_TYPE_TYPE 320
#define OGS_PFCP_CONFIGURED_TIME_DOMAIN_TYPE 321

/* Information Element TLV Descriptor */
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_cause;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_source_interface;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_f_teid;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_network_instance;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_sdf_filter;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_application_id;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_gate_status;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_mbr;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_gbr;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_qer_correlation_id;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_precedence;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_transport_level_marking;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_volume_threshold;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_time_threshold;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_monitoring_time;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_subsequent_volume_threshold;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_subsequent_time_threshold;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_inactivity_detection_time;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_reporting_triggers;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_redirect_information;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_report_type;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_offending_ie;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_forwarding_policy;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_destination_interface;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_up_function_features;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_apply_action;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_downlink_data_service_information;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_downlink_data_notification_delay;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_dl_buffering_duration;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_dl_buffering_suggested_packet_count;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_pfcpsmreq_flags;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_pfcpsrrsp_flags;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_sequence_number;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_metric;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_timer;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_pdr_id;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_f_seid;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_node_id;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_pfd_contents;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_measurement_method;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_usage_report_trigger;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_measurement_period;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_fq_csid;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_volume_measurement;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_duration_measurement;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_time_of_first_packet;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_time_of_last_packet;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_quota_holding_time;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_dropped_dl_traffic_threshold;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_volume_quota;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_time_quota;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_start_time;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_end_time;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_urr_id;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_linked_urr_id;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_outer_header_creation;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_bar_id;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_cp_function_features;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_usage_information;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_application_instance_id;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_flow_information;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_ue_ip_address;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_packet_rate;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_outer_header_removal;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_recovery_time_stamp;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_dl_flow_level_marking;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_header_enrichment;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_measurement_information;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_node_report_type;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_remote_gtp_u_peer;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_ur_seqn;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_activate_predefined_rules;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_deactivate_predefined_rules;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_far_id;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_qer_id;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_oci_flags;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_pfcp_association_release_request;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_graceful_release_period;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_pdn_type;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_failed_rule_id;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_time_quota_mechanism;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_user_plane_ip_resource_information;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_user_plane_inactivity_timer;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_aggregated_urrs;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_multiplier;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_aggregated_urr_id;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_subsequent_volume_quota;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_subsequent_time_quota;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_rqi;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_qfi;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_query_urr_reference;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_additional_usage_reports_information;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_update_traffic_endpoint;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_traffic_endpoint_id;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_mac_address;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_c_tag;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_s_tag;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_ethertype;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_proxying;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_ethernet_filter_id;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_ethernet_filter_properties;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_suggested_buffering_packets_count;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_user_id;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_ethernet_pdu_session_information;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_mac_addresses_detected;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_mac_addresses_removed;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_ethernet_inactivity_timer;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_additional_monitoring_time;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_event_quota;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_event_threshold;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_subsequent_event_quota;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_subsequent_event_threshold;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_trace_information;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_framed_route;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_framed_routing;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_framed_ipv6_route;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_time_stamp;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_averaging_window;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_paging_policy_indicator;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_apn_dnn;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc__interface_type;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_pfcpsrreq_flags;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_pfcpaureq_flags;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_activation_time;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_deactivation_time;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_mar_id;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_steering_functionality;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_steering_mode;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_weight;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_priority;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_ue_ip_address_pool_identity;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_alternative_smf_ip_address;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_packet_replication_and_detection_carry_on_information;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_smf_set_id;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_quota_validity_time;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_number_of_reports;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_pfcpasrsp_flags;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_cp_pfcp_entity_ip_address;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_pfcpsereq_flags;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_ip_multicast_address;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_source_ip_address;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_packet_rate_status;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_create_bridge_info_for_tsc;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_ds_tt_port_number;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_nw_tt_port_number;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_fivegs_user_plane_node;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_port_management_information_container;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_requested_clock_drift_information;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_time_domain_number;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_time_offset_threshold;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_cumulative_rateratio_threshold;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_time_offset_measurement;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_cumulative_rateratio_measurement;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_srr_id;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_access_availability_control_information;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_requested_access_availability_information;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_access_availability_information;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_mptcp_control_information;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_atsss_ll_control_information;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_pmf_control_information;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_mptcp_address_information;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_ue_link_specific_ip_address;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_pmf_address_information;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_atsss_ll_information;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_data_network_access_identifier;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_average_packet_delay;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_minimum_packet_delay;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_maximum_packet_delay;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_qos_report_trigger;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_gtp_u_path_qos_control_information;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_gtp_u_path_interface_type;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_qos_monitoring_per_qos_flow_control_information;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_requested_qos_monitoring;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_reporting_frequency;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_packet_delay_thresholds;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_minimum_wait_time;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_qos_monitoring_measurement;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_mt_edt_control_information;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_dl_data_packets_size;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_qer_control_indications;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_nf_instance_id;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_s_nssai;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_ip_version;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_pfcpasreq_flags;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_data_status;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_rds_configuration_information;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_mptcp_applicable_indication;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_bridge_management_information_container;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_number_of_ue_ip_addresses;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_validity_timer;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_spare;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_offending_ie_information;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_rat_type;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_l2tp_user_authentication_ie;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_lns_address;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_tunnel_preference;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_calling_number;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_called_number;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_l2tp_session_indications;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_dns_server_address;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_nbns_server_address;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_maximum_receive_unit;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_thresholds;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_steering_mode_indicator;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_group_id;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_cp_ip_address;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_ip_address_and_port_number_replacement;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_dns_query_filter;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_direct_reporting_information;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_event_notification_uri;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_notification_correlation_id;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_reporting_flags;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_predefined_rules_name;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_remove_mbs_unicast_parameters;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_mbs_session_identifier;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_multicast_transport_information;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_mbsn4mbreq_flags;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_local_ingress_tunnel;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_mbs_unicast_parameters_id;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_mbsn4resp_flags;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_tunnel_password;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_area_session_id;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_peer_up_restart_report;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_dscp_to_ppi_mapping_information;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_pfcpsdrsp_flags;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_qer_indications;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_vendor_specific_node_report_type;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_configured_time_domain;

/* Group Information Element TLV Descriptor */
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_ethernet_packet_filter;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_redundant_transmission_parameters;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_ip_multicast_addressing_info_within_pfcp_session_establishment_request;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_pdi;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_transport_delay_reporting;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_create_pdr;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_forwarding_parameters;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_duplicating_parameters;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_redundant_transmission_forwarding_parameters;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_mbs_multicast_parameters;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_add_mbs_unicast_parameters;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_create_far;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_update_forwarding_parameters;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_update_duplicating_parameters;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_update_far;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_pfd_context;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_application_id_s_pfds;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_ethernet_traffic_information;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc__access_forwarding_action_information;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_non__access_forwarding_action_information;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_update__access_forwarding_action_information;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_update_non__access_forwarding_action_information;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_access_availability_report;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_qos_monitoring_report;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_mptcp_parameters;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_atsss_ll_parameters;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_pmf_parameters;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_join_ip_multicast_information_ie_within_usage_report;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_leave_ip_multicast_information_ie_within_usage_report;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_create_urr;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_create_qer;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_created_pdr;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_update_pdr;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_update_bar_pfcp_session_report_response;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_update_urr;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_update_qer;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_remove_pdr;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_remove_far;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_remove_urr;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_remove_qer;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_load_control_information;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_overload_control_information;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_application_detection_information;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_query_urr;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_usage_report_session_modification_response;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_usage_report_session_deletion_response;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_usage_report_session_report_request;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_downlink_data_report;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_create_bar;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_update_bar_session_modification_request;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_remove_bar;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_error_indication_report;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_user_plane_path_failure_report;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_create_traffic_endpoint;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_created_traffic_endpoint;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_remove_traffic_endpoint;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_create_mar;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_remove_mar;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_update_mar;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_pfcp_session_retention_information_within_pfcp_association_setup_request;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_user_plane_path_recovery_report;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_created_bridge_info_for_tsc;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_tsc_management_information_ie_within_pfcp_session_modification_request;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_tsc_management_information_ie_within_pfcp_session_modification_response;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_tsc_management_information_ie_within_pfcp_session_report_request;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_clock_drift_control_information;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_clock_drift_report;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_remove_srr;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_create_srr;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_update_srr;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_session_report;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_provide_atsss_control_information;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_atsss_control_parameters;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_ue_ip_address_pool_information;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_gtp_u_path_qos_report_pfcp_node_report_request;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_qos_information_in_gtp_u_path_qos_report;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_packet_rate_status_report;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_ethernet_context_information;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_updated_pdr;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_provide_rds_configuration_information;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_query_packet_rate_status_ie_within_pfcp_session_modification_request;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_packet_rate_status_report_ie_within_pfcp_session_modification_response;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_ue_ip_address_usage_information;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_partial_failure_information;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_l2tp_tunnel_information;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_l2tp_session_information;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_created_l2tp_session;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_pfcp_session_change_info;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_mbs_session_n4mb_control_information;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_mbs_session_n4mb_information;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_mbs_session_n4_control_information;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_mbs_session_n4_information;
extern ogs_tlv_desc_t ogs_pfcp_tlv_desc_dscp_to_ppi_control_information;

/* Message Descriptor */
extern ogs_tlv_desc_t ogs_pfcp_msg_desc_pfcp_heartbeat_request;
extern ogs_tlv_desc_t ogs_pfcp_msg_desc_pfcp_heartbeat_response;
extern ogs_tlv_desc_t ogs_pfcp_msg_desc_pfcp_pfd_management_request;
extern ogs_tlv_desc_t ogs_pfcp_msg_desc_pfcp_pfd_management_response;
extern ogs_tlv_desc_t ogs_pfcp_msg_desc_pfcp_association_setup_request;
extern ogs_tlv_desc_t ogs_pfcp_msg_desc_pfcp_association_setup_response;
extern ogs_tlv_desc_t ogs_pfcp_msg_desc_pfcp_association_update_request;
extern ogs_tlv_desc_t ogs_pfcp_msg_desc_pfcp_association_update_response;
extern ogs_tlv_desc_t ogs_pfcp_msg_desc_pfcp_association_release_request;
extern ogs_tlv_desc_t ogs_pfcp_msg_desc_pfcp_association_release_response;
extern ogs_tlv_desc_t ogs_pfcp_msg_desc_pfcp_version_not_supported_response;
extern ogs_tlv_desc_t ogs_pfcp_msg_desc_pfcp_node_report_request;
extern ogs_tlv_desc_t ogs_pfcp_msg_desc_pfcp_node_report_response;
extern ogs_tlv_desc_t ogs_pfcp_msg_desc_pfcp_session_set_deletion_request;
extern ogs_tlv_desc_t ogs_pfcp_msg_desc_pfcp_session_set_deletion_response;
extern ogs_tlv_desc_t ogs_pfcp_msg_desc_pfcp_session_set_modification_request;
extern ogs_tlv_desc_t ogs_pfcp_msg_desc_pfcp_session_set_modification_response;
extern ogs_tlv_desc_t ogs_pfcp_msg_desc_pfcp_session_establishment_request;
extern ogs_tlv_desc_t ogs_pfcp_msg_desc_pfcp_session_establishment_response;
extern ogs_tlv_desc_t ogs_pfcp_msg_desc_pfcp_session_modification_request;
extern ogs_tlv_desc_t ogs_pfcp_msg_desc_pfcp_session_modification_response;
extern ogs_tlv_desc_t ogs_pfcp_msg_desc_pfcp_session_deletion_request;
extern ogs_tlv_desc_t ogs_pfcp_msg_desc_pfcp_session_deletion_response;
extern ogs_tlv_desc_t ogs_pfcp_msg_desc_pfcp_session_report_request;
extern ogs_tlv_desc_t ogs_pfcp_msg_desc_pfcp_session_report_response;

/* Structure for Information Element */
typedef ogs_tlv_uint8_t ogs_pfcp_tlv_cause_t;
typedef ogs_tlv_uint8_t ogs_pfcp_tlv_source_interface_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_f_teid_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_network_instance_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_sdf_filter_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_application_id_t;
typedef ogs_tlv_uint8_t ogs_pfcp_tlv_gate_status_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_mbr_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_gbr_t;
typedef ogs_tlv_uint32_t ogs_pfcp_tlv_qer_correlation_id_t;
typedef ogs_tlv_uint32_t ogs_pfcp_tlv_precedence_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_transport_level_marking_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_volume_threshold_t;
typedef ogs_tlv_uint32_t ogs_pfcp_tlv_time_threshold_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_monitoring_time_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_subsequent_volume_threshold_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_subsequent_time_threshold_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_inactivity_detection_time_t;
typedef ogs_tlv_uint24_t ogs_pfcp_tlv_reporting_triggers_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_redirect_information_t;
typedef ogs_tlv_uint8_t ogs_pfcp_tlv_report_type_t;
typedef ogs_tlv_uint16_t ogs_pfcp_tlv_offending_ie_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_forwarding_policy_t;
typedef ogs_tlv_uint8_t ogs_pfcp_tlv_destination_interface_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_up_function_features_t;
typedef ogs_tlv_uint16_t ogs_pfcp_tlv_apply_action_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_downlink_data_service_information_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_downlink_data_notification_delay_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_dl_buffering_duration_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_dl_buffering_suggested_packet_count_t;
typedef ogs_tlv_uint8_t ogs_pfcp_tlv_pfcpsmreq_flags_t;
typedef ogs_tlv_uint8_t ogs_pfcp_tlv_pfcpsrrsp_flags_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_sequence_number_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_metric_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_timer_t;
typedef ogs_tlv_uint16_t ogs_pfcp_tlv_pdr_id_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_f_seid_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_node_id_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_pfd_contents_t;
typedef ogs_tlv_uint8_t ogs_pfcp_tlv_measurement_method_t;
typedef ogs_tlv_uint24_t ogs_pfcp_tlv_usage_report_trigger_t;
typedef ogs_tlv_uint32_t ogs_pfcp_tlv_measurement_period_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_fq_csid_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_volume_measurement_t;
typedef ogs_tlv_uint32_t ogs_pfcp_tlv_duration_measurement_t;
typedef ogs_tlv_uint32_t ogs_pfcp_tlv_time_of_first_packet_t;
typedef ogs_tlv_uint32_t ogs_pfcp_tlv_time_of_last_packet_t;
typedef ogs_tlv_uint32_t ogs_pfcp_tlv_quota_holding_time_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_dropped_dl_traffic_threshold_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_volume_quota_t;
typedef ogs_tlv_uint32_t ogs_pfcp_tlv_time_quota_t;
typedef ogs_tlv_uint32_t ogs_pfcp_tlv_start_time_t;
typedef ogs_tlv_uint32_t ogs_pfcp_tlv_end_time_t;
typedef ogs_tlv_uint32_t ogs_pfcp_tlv_urr_id_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_linked_urr_id_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_outer_header_creation_t;
typedef ogs_tlv_uint8_t ogs_pfcp_tlv_bar_id_t;
typedef ogs_tlv_uint8_t ogs_pfcp_tlv_cp_function_features_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_usage_information_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_application_instance_id_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_flow_information_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_ue_ip_address_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_packet_rate_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_outer_header_removal_t;
typedef ogs_tlv_uint32_t ogs_pfcp_tlv_recovery_time_stamp_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_dl_flow_level_marking_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_header_enrichment_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_measurement_information_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_node_report_type_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_remote_gtp_u_peer_t;
typedef ogs_tlv_uint32_t ogs_pfcp_tlv_ur_seqn_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_activate_predefined_rules_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_deactivate_predefined_rules_t;
typedef ogs_tlv_uint32_t ogs_pfcp_tlv_far_id_t;
typedef ogs_tlv_uint32_t ogs_pfcp_tlv_qer_id_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_oci_flags_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_pfcp_association_release_request_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_graceful_release_period_t;
typedef ogs_tlv_uint8_t ogs_pfcp_tlv_pdn_type_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_failed_rule_id_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_time_quota_mechanism_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_user_plane_ip_resource_information_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_user_plane_inactivity_timer_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_aggregated_urrs_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_multiplier_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_aggregated_urr_id_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_subsequent_volume_quota_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_subsequent_time_quota_t;
typedef ogs_tlv_uint8_t ogs_pfcp_tlv_rqi_t;
typedef ogs_tlv_uint8_t ogs_pfcp_tlv_qfi_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_query_urr_reference_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_additional_usage_reports_information_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_update_traffic_endpoint_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_traffic_endpoint_id_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_mac_address_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_c_tag_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_s_tag_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_ethertype_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_proxying_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_ethernet_filter_id_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_ethernet_filter_properties_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_suggested_buffering_packets_count_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_user_id_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_ethernet_pdu_session_information_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_mac_addresses_detected_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_mac_addresses_removed_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_ethernet_inactivity_timer_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_additional_monitoring_time_t;
typedef ogs_tlv_uint32_t ogs_pfcp_tlv_event_quota_t;
typedef ogs_tlv_uint32_t ogs_pfcp_tlv_event_threshold_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_subsequent_event_quota_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_subsequent_event_threshold_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_trace_information_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_framed_route_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_framed_routing_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_framed_ipv6_route_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_time_stamp_t;
typedef ogs_tlv_uint32_t ogs_pfcp_tlv_averaging_window_t;
typedef ogs_tlv_uint8_t ogs_pfcp_tlv_paging_policy_indicator_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_apn_dnn_t;
typedef ogs_tlv_uint8_t ogs_pfcp_tlv__interface_type_t;
typedef ogs_tlv_uint8_t ogs_pfcp_tlv_pfcpsrreq_flags_t;
typedef ogs_tlv_uint8_t ogs_pfcp_tlv_pfcpaureq_flags_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_activation_time_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_deactivation_time_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_mar_id_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_steering_functionality_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_steering_mode_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_weight_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_priority_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_ue_ip_address_pool_identity_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_alternative_smf_ip_address_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_packet_replication_and_detection_carry_on_information_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_smf_set_id_t;
typedef ogs_tlv_uint32_t ogs_pfcp_tlv_quota_validity_time_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_number_of_reports_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_pfcpasrsp_flags_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_cp_pfcp_entity_ip_address_t;
typedef ogs_tlv_uint8_t ogs_pfcp_tlv_pfcpsereq_flags_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_ip_multicast_address_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_source_ip_address_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_packet_rate_status_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_create_bridge_info_for_tsc_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_ds_tt_port_number_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_nw_tt_port_number_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_fivegs_user_plane_node_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_port_management_information_container_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_requested_clock_drift_information_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_time_domain_number_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_time_offset_threshold_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_cumulative_rateratio_threshold_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_time_offset_measurement_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_cumulative_rateratio_measurement_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_srr_id_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_access_availability_control_information_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_requested_access_availability_information_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_access_availability_information_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_mptcp_control_information_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_atsss_ll_control_information_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_pmf_control_information_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_mptcp_address_information_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_ue_link_specific_ip_address_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_pmf_address_information_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_atsss_ll_information_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_data_network_access_identifier_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_average_packet_delay_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_minimum_packet_delay_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_maximum_packet_delay_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_qos_report_trigger_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_gtp_u_path_qos_control_information_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_gtp_u_path_interface_type_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_qos_monitoring_per_qos_flow_control_information_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_requested_qos_monitoring_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_reporting_frequency_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_packet_delay_thresholds_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_minimum_wait_time_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_qos_monitoring_measurement_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_mt_edt_control_information_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_dl_data_packets_size_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_qer_control_indications_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_nf_instance_id_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_s_nssai_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_ip_version_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_pfcpasreq_flags_t;
typedef ogs_tlv_uint8_t ogs_pfcp_tlv_data_status_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_rds_configuration_information_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_mptcp_applicable_indication_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_bridge_management_information_container_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_number_of_ue_ip_addresses_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_validity_timer_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_spare_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_offending_ie_information_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_rat_type_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_l2tp_user_authentication_ie_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_lns_address_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_tunnel_preference_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_calling_number_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_called_number_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_l2tp_session_indications_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_dns_server_address_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_nbns_server_address_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_maximum_receive_unit_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_thresholds_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_steering_mode_indicator_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_group_id_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_cp_ip_address_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_ip_address_and_port_number_replacement_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_dns_query_filter_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_direct_reporting_information_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_event_notification_uri_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_notification_correlation_id_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_reporting_flags_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_predefined_rules_name_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_remove_mbs_unicast_parameters_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_mbs_session_identifier_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_multicast_transport_information_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_mbsn4mbreq_flags_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_local_ingress_tunnel_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_mbs_unicast_parameters_id_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_mbsn4resp_flags_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_tunnel_password_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_area_session_id_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_peer_up_restart_report_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_dscp_to_ppi_mapping_information_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_pfcpsdrsp_flags_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_qer_indications_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_vendor_specific_node_report_type_t;
typedef ogs_tlv_octet_t ogs_pfcp_tlv_configured_time_domain_t;

/* Structure for Group Information Element */
typedef struct ogs_pfcp_tlv_ethernet_packet_filter_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_ethernet_filter_id_t ethernet_filter_id;
    ogs_pfcp_tlv_ethernet_filter_properties_t ethernet_filter_properties;
    ogs_pfcp_tlv_mac_address_t mac_address;
    ogs_pfcp_tlv_ethertype_t ethertype;
    ogs_pfcp_tlv_c_tag_t c_tag;
    ogs_pfcp_tlv_s_tag_t s_tag;
    ogs_pfcp_tlv_sdf_filter_t sdf_filter[8];
} ogs_pfcp_tlv_ethernet_packet_filter_t;

typedef struct ogs_pfcp_tlv_redundant_transmission_parameters_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_f_teid_t local_f_teid_for_redundant_transmission;
    ogs_pfcp_tlv_network_instance_t network_instance_for_redundant_transmission;
} ogs_pfcp_tlv_redundant_transmission_parameters_t;

typedef struct ogs_pfcp_tlv_ip_multicast_addressing_info_within_pfcp_session_establishment_request_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_ip_multicast_address_t ip_multicast_address;
    ogs_pfcp_tlv_source_ip_address_t source_ip_address;
} ogs_pfcp_tlv_ip_multicast_addressing_info_within_pfcp_session_establishment_request_t;

typedef struct ogs_pfcp_tlv_pdi_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_source_interface_t source_interface;
    ogs_pfcp_tlv_f_teid_t local_f_teid;
    ogs_pfcp_tlv_local_ingress_tunnel_t local_ingress_tunnel;
    ogs_pfcp_tlv_network_instance_t network_instance;
    ogs_pfcp_tlv_redundant_transmission_parameters_t redundant_transmission_detection_parameters;
    ogs_pfcp_tlv_ue_ip_address_t ue_ip_address;
    ogs_pfcp_tlv_traffic_endpoint_id_t traffic_endpoint_id;
    ogs_pfcp_tlv_sdf_filter_t sdf_filter[8];
    ogs_pfcp_tlv_application_id_t application_id;
    ogs_pfcp_tlv_ethernet_pdu_session_information_t ethernet_pdu_session_information;
    ogs_pfcp_tlv_ethernet_packet_filter_t ethernet_packet_filter;
    ogs_pfcp_tlv_qfi_t qfi;
    ogs_pfcp_tlv_framed_route_t framed_route[8];
    ogs_pfcp_tlv_framed_routing_t framed_routing;
    ogs_pfcp_tlv_framed_ipv6_route_t framed_ipv6_route[8];
    ogs_pfcp_tlv__interface_type_t source_interface_type;
    ogs_pfcp_tlv_ip_multicast_addressing_info_within_pfcp_session_establishment_request_t ip_multicast_addressing_info;
    ogs_pfcp_tlv_dns_query_filter_t dns_query_filter;
    ogs_pfcp_tlv_mbs_session_identifier_t mbs_session_identifier;
    ogs_pfcp_tlv_area_session_id_t area_session_id;
} ogs_pfcp_tlv_pdi_t;

typedef struct ogs_pfcp_tlv_transport_delay_reporting_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_remote_gtp_u_peer_t preceding_ul_gtp_u_peer;
    ogs_pfcp_tlv_transport_level_marking_t dscp;
} ogs_pfcp_tlv_transport_delay_reporting_t;

typedef struct ogs_pfcp_tlv_create_pdr_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_pdr_id_t pdr_id;
    ogs_pfcp_tlv_precedence_t precedence;
    ogs_pfcp_tlv_pdi_t pdi;
    ogs_pfcp_tlv_outer_header_removal_t outer_header_removal;
    ogs_pfcp_tlv_far_id_t far_id;
    ogs_pfcp_tlv_urr_id_t urr_id[8];
    ogs_pfcp_tlv_qer_id_t qer_id;
    ogs_pfcp_tlv_activate_predefined_rules_t activate_predefined_rules;
    ogs_pfcp_tlv_activation_time_t activation_time;
    ogs_pfcp_tlv_deactivation_time_t deactivation_time;
    ogs_pfcp_tlv_mar_id_t mar_id;
    ogs_pfcp_tlv_packet_replication_and_detection_carry_on_information_t packet_replication_and_detection_carry_on_information;
    ogs_pfcp_tlv_ip_multicast_addressing_info_within_pfcp_session_establishment_request_t ip_multicast_addressing_info;
    ogs_pfcp_tlv_ue_ip_address_t ue_ip_address_pool_identity;
    ogs_pfcp_tlv_mptcp_applicable_indication_t mptcp_applicable_indication;
    ogs_pfcp_tlv_transport_delay_reporting_t transport_delay_reporting;
    ogs_pfcp_tlv_rat_type_t rat_type;
} ogs_pfcp_tlv_create_pdr_t;

typedef struct ogs_pfcp_tlv_forwarding_parameters_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_destination_interface_t destination_interface;
    ogs_pfcp_tlv_network_instance_t network_instance;
    ogs_pfcp_tlv_redirect_information_t redirect_information;
    ogs_pfcp_tlv_outer_header_creation_t outer_header_creation;
    ogs_pfcp_tlv_transport_level_marking_t transport_level_marking;
    ogs_pfcp_tlv_forwarding_policy_t forwarding_policy;
    ogs_pfcp_tlv_header_enrichment_t header_enrichment;
    ogs_pfcp_tlv_traffic_endpoint_id_t linked_traffic_endpoint_id;
    ogs_pfcp_tlv_proxying_t proxying;
    ogs_pfcp_tlv__interface_type_t destination_interface_type;
    ogs_pfcp_tlv_data_network_access_identifier_t data_network_access_identifier;
    ogs_pfcp_tlv_ip_address_and_port_number_replacement_t ip_address_and_port_number_replacement;
} ogs_pfcp_tlv_forwarding_parameters_t;

typedef struct ogs_pfcp_tlv_duplicating_parameters_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_destination_interface_t destination_interface;
    ogs_pfcp_tlv_outer_header_creation_t outer_header_creation;
    ogs_pfcp_tlv_transport_level_marking_t transport_level_marking;
    ogs_pfcp_tlv_forwarding_policy_t forwarding_policy;
} ogs_pfcp_tlv_duplicating_parameters_t;

typedef struct ogs_pfcp_tlv_redundant_transmission_forwarding_parameters_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_outer_header_creation_t outer_header_creation;
    ogs_pfcp_tlv_network_instance_t network_instance_for_redundant_transmission;
} ogs_pfcp_tlv_redundant_transmission_forwarding_parameters_t;

typedef struct ogs_pfcp_tlv_mbs_multicast_parameters_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_destination_interface_t destination_interface;
    ogs_pfcp_tlv_network_instance_t network_instance;
    ogs_pfcp_tlv_outer_header_creation_t outer_header_creation;
    ogs_pfcp_tlv_transport_level_marking_t transport_level_marking;
    ogs_pfcp_tlv__interface_type_t destination_interface_type;
} ogs_pfcp_tlv_mbs_multicast_parameters_t;

typedef struct ogs_pfcp_tlv_add_mbs_unicast_parameters_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_destination_interface_t destination_interface;
    ogs_pfcp_tlv_mbs_unicast_parameters_id_t mbs_unicast_parameters_id;
    ogs_pfcp_tlv_network_instance_t network_instance;
    ogs_pfcp_tlv_outer_header_creation_t outer_header_creation;
    ogs_pfcp_tlv_transport_level_marking_t transport_level_marking;
    ogs_pfcp_tlv__interface_type_t destination_interface_type;
} ogs_pfcp_tlv_add_mbs_unicast_parameters_t;

typedef struct ogs_pfcp_tlv_create_far_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_far_id_t far_id;
    ogs_pfcp_tlv_apply_action_t apply_action;
    ogs_pfcp_tlv_forwarding_parameters_t forwarding_parameters;
    ogs_pfcp_tlv_duplicating_parameters_t duplicating_parameters;
    ogs_pfcp_tlv_bar_id_t bar_id;
    ogs_pfcp_tlv_redundant_transmission_forwarding_parameters_t redundant_transmission_forwarding_parameters;
    ogs_pfcp_tlv_mbs_multicast_parameters_t mbs_multicast_parameters;
    ogs_pfcp_tlv_add_mbs_unicast_parameters_t add_mbs_unicast_parameters;
} ogs_pfcp_tlv_create_far_t;

typedef struct ogs_pfcp_tlv_update_forwarding_parameters_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_destination_interface_t destination_interface;
    ogs_pfcp_tlv_network_instance_t network_instance;
    ogs_pfcp_tlv_redirect_information_t redirect_information;
    ogs_pfcp_tlv_outer_header_creation_t outer_header_creation;
    ogs_pfcp_tlv_transport_level_marking_t transport_level_marking;
    ogs_pfcp_tlv_forwarding_policy_t forwarding_policy;
    ogs_pfcp_tlv_header_enrichment_t header_enrichment;
    ogs_pfcp_tlv_pfcpsmreq_flags_t pfcpsmreq_flags;
    ogs_pfcp_tlv_traffic_endpoint_id_t linked_traffic_endpoint_id;
    ogs_pfcp_tlv__interface_type_t destination_interface_type;
    ogs_pfcp_tlv_data_network_access_identifier_t data_network_access_identifier;
    ogs_pfcp_tlv_ip_address_and_port_number_replacement_t ip_address_and_port_number_replacement;
} ogs_pfcp_tlv_update_forwarding_parameters_t;

typedef struct ogs_pfcp_tlv_update_duplicating_parameters_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_destination_interface_t destination_interface;
    ogs_pfcp_tlv_outer_header_creation_t outer_header_creation;
    ogs_pfcp_tlv_transport_level_marking_t transport_level_marking;
    ogs_pfcp_tlv_forwarding_policy_t forwarding_policy;
} ogs_pfcp_tlv_update_duplicating_parameters_t;

typedef struct ogs_pfcp_tlv_update_far_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_far_id_t far_id;
    ogs_pfcp_tlv_apply_action_t apply_action;
    ogs_pfcp_tlv_update_forwarding_parameters_t update_forwarding_parameters;
    ogs_pfcp_tlv_update_duplicating_parameters_t update_duplicating_parameters;
    ogs_pfcp_tlv_redundant_transmission_forwarding_parameters_t redundant_transmission_forwarding_parameters;
    ogs_pfcp_tlv_bar_id_t bar_id;
    ogs_pfcp_tlv_add_mbs_unicast_parameters_t add_mbs_unicast_parameters;
    ogs_pfcp_tlv_remove_mbs_unicast_parameters_t remove_mbs_unicast_parameters;
} ogs_pfcp_tlv_update_far_t;

typedef struct ogs_pfcp_tlv_pfd_context_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_pfd_contents_t pfd_contents;
} ogs_pfcp_tlv_pfd_context_t;

typedef struct ogs_pfcp_tlv_application_id_s_pfds_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_application_id_t application_id;
    ogs_pfcp_tlv_pfd_context_t pfd_context;
} ogs_pfcp_tlv_application_id_s_pfds_t;

typedef struct ogs_pfcp_tlv_ethernet_traffic_information_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_mac_addresses_detected_t mac_addresses_detected;
    ogs_pfcp_tlv_mac_addresses_removed_t mac_addresses_removed;
} ogs_pfcp_tlv_ethernet_traffic_information_t;

typedef struct ogs_pfcp_tlv__access_forwarding_action_information_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_far_id_t far_id;
    ogs_pfcp_tlv_weight_t weight;
    ogs_pfcp_tlv_priority_t priority;
    ogs_pfcp_tlv_urr_id_t urr_id[8];
    ogs_pfcp_tlv_rat_type_t rat_type;
} ogs_pfcp_tlv__access_forwarding_action_information_t;

typedef struct ogs_pfcp_tlv_non__access_forwarding_action_information_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_far_id_t far_id;
    ogs_pfcp_tlv_weight_t weight;
    ogs_pfcp_tlv_priority_t priority;
    ogs_pfcp_tlv_urr_id_t urr_id[8];
    ogs_pfcp_tlv_rat_type_t rat_type;
} ogs_pfcp_tlv_non__access_forwarding_action_information_t;

typedef struct ogs_pfcp_tlv_update__access_forwarding_action_information_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_far_id_t far_id;
    ogs_pfcp_tlv_weight_t weight;
    ogs_pfcp_tlv_priority_t priority;
    ogs_pfcp_tlv_urr_id_t urr_id;
    ogs_pfcp_tlv_rat_type_t rat_type;
} ogs_pfcp_tlv_update__access_forwarding_action_information_t;

typedef struct ogs_pfcp_tlv_update_non__access_forwarding_action_information_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_far_id_t far_id;
    ogs_pfcp_tlv_weight_t weight;
    ogs_pfcp_tlv_priority_t priority;
    ogs_pfcp_tlv_urr_id_t urr_id;
    ogs_pfcp_tlv_rat_type_t rat_type;
} ogs_pfcp_tlv_update_non__access_forwarding_action_information_t;

typedef struct ogs_pfcp_tlv_access_availability_report_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_access_availability_information_t access_availability_information;
} ogs_pfcp_tlv_access_availability_report_t;

typedef struct ogs_pfcp_tlv_qos_monitoring_report_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_qfi_t qfi;
    ogs_pfcp_tlv_qos_monitoring_measurement_t qos_monitoring_measurement;
    ogs_pfcp_tlv_time_stamp_t time_stamp;
    ogs_pfcp_tlv_start_time_t start_time;
} ogs_pfcp_tlv_qos_monitoring_report_t;

typedef struct ogs_pfcp_tlv_mptcp_parameters_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_mptcp_address_information_t mptcp_address_information;
    ogs_pfcp_tlv_ue_link_specific_ip_address_t ue_link_specific_ip_address;
} ogs_pfcp_tlv_mptcp_parameters_t;

typedef struct ogs_pfcp_tlv_atsss_ll_parameters_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_atsss_ll_information_t atsss_ll_information;
} ogs_pfcp_tlv_atsss_ll_parameters_t;

typedef struct ogs_pfcp_tlv_pmf_parameters_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_pmf_address_information_t pmf_address_information;
    ogs_pfcp_tlv_qfi_t qos_flow_identifier;
} ogs_pfcp_tlv_pmf_parameters_t;

typedef struct ogs_pfcp_tlv_join_ip_multicast_information_ie_within_usage_report_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_ip_multicast_address_t ip_multicast_address;
    ogs_pfcp_tlv_source_ip_address_t source_ip_address;
} ogs_pfcp_tlv_join_ip_multicast_information_ie_within_usage_report_t;

typedef struct ogs_pfcp_tlv_leave_ip_multicast_information_ie_within_usage_report_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_ip_multicast_address_t ip_multicast_address;
    ogs_pfcp_tlv_source_ip_address_t source_ip_address;
} ogs_pfcp_tlv_leave_ip_multicast_information_ie_within_usage_report_t;

typedef struct ogs_pfcp_tlv_create_urr_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_urr_id_t urr_id;
    ogs_pfcp_tlv_measurement_method_t measurement_method;
    ogs_pfcp_tlv_reporting_triggers_t reporting_triggers;
    ogs_pfcp_tlv_measurement_period_t measurement_period;
    ogs_pfcp_tlv_volume_threshold_t volume_threshold;
    ogs_pfcp_tlv_volume_quota_t volume_quota;
    ogs_pfcp_tlv_event_threshold_t event_threshold;
    ogs_pfcp_tlv_event_quota_t event_quota;
    ogs_pfcp_tlv_time_threshold_t time_threshold;
    ogs_pfcp_tlv_time_quota_t time_quota;
    ogs_pfcp_tlv_quota_holding_time_t quota_holding_time;
    ogs_pfcp_tlv_dropped_dl_traffic_threshold_t dropped_dl_traffic_threshold;
    ogs_pfcp_tlv_quota_validity_time_t quota_validity_time;
    ogs_pfcp_tlv_monitoring_time_t monitoring_time;
    ogs_pfcp_tlv_subsequent_volume_threshold_t subsequent_volume_threshold;
    ogs_pfcp_tlv_subsequent_time_threshold_t subsequent_time_threshold;
    ogs_pfcp_tlv_subsequent_volume_quota_t subsequent_volume_quota;
    ogs_pfcp_tlv_subsequent_time_quota_t subsequent_time_quota;
    ogs_pfcp_tlv_subsequent_event_threshold_t subsequent_event_threshold;
    ogs_pfcp_tlv_subsequent_event_quota_t subsequent_event_quota;
    ogs_pfcp_tlv_inactivity_detection_time_t inactivity_detection_time;
    ogs_pfcp_tlv_linked_urr_id_t linked_urr_id;
    ogs_pfcp_tlv_measurement_information_t measurement_information;
    ogs_pfcp_tlv_time_quota_mechanism_t time_quota_mechanism;
    ogs_pfcp_tlv_aggregated_urrs_t aggregated_urrs;
    ogs_pfcp_tlv_far_id_t far_id_for_quota_action;
    ogs_pfcp_tlv_ethernet_inactivity_timer_t ethernet_inactivity_timer;
    ogs_pfcp_tlv_additional_monitoring_time_t additional_monitoring_time;
    ogs_pfcp_tlv_number_of_reports_t number_of_reports;
    ogs_pfcp_tlv_application_id_t exempted_application_id_for_quota_action;
    ogs_pfcp_tlv_sdf_filter_t exempted_sdf_filter_for_quota_action[8];
    ogs_pfcp_tlv_user_plane_inactivity_timer_t user_plane_inactivity_timer;
} ogs_pfcp_tlv_create_urr_t;

typedef struct ogs_pfcp_tlv_create_qer_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_qer_id_t qer_id;
    ogs_pfcp_tlv_qer_correlation_id_t qer_correlation_id;
    ogs_pfcp_tlv_gate_status_t gate_status;
    ogs_pfcp_tlv_mbr_t maximum_bitrate;
    ogs_pfcp_tlv_gbr_t guaranteed_bitrate;
    ogs_pfcp_tlv_packet_rate_t packet_rate;
    ogs_pfcp_tlv_packet_rate_status_t packet_rate_status;
    ogs_pfcp_tlv_dl_flow_level_marking_t dl_flow_level_marking;
    ogs_pfcp_tlv_qfi_t qos_flow_identifier;
    ogs_pfcp_tlv_rqi_t reflective_qos;
    ogs_pfcp_tlv_paging_policy_indicator_t paging_policy_indicator;
    ogs_pfcp_tlv_averaging_window_t averaging_window;
    ogs_pfcp_tlv_qer_control_indications_t qer_control_indications;
    ogs_pfcp_tlv_qer_indications_t qer_indications;
} ogs_pfcp_tlv_create_qer_t;

typedef struct ogs_pfcp_tlv_created_pdr_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_pdr_id_t pdr_id;
    ogs_pfcp_tlv_f_teid_t local_f_teid;
    ogs_pfcp_tlv_f_teid_t local_f_teid_for_redundant_transmission;
    ogs_pfcp_tlv_ue_ip_address_t ue_ip_address;
    ogs_pfcp_tlv_local_ingress_tunnel_t local_ingress_tunnel;
} ogs_pfcp_tlv_created_pdr_t;

typedef struct ogs_pfcp_tlv_update_pdr_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_pdr_id_t pdr_id;
    ogs_pfcp_tlv_outer_header_removal_t outer_header_removal;
    ogs_pfcp_tlv_precedence_t precedence;
    ogs_pfcp_tlv_pdi_t pdi;
    ogs_pfcp_tlv_far_id_t far_id;
    ogs_pfcp_tlv_urr_id_t urr_id;
    ogs_pfcp_tlv_qer_id_t qer_id;
    ogs_pfcp_tlv_activate_predefined_rules_t activate_predefined_rules;
    ogs_pfcp_tlv_deactivate_predefined_rules_t deactivate_predefined_rules;
    ogs_pfcp_tlv_activation_time_t activation_time;
    ogs_pfcp_tlv_deactivation_time_t deactivation_time;
    ogs_pfcp_tlv_ip_multicast_addressing_info_within_pfcp_session_establishment_request_t ip_multicast_addressing_info;
    ogs_pfcp_tlv_transport_delay_reporting_t transport_delay_reporting;
    ogs_pfcp_tlv_rat_type_t rat_type;
} ogs_pfcp_tlv_update_pdr_t;

typedef struct ogs_pfcp_tlv_update_bar_pfcp_session_report_response_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_bar_id_t bar_id;
    ogs_pfcp_tlv_downlink_data_notification_delay_t downlink_data_notification_delay;
    ogs_pfcp_tlv_dl_buffering_duration_t dl_buffering_duration;
    ogs_pfcp_tlv_dl_buffering_suggested_packet_count_t dl_buffering_suggested_packet_count;
    ogs_pfcp_tlv_suggested_buffering_packets_count_t suggested_buffering_packets_count;
} ogs_pfcp_tlv_update_bar_pfcp_session_report_response_t;

typedef struct ogs_pfcp_tlv_update_urr_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_urr_id_t urr_id;
    ogs_pfcp_tlv_measurement_method_t measurement_method;
    ogs_pfcp_tlv_reporting_triggers_t reporting_triggers;
    ogs_pfcp_tlv_measurement_period_t measurement_period;
    ogs_pfcp_tlv_volume_threshold_t volume_threshold;
    ogs_pfcp_tlv_volume_quota_t volume_quota;
    ogs_pfcp_tlv_time_threshold_t time_threshold;
    ogs_pfcp_tlv_time_quota_t time_quota;
    ogs_pfcp_tlv_event_threshold_t event_threshold;
    ogs_pfcp_tlv_event_quota_t event_quota;
    ogs_pfcp_tlv_quota_holding_time_t quota_holding_time;
    ogs_pfcp_tlv_dropped_dl_traffic_threshold_t dropped_dl_traffic_threshold;
    ogs_pfcp_tlv_quota_validity_time_t quota_validity_time;
    ogs_pfcp_tlv_monitoring_time_t monitoring_time;
    ogs_pfcp_tlv_subsequent_volume_threshold_t subsequent_volume_threshold;
    ogs_pfcp_tlv_subsequent_time_threshold_t subsequent_time_threshold;
    ogs_pfcp_tlv_subsequent_volume_quota_t subsequent_volume_quota;
    ogs_pfcp_tlv_subsequent_time_quota_t subsequent_time_quota;
    ogs_pfcp_tlv_subsequent_event_threshold_t subsequent_event_threshold;
    ogs_pfcp_tlv_subsequent_event_quota_t subsequent_event_quota;
    ogs_pfcp_tlv_inactivity_detection_time_t inactivity_detection_time;
    ogs_pfcp_tlv_linked_urr_id_t linked_urr_id;
    ogs_pfcp_tlv_measurement_information_t measurement_information;
    ogs_pfcp_tlv_time_quota_mechanism_t time_quota_mechanism;
    ogs_pfcp_tlv_aggregated_urrs_t aggregated_urrs;
    ogs_pfcp_tlv_far_id_t far_id_for_quota_action;
    ogs_pfcp_tlv_ethernet_inactivity_timer_t ethernet_inactivity_timer;
    ogs_pfcp_tlv_additional_monitoring_time_t additional_monitoring_time;
    ogs_pfcp_tlv_number_of_reports_t number_of_reports;
    ogs_pfcp_tlv_application_id_t exempted_application_id_for_quota_action;
    ogs_pfcp_tlv_sdf_filter_t exempted_sdf_filter_for_quota_action[8];
    ogs_pfcp_tlv_user_plane_inactivity_timer_t user_plane_inactivity_timer;
} ogs_pfcp_tlv_update_urr_t;

typedef struct ogs_pfcp_tlv_update_qer_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_qer_id_t qer_id;
    ogs_pfcp_tlv_qer_correlation_id_t qer_correlation_id;
    ogs_pfcp_tlv_gate_status_t gate_status;
    ogs_pfcp_tlv_mbr_t maximum_bitrate;
    ogs_pfcp_tlv_gbr_t guaranteed_bitrate;
    ogs_pfcp_tlv_packet_rate_t packet_rate;
    ogs_pfcp_tlv_dl_flow_level_marking_t dl_flow_level_marking;
    ogs_pfcp_tlv_qfi_t qos_flow_identifier;
    ogs_pfcp_tlv_rqi_t reflective_qos;
    ogs_pfcp_tlv_paging_policy_indicator_t paging_policy_indicator;
    ogs_pfcp_tlv_averaging_window_t averaging_window;
    ogs_pfcp_tlv_qer_control_indications_t qer_control_indications;
} ogs_pfcp_tlv_update_qer_t;

typedef struct ogs_pfcp_tlv_remove_pdr_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_pdr_id_t pdr_id;
} ogs_pfcp_tlv_remove_pdr_t;

typedef struct ogs_pfcp_tlv_remove_far_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_far_id_t far_id;
} ogs_pfcp_tlv_remove_far_t;

typedef struct ogs_pfcp_tlv_remove_urr_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_urr_id_t urr_id;
} ogs_pfcp_tlv_remove_urr_t;

typedef struct ogs_pfcp_tlv_remove_qer_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_qer_id_t qer_id;
} ogs_pfcp_tlv_remove_qer_t;

typedef struct ogs_pfcp_tlv_load_control_information_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_sequence_number_t load_control_sequence_number;
    ogs_pfcp_tlv_metric_t load_metric;
} ogs_pfcp_tlv_load_control_information_t;

typedef struct ogs_pfcp_tlv_overload_control_information_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_sequence_number_t overload_control_sequence_number;
    ogs_pfcp_tlv_metric_t overload_reduction_metric;
    ogs_pfcp_tlv_timer_t period_of_validity;
    ogs_pfcp_tlv_oci_flags_t overload_control_information_flags;
} ogs_pfcp_tlv_overload_control_information_t;

typedef struct ogs_pfcp_tlv_application_detection_information_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_application_id_t application_id;
    ogs_pfcp_tlv_application_instance_id_t application_instance_id;
    ogs_pfcp_tlv_flow_information_t flow_information;
    ogs_pfcp_tlv_pdr_id_t pdr_id;
} ogs_pfcp_tlv_application_detection_information_t;

typedef struct ogs_pfcp_tlv_query_urr_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_urr_id_t urr_id;
} ogs_pfcp_tlv_query_urr_t;

typedef struct ogs_pfcp_tlv_usage_report_session_modification_response_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_urr_id_t urr_id;
    ogs_pfcp_tlv_ur_seqn_t ur_seqn;
    ogs_pfcp_tlv_usage_report_trigger_t usage_report_trigger;
    ogs_pfcp_tlv_start_time_t start_time;
    ogs_pfcp_tlv_end_time_t end_time;
    ogs_pfcp_tlv_volume_measurement_t volume_measurement;
    ogs_pfcp_tlv_duration_measurement_t duration_measurement;
    ogs_pfcp_tlv_time_of_first_packet_t time_of_first_packet;
    ogs_pfcp_tlv_time_of_last_packet_t time_of_last_packet;
    ogs_pfcp_tlv_usage_information_t usage_information;
    ogs_pfcp_tlv_query_urr_reference_t query_urr_reference;
    ogs_pfcp_tlv_ethernet_traffic_information_t ethernet_traffic_information;
} ogs_pfcp_tlv_usage_report_session_modification_response_t;

typedef struct ogs_pfcp_tlv_usage_report_session_deletion_response_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_urr_id_t urr_id;
    ogs_pfcp_tlv_ur_seqn_t ur_seqn;
    ogs_pfcp_tlv_usage_report_trigger_t usage_report_trigger;
    ogs_pfcp_tlv_start_time_t start_time;
    ogs_pfcp_tlv_end_time_t end_time;
    ogs_pfcp_tlv_volume_measurement_t volume_measurement;
    ogs_pfcp_tlv_duration_measurement_t duration_measurement;
    ogs_pfcp_tlv_time_of_first_packet_t time_of_first_packet;
    ogs_pfcp_tlv_time_of_last_packet_t time_of_last_packet;
    ogs_pfcp_tlv_usage_information_t usage_information;
    ogs_pfcp_tlv_ethernet_traffic_information_t ethernet_traffic_information;
} ogs_pfcp_tlv_usage_report_session_deletion_response_t;

typedef struct ogs_pfcp_tlv_usage_report_session_report_request_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_urr_id_t urr_id;
    ogs_pfcp_tlv_ur_seqn_t ur_seqn;
    ogs_pfcp_tlv_usage_report_trigger_t usage_report_trigger;
    ogs_pfcp_tlv_start_time_t start_time;
    ogs_pfcp_tlv_end_time_t end_time;
    ogs_pfcp_tlv_volume_measurement_t volume_measurement;
    ogs_pfcp_tlv_duration_measurement_t duration_measurement;
    ogs_pfcp_tlv_application_detection_information_t application_detection_information;
    ogs_pfcp_tlv_ue_ip_address_t ue_ip_address;
    ogs_pfcp_tlv_network_instance_t network_instance;
    ogs_pfcp_tlv_time_of_first_packet_t time_of_first_packet;
    ogs_pfcp_tlv_time_of_last_packet_t time_of_last_packet;
    ogs_pfcp_tlv_usage_information_t usage_information;
    ogs_pfcp_tlv_query_urr_reference_t query_urr_reference;
    ogs_pfcp_tlv_time_stamp_t event_time_stamp;
    ogs_pfcp_tlv_ethernet_traffic_information_t ethernet_traffic_information;
    ogs_pfcp_tlv_join_ip_multicast_information_ie_within_usage_report_t join_ip_muticast_information;
    ogs_pfcp_tlv_leave_ip_multicast_information_ie_within_usage_report_t leave_ip_muticast_information;
    ogs_pfcp_tlv_predefined_rules_name_t predefined_rules_name;
} ogs_pfcp_tlv_usage_report_session_report_request_t;

typedef struct ogs_pfcp_tlv_downlink_data_report_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_pdr_id_t pdr_id;
    ogs_pfcp_tlv_downlink_data_service_information_t downlink_data_service_information;
    ogs_pfcp_tlv_dl_data_packets_size_t dl_data_packets_size;
    ogs_pfcp_tlv_data_status_t dl_data_status;
} ogs_pfcp_tlv_downlink_data_report_t;

typedef struct ogs_pfcp_tlv_create_bar_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_bar_id_t bar_id;
    ogs_pfcp_tlv_downlink_data_notification_delay_t downlink_data_notification_delay;
    ogs_pfcp_tlv_suggested_buffering_packets_count_t suggested_buffering_packets_count;
    ogs_pfcp_tlv_mt_edt_control_information_t mt_edt_control_information;
} ogs_pfcp_tlv_create_bar_t;

typedef struct ogs_pfcp_tlv_update_bar_session_modification_request_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_bar_id_t bar_id;
    ogs_pfcp_tlv_downlink_data_notification_delay_t downlink_data_notification_delay;
    ogs_pfcp_tlv_suggested_buffering_packets_count_t suggested_buffering_packets_count;
    ogs_pfcp_tlv_mt_edt_control_information_t mt_edt_control_information;
} ogs_pfcp_tlv_update_bar_session_modification_request_t;

typedef struct ogs_pfcp_tlv_remove_bar_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_bar_id_t bar_id;
} ogs_pfcp_tlv_remove_bar_t;

typedef struct ogs_pfcp_tlv_error_indication_report_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_f_teid_t remote_f_teid;
} ogs_pfcp_tlv_error_indication_report_t;

typedef struct ogs_pfcp_tlv_user_plane_path_failure_report_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_remote_gtp_u_peer_t remote_gtp_u_peer;
} ogs_pfcp_tlv_user_plane_path_failure_report_t;

typedef struct ogs_pfcp_tlv_create_traffic_endpoint_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_traffic_endpoint_id_t traffic_endpoint_id;
    ogs_pfcp_tlv_f_teid_t local_f_teid;
    ogs_pfcp_tlv_network_instance_t network_instance;
    ogs_pfcp_tlv_redundant_transmission_parameters_t redundant_transmission_detection_parameters;
    ogs_pfcp_tlv_ue_ip_address_t ue_ip_address;
    ogs_pfcp_tlv_ethernet_pdu_session_information_t ethernet_pdu_session_information;
    ogs_pfcp_tlv_framed_route_t framed_route[8];
    ogs_pfcp_tlv_framed_routing_t framed_routing;
    ogs_pfcp_tlv_framed_ipv6_route_t framed_ipv6_route[8];
    ogs_pfcp_tlv_qfi_t qfi;
    ogs_pfcp_tlv__interface_type_t source_interface_type;
    ogs_pfcp_tlv_local_ingress_tunnel_t local_ingress_tunnel;
    ogs_pfcp_tlv_ip_multicast_addressing_info_within_pfcp_session_establishment_request_t ip_multicast_addressing_info;
    ogs_pfcp_tlv_mbs_session_identifier_t mbs_session_identifier;
    ogs_pfcp_tlv_area_session_id_t area_session_id;
    ogs_pfcp_tlv_rat_type_t rat_type;
} ogs_pfcp_tlv_create_traffic_endpoint_t;

typedef struct ogs_pfcp_tlv_created_traffic_endpoint_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_traffic_endpoint_id_t traffic_endpoint_id;
    ogs_pfcp_tlv_f_teid_t local_f_teid;
    ogs_pfcp_tlv_f_teid_t local_f_teid_for_redundant_transmission;
    ogs_pfcp_tlv_ue_ip_address_t ue_ip_address;
    ogs_pfcp_tlv_local_ingress_tunnel_t local_ingress_tunnel;
} ogs_pfcp_tlv_created_traffic_endpoint_t;

typedef struct ogs_pfcp_tlv_remove_traffic_endpoint_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_traffic_endpoint_id_t traffic_endpoint_id;
} ogs_pfcp_tlv_remove_traffic_endpoint_t;

typedef struct ogs_pfcp_tlv_create_mar_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_mar_id_t mar_id;
    ogs_pfcp_tlv_steering_functionality_t steering_functionality;
    ogs_pfcp_tlv_steering_mode_t steering_mode;
    ogs_pfcp_tlv__access_forwarding_action_information_t _access_forwarding_action_information;
    ogs_pfcp_tlv_non__access_forwarding_action_information_t non__access_forwarding_action_information;
    ogs_pfcp_tlv_thresholds_t threshold_values;
    ogs_pfcp_tlv_steering_mode_indicator_t steering_mode_indicator;
} ogs_pfcp_tlv_create_mar_t;

typedef struct ogs_pfcp_tlv_remove_mar_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_mar_id_t mar_id;
} ogs_pfcp_tlv_remove_mar_t;

typedef struct ogs_pfcp_tlv_update_mar_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_mar_id_t mar_id;
    ogs_pfcp_tlv_steering_functionality_t steering_functionality;
    ogs_pfcp_tlv_steering_mode_t steering_mode;
    ogs_pfcp_tlv_update__access_forwarding_action_information_t update__access_forwarding_action_information;
    ogs_pfcp_tlv_update_non__access_forwarding_action_information_t update_non__access_forwarding_action_information;
    ogs_pfcp_tlv__access_forwarding_action_information_t _access_forwarding_action_information;
    ogs_pfcp_tlv_non__access_forwarding_action_information_t non__access_forwarding_action_information;
    ogs_pfcp_tlv_thresholds_t threshold_values;
    ogs_pfcp_tlv_steering_mode_indicator_t steering_mode_indicator;
} ogs_pfcp_tlv_update_mar_t;

typedef struct ogs_pfcp_tlv_pfcp_session_retention_information_within_pfcp_association_setup_request_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_cp_pfcp_entity_ip_address_t cp_pfcp_entity_ip_address;
} ogs_pfcp_tlv_pfcp_session_retention_information_within_pfcp_association_setup_request_t;

typedef struct ogs_pfcp_tlv_user_plane_path_recovery_report_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_remote_gtp_u_peer_t remote_gtp_u_peer;
} ogs_pfcp_tlv_user_plane_path_recovery_report_t;

typedef struct ogs_pfcp_tlv_created_bridge_info_for_tsc_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_ds_tt_port_number_t ds_tt_port_number;
    ogs_pfcp_tlv_fivegs_user_plane_node_t fivegs_user_plane_node;
} ogs_pfcp_tlv_created_bridge_info_for_tsc_t;

typedef struct ogs_pfcp_tlv_tsc_management_information_ie_within_pfcp_session_modification_request_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_port_management_information_container_t port_management_information_container;
    ogs_pfcp_tlv_bridge_management_information_container_t user_plane_node_management_information_container;
    ogs_pfcp_tlv_nw_tt_port_number_t nw_tt_port_number;
} ogs_pfcp_tlv_tsc_management_information_ie_within_pfcp_session_modification_request_t;

typedef struct ogs_pfcp_tlv_tsc_management_information_ie_within_pfcp_session_modification_response_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_port_management_information_container_t port_management_information_container;
    ogs_pfcp_tlv_bridge_management_information_container_t user_plane_node_management_information_container;
    ogs_pfcp_tlv_nw_tt_port_number_t nw_tt_port_number;
} ogs_pfcp_tlv_tsc_management_information_ie_within_pfcp_session_modification_response_t;

typedef struct ogs_pfcp_tlv_tsc_management_information_ie_within_pfcp_session_report_request_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_port_management_information_container_t port_management_information_container;
    ogs_pfcp_tlv_bridge_management_information_container_t user_plane_node_management_information_container;
    ogs_pfcp_tlv_nw_tt_port_number_t nw_tt_port_number;
} ogs_pfcp_tlv_tsc_management_information_ie_within_pfcp_session_report_request_t;

typedef struct ogs_pfcp_tlv_clock_drift_control_information_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_requested_clock_drift_information_t requested_clock_drift_information;
    ogs_pfcp_tlv_time_domain_number_t time_domain_number;
    ogs_pfcp_tlv_configured_time_domain_t configured_time_domain;
    ogs_pfcp_tlv_time_offset_threshold_t time_offset_threshold;
    ogs_pfcp_tlv_cumulative_rateratio_threshold_t cumulative_rateratio_threshold;
} ogs_pfcp_tlv_clock_drift_control_information_t;

typedef struct ogs_pfcp_tlv_clock_drift_report_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_time_domain_number_t time_domain_number;
    ogs_pfcp_tlv_time_offset_measurement_t time_offset_measurement;
    ogs_pfcp_tlv_cumulative_rateratio_measurement_t cumulative_rateratio_measurement;
    ogs_pfcp_tlv_time_stamp_t time_stamp;
    ogs_pfcp_tlv_network_instance_t network_instance;
    ogs_pfcp_tlv_apn_dnn_t apn_dnn;
    ogs_pfcp_tlv_s_nssai_t s_nssai;
} ogs_pfcp_tlv_clock_drift_report_t;

typedef struct ogs_pfcp_tlv_remove_srr_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_srr_id_t srr_id;
} ogs_pfcp_tlv_remove_srr_t;

typedef struct ogs_pfcp_tlv_create_srr_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_srr_id_t srr_id;
    ogs_pfcp_tlv_access_availability_control_information_t access_availability_control_information;
    ogs_pfcp_tlv_qos_monitoring_per_qos_flow_control_information_t qos_monitoring_per_qos_flow_control_information;
    ogs_pfcp_tlv_direct_reporting_information_t direct_reporting_information;
} ogs_pfcp_tlv_create_srr_t;

typedef struct ogs_pfcp_tlv_update_srr_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_srr_id_t srr_id;
    ogs_pfcp_tlv_access_availability_control_information_t access_availability_control_information;
    ogs_pfcp_tlv_qos_monitoring_per_qos_flow_control_information_t qos_monitoring_per_qos_flow_control_information;
    ogs_pfcp_tlv_direct_reporting_information_t direct_reporting_information;
} ogs_pfcp_tlv_update_srr_t;

typedef struct ogs_pfcp_tlv_session_report_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_srr_id_t srr_id;
    ogs_pfcp_tlv_access_availability_report_t access_availability_report;
    ogs_pfcp_tlv_qos_monitoring_report_t qos_monitoring_report;
} ogs_pfcp_tlv_session_report_t;

typedef struct ogs_pfcp_tlv_provide_atsss_control_information_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_mptcp_control_information_t mptcp_control_information;
    ogs_pfcp_tlv_atsss_ll_control_information_t atsss_ll_control_information;
    ogs_pfcp_tlv_pmf_control_information_t pmf_control_information;
} ogs_pfcp_tlv_provide_atsss_control_information_t;

typedef struct ogs_pfcp_tlv_atsss_control_parameters_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_mptcp_parameters_t mptcp_parameters;
    ogs_pfcp_tlv_atsss_ll_parameters_t atsss_ll_parameters;
    ogs_pfcp_tlv_pmf_parameters_t pmf_parameters;
} ogs_pfcp_tlv_atsss_control_parameters_t;

typedef struct ogs_pfcp_tlv_ue_ip_address_pool_information_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_ue_ip_address_t ue_ip_address_pool_identity;
    ogs_pfcp_tlv_network_instance_t network_instance;
    ogs_pfcp_tlv_s_nssai_t s_nssai;
    ogs_pfcp_tlv_ip_version_t ip_version;
} ogs_pfcp_tlv_ue_ip_address_pool_information_t;

typedef struct ogs_pfcp_tlv_gtp_u_path_qos_report_pfcp_node_report_request_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_remote_gtp_u_peer_t remote_gtp_u_peer;
    ogs_pfcp_tlv_gtp_u_path_interface_type_t gtp_u_path_interface_type;
    ogs_pfcp_tlv_qos_report_trigger_t qos_report_trigger;
    ogs_pfcp_tlv_transport_level_marking_t dscp;
    ogs_pfcp_tlv_measurement_period_t measurement_period;
    ogs_pfcp_tlv_average_packet_delay_t average_packet_delay_threshold;
    ogs_pfcp_tlv_minimum_packet_delay_t minimum_packet_delay_threshold;
    ogs_pfcp_tlv_maximum_packet_delay_t maximum_packet_delay_threshold;
    ogs_pfcp_tlv_timer_t minimum_waiting_time;
} ogs_pfcp_tlv_gtp_u_path_qos_report_pfcp_node_report_request_t;

typedef struct ogs_pfcp_tlv_qos_information_in_gtp_u_path_qos_report_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_average_packet_delay_t average_packet_delay;
    ogs_pfcp_tlv_minimum_packet_delay_t minimum_packet_delay;
    ogs_pfcp_tlv_maximum_packet_delay_t maximum_packet_delay;
    ogs_pfcp_tlv_transport_level_marking_t dscp;
} ogs_pfcp_tlv_qos_information_in_gtp_u_path_qos_report_t;

typedef struct ogs_pfcp_tlv_packet_rate_status_report_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_qer_id_t qer_id;
    ogs_pfcp_tlv_packet_rate_status_t packet_rate_status;
} ogs_pfcp_tlv_packet_rate_status_report_t;

typedef struct ogs_pfcp_tlv_ethernet_context_information_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_mac_addresses_detected_t mac_addresses_detected;
} ogs_pfcp_tlv_ethernet_context_information_t;

typedef struct ogs_pfcp_tlv_updated_pdr_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_pdr_id_t pdr_id;
    ogs_pfcp_tlv_f_teid_t local_f_teid_for_redundant_transmission;
    ogs_pfcp_tlv_f_teid_t local_f_teid;
    ogs_pfcp_tlv_ue_ip_address_t ue_ip_address;
} ogs_pfcp_tlv_updated_pdr_t;

typedef struct ogs_pfcp_tlv_provide_rds_configuration_information_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_rds_configuration_information_t rds_configuration_information;
} ogs_pfcp_tlv_provide_rds_configuration_information_t;

typedef struct ogs_pfcp_tlv_query_packet_rate_status_ie_within_pfcp_session_modification_request_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_qer_id_t qer_id;
} ogs_pfcp_tlv_query_packet_rate_status_ie_within_pfcp_session_modification_request_t;

typedef struct ogs_pfcp_tlv_packet_rate_status_report_ie_within_pfcp_session_modification_response_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_qer_id_t qer_id;
    ogs_pfcp_tlv_packet_rate_status_t packet_rate_status;
} ogs_pfcp_tlv_packet_rate_status_report_ie_within_pfcp_session_modification_response_t;

typedef struct ogs_pfcp_tlv_ue_ip_address_usage_information_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_sequence_number_t ue_ip_address_usage_sequence_number;
    ogs_pfcp_tlv_metric_t ue_ip_address_usage_metric;
    ogs_pfcp_tlv_validity_timer_t validity_timer;
    ogs_pfcp_tlv_number_of_ue_ip_addresses_t number_of_ue_ip_addresses;
    ogs_pfcp_tlv_network_instance_t network_instance;
    ogs_pfcp_tlv_ue_ip_address_t ue_ip_address_pool_id;
    ogs_pfcp_tlv_s_nssai_t s_nssai;
} ogs_pfcp_tlv_ue_ip_address_usage_information_t;

typedef struct ogs_pfcp_tlv_partial_failure_information_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_failed_rule_id_t failed_rule_id;
    ogs_pfcp_tlv_cause_t failure_cause;
    ogs_pfcp_tlv_offending_ie_information_t offending_ie_information;
} ogs_pfcp_tlv_partial_failure_information_t;

typedef struct ogs_pfcp_tlv_l2tp_tunnel_information_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_lns_address_t lns_address;
    ogs_pfcp_tlv_tunnel_password_t tunnel_password;
    ogs_pfcp_tlv_tunnel_preference_t tunnel_preference;
} ogs_pfcp_tlv_l2tp_tunnel_information_t;

typedef struct ogs_pfcp_tlv_l2tp_session_information_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_calling_number_t calling_number;
    ogs_pfcp_tlv_called_number_t called_number;
    ogs_pfcp_tlv_maximum_receive_unit_t maximum_receive_unit;
    ogs_pfcp_tlv_l2tp_session_indications_t l2tp_session_indications;
    ogs_pfcp_tlv_l2tp_user_authentication_ie_t l2tp_user_authentication;
} ogs_pfcp_tlv_l2tp_session_information_t;

typedef struct ogs_pfcp_tlv_created_l2tp_session_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_dns_server_address_t dns_server_address;
    ogs_pfcp_tlv_nbns_server_address_t nbns_server_address;
    ogs_pfcp_tlv_lns_address_t lns_address;
} ogs_pfcp_tlv_created_l2tp_session_t;

typedef struct ogs_pfcp_tlv_pfcp_session_change_info_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_fq_csid_t pgw_c_smf_fq_csid;
    ogs_pfcp_tlv_group_id_t group_id;
    ogs_pfcp_tlv_cp_ip_address_t cp_ip_address;
    ogs_pfcp_tlv_alternative_smf_ip_address_t alternative_smf_pgw_c_ip_address;
} ogs_pfcp_tlv_pfcp_session_change_info_t;

typedef struct ogs_pfcp_tlv_mbs_session_n4mb_control_information_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_mbs_session_identifier_t mbs_session_identifier;
    ogs_pfcp_tlv_area_session_id_t area_session_id;
    ogs_pfcp_tlv_mbsn4mbreq_flags_t mbsn4mbreq_flags;
    ogs_pfcp_tlv_multicast_transport_information_t multicast_transport_information_for_n3mb_and_or_n19mb;
} ogs_pfcp_tlv_mbs_session_n4mb_control_information_t;

typedef struct ogs_pfcp_tlv_mbs_session_n4mb_information_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_multicast_transport_information_t multicast_transport_information;
} ogs_pfcp_tlv_mbs_session_n4mb_information_t;

typedef struct ogs_pfcp_tlv_mbs_session_n4_control_information_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_mbs_session_identifier_t mbs_session_identifier;
    ogs_pfcp_tlv_area_session_id_t area_session_id;
    ogs_pfcp_tlv_multicast_transport_information_t multicast_transport_information;
} ogs_pfcp_tlv_mbs_session_n4_control_information_t;

typedef struct ogs_pfcp_tlv_mbs_session_n4_information_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_mbs_session_identifier_t mbs_session_identifier;
    ogs_pfcp_tlv_area_session_id_t area_session_id;
    ogs_pfcp_tlv_f_teid_t n19mb_dl_tunnel_id;
    ogs_pfcp_tlv_mbsn4resp_flags_t mbsn4resp_flags;
} ogs_pfcp_tlv_mbs_session_n4_information_t;

typedef struct ogs_pfcp_tlv_dscp_to_ppi_control_information_s {
    ogs_tlv_presence_t presence;
    ogs_pfcp_tlv_dscp_to_ppi_mapping_information_t dscp_to_ppi_mapping_information;
    ogs_pfcp_tlv_qfi_t qfi;
} ogs_pfcp_tlv_dscp_to_ppi_control_information_t;

/* Structure for Message */
typedef struct ogs_pfcp_heartbeat_request_s {
    ogs_pfcp_tlv_recovery_time_stamp_t recovery_time_stamp;
    ogs_pfcp_tlv_source_ip_address_t source_ip_address;
} ogs_pfcp_heartbeat_request_t;

typedef struct ogs_pfcp_heartbeat_response_s {
    ogs_pfcp_tlv_recovery_time_stamp_t recovery_time_stamp;
} ogs_pfcp_heartbeat_response_t;

typedef struct ogs_pfcp_pfd_management_request_s {
    ogs_pfcp_tlv_application_id_s_pfds_t application_id_s_pfds;
    ogs_pfcp_tlv_node_id_t node_id;
} ogs_pfcp_pfd_management_request_t;

typedef struct ogs_pfcp_pfd_management_response_s {
    ogs_pfcp_tlv_cause_t cause;
    ogs_pfcp_tlv_offending_ie_t offending_ie;
    ogs_pfcp_tlv_node_id_t node_id;
} ogs_pfcp_pfd_management_response_t;

typedef struct ogs_pfcp_association_setup_request_s {
    ogs_pfcp_tlv_node_id_t node_id;
    ogs_pfcp_tlv_recovery_time_stamp_t recovery_time_stamp;
    ogs_pfcp_tlv_up_function_features_t up_function_features;
    ogs_pfcp_tlv_cp_function_features_t cp_function_features;
    ogs_pfcp_tlv_user_plane_ip_resource_information_t user_plane_ip_resource_information[4];
    ogs_pfcp_tlv_alternative_smf_ip_address_t alternative_smf_ip_address;
    ogs_pfcp_tlv_smf_set_id_t smf_set_id;
    ogs_pfcp_tlv_pfcp_session_retention_information_within_pfcp_association_setup_request_t pfcp_session_retention_information;
    ogs_pfcp_tlv_ue_ip_address_t ue_ip_address_pool_information;
    ogs_pfcp_tlv_gtp_u_path_qos_control_information_t gtp_u_path_qos_control_information;
    ogs_pfcp_tlv_clock_drift_control_information_t clock_drift_control_information;
    ogs_pfcp_tlv_nf_instance_id_t upf_instance_id;
    ogs_pfcp_tlv_pfcpasreq_flags_t pfcpasreq_flags;
} ogs_pfcp_association_setup_request_t;

typedef struct ogs_pfcp_association_setup_response_s {
    ogs_pfcp_tlv_node_id_t node_id;
    ogs_pfcp_tlv_cause_t cause;
    ogs_pfcp_tlv_recovery_time_stamp_t recovery_time_stamp;
    ogs_pfcp_tlv_up_function_features_t up_function_features;
    ogs_pfcp_tlv_cp_function_features_t cp_function_features;
    ogs_pfcp_tlv_user_plane_ip_resource_information_t user_plane_ip_resource_information[4];
    ogs_pfcp_tlv_alternative_smf_ip_address_t alternative_smf_ip_address;
    ogs_pfcp_tlv_smf_set_id_t smf_set_id;
    ogs_pfcp_tlv_pfcpasrsp_flags_t pfcpasrsp_flags;
    ogs_pfcp_tlv_clock_drift_control_information_t clock_drift_control_information;
    ogs_pfcp_tlv_ue_ip_address_t ue_ip_address_pool_information;
    ogs_pfcp_tlv_gtp_u_path_qos_control_information_t gtp_u_path_qos_control_information;
    ogs_pfcp_tlv_nf_instance_id_t upf_instance_id;
} ogs_pfcp_association_setup_response_t;

typedef struct ogs_pfcp_association_update_request_s {
    ogs_pfcp_tlv_node_id_t node_id;
    ogs_pfcp_tlv_up_function_features_t up_function_features;
    ogs_pfcp_tlv_cp_function_features_t cp_function_features;
    ogs_pfcp_tlv_user_plane_ip_resource_information_t user_plane_ip_resource_information[4];
    ogs_pfcp_tlv_pfcp_association_release_request_t pfcp_association_release_request;
    ogs_pfcp_tlv_graceful_release_period_t graceful_release_period;
    ogs_pfcp_tlv_pfcpaureq_flags_t pfcpaureq_flags;
    ogs_pfcp_tlv_alternative_smf_ip_address_t alternative_smf_ip_address;
    ogs_pfcp_tlv_smf_set_id_t smf_set_id;
    ogs_pfcp_tlv_clock_drift_control_information_t clock_drift_control_information;
    ogs_pfcp_tlv_ue_ip_address_t ue_ip_address_pool_information;
    ogs_pfcp_tlv_gtp_u_path_qos_control_information_t gtp_u_path_qos_control_information;
    ogs_pfcp_tlv_ue_ip_address_usage_information_t ue_ip_address_usage_information;
} ogs_pfcp_association_update_request_t;

typedef struct ogs_pfcp_association_update_response_s {
    ogs_pfcp_tlv_node_id_t node_id;
    ogs_pfcp_tlv_cause_t cause;
    ogs_pfcp_tlv_up_function_features_t up_function_features;
    ogs_pfcp_tlv_cp_function_features_t cp_function_features;
    ogs_pfcp_tlv_user_plane_ip_resource_information_t user_plane_ip_resource_information[4];
    ogs_pfcp_tlv_ue_ip_address_usage_information_t ue_ip_address_usage_information;
} ogs_pfcp_association_update_response_t;

typedef struct ogs_pfcp_association_release_request_s {
    ogs_pfcp_tlv_node_id_t node_id;
} ogs_pfcp_association_release_request_t;

typedef struct ogs_pfcp_association_release_response_s {
    ogs_pfcp_tlv_node_id_t node_id;
    ogs_pfcp_tlv_cause_t cause;
} ogs_pfcp_association_release_response_t;

typedef struct ogs_pfcp_version_not_supported_response_s {
} ogs_pfcp_version_not_supported_response_t;

typedef struct ogs_pfcp_node_report_request_s {
    ogs_pfcp_tlv_node_id_t node_id;
    ogs_pfcp_tlv_node_report_type_t node_report_type;
    ogs_pfcp_tlv_vendor_specific_node_report_type_t vendor_specific_node_report_type;
    ogs_pfcp_tlv_user_plane_path_failure_report_t user_plane_path_failure_report;
    ogs_pfcp_tlv_user_plane_path_recovery_report_t user_plane_path_recovery_report;
    ogs_pfcp_tlv_clock_drift_report_t clock_drift_report;
    ogs_pfcp_tlv_gtp_u_path_qos_report_pfcp_node_report_request_t gtp_u_path_qos_report;
    ogs_pfcp_tlv_peer_up_restart_report_t peer_up_restart_report;
} ogs_pfcp_node_report_request_t;

typedef struct ogs_pfcp_node_report_response_s {
    ogs_pfcp_tlv_node_id_t node_id;
    ogs_pfcp_tlv_cause_t cause;
    ogs_pfcp_tlv_offending_ie_t offending_ie;
} ogs_pfcp_node_report_response_t;

typedef struct ogs_pfcp_session_set_deletion_request_s {
    ogs_pfcp_tlv_node_id_t node_id;
    ogs_pfcp_tlv_fq_csid_t sgw_c_fq_csid;
    ogs_pfcp_tlv_fq_csid_t pgw_c_smf_fq_csid;
    ogs_pfcp_tlv_fq_csid_t pgw_u_sgw_u__upf_fq_csid;
    ogs_pfcp_tlv_fq_csid_t twan_fq_csid;
    ogs_pfcp_tlv_fq_csid_t epdg_fq_csid;
    ogs_pfcp_tlv_fq_csid_t mme_fq_csid;
} ogs_pfcp_session_set_deletion_request_t;

typedef struct ogs_pfcp_session_set_deletion_response_s {
    ogs_pfcp_tlv_node_id_t node_id;
    ogs_pfcp_tlv_cause_t cause;
    ogs_pfcp_tlv_offending_ie_t offending_ie;
} ogs_pfcp_session_set_deletion_response_t;

typedef struct ogs_pfcp_session_set_modification_request_s {
    ogs_pfcp_tlv_node_id_t node_id;
    ogs_pfcp_tlv_pfcp_session_change_info_t pfcp_session_change_info;
} ogs_pfcp_session_set_modification_request_t;

typedef struct ogs_pfcp_session_set_modification_response_s {
    ogs_pfcp_tlv_node_id_t node_id;
    ogs_pfcp_tlv_cause_t cause;
    ogs_pfcp_tlv_offending_ie_t offending_ie;
} ogs_pfcp_session_set_modification_response_t;

typedef struct ogs_pfcp_session_establishment_request_s {
    ogs_pfcp_tlv_node_id_t node_id;
    ogs_pfcp_tlv_f_seid_t cp_f_seid;
    ogs_pfcp_tlv_create_pdr_t create_pdr[16];
    ogs_pfcp_tlv_create_far_t create_far[16];
    ogs_pfcp_tlv_create_urr_t create_urr[16];
    ogs_pfcp_tlv_create_qer_t create_qer[4];
    ogs_pfcp_tlv_create_bar_t create_bar;
    ogs_pfcp_tlv_create_traffic_endpoint_t create_traffic_endpoint;
    ogs_pfcp_tlv_pdn_type_t pdn_type;
    ogs_pfcp_tlv_fq_csid_t sgw_c_fq_csid;
    ogs_pfcp_tlv_fq_csid_t mme_fq_csid;
    ogs_pfcp_tlv_fq_csid_t pgw_c_smf_fq_csid;
    ogs_pfcp_tlv_fq_csid_t epdg_fq_csid;
    ogs_pfcp_tlv_fq_csid_t twan_fq_csid;
    ogs_pfcp_tlv_user_plane_inactivity_timer_t user_plane_inactivity_timer;
    ogs_pfcp_tlv_user_id_t user_id;
    ogs_pfcp_tlv_trace_information_t trace_information;
    ogs_pfcp_tlv_apn_dnn_t apn_dnn;
    ogs_pfcp_tlv_create_mar_t create_mar;
    ogs_pfcp_tlv_pfcpsereq_flags_t pfcpsereq_flags;
    ogs_pfcp_tlv_create_bridge_info_for_tsc_t create_bridge_info_for_tsc;
    ogs_pfcp_tlv_create_srr_t create_srr;
    ogs_pfcp_tlv_provide_atsss_control_information_t provide_atsss_control_information;
    ogs_pfcp_tlv_recovery_time_stamp_t recovery_time_stamp;
    ogs_pfcp_tlv_s_nssai_t s_nssai;
    ogs_pfcp_tlv_provide_rds_configuration_information_t provide_rds_configuration_information;
    ogs_pfcp_tlv_rat_type_t rat_type;
    ogs_pfcp_tlv_l2tp_tunnel_information_t l2tp_tunnel_information;
    ogs_pfcp_tlv_l2tp_session_information_t l2tp_session_information;
    ogs_pfcp_tlv_group_id_t group_id;
    ogs_pfcp_tlv_mbs_session_n4mb_control_information_t mbs_session_n4mb_control_information;
    ogs_pfcp_tlv_mbs_session_n4_control_information_t mbs_session_n4_control_information;
    ogs_pfcp_tlv_dscp_to_ppi_control_information_t dscp_to_ppi_control_information;
} ogs_pfcp_session_establishment_request_t;

typedef struct ogs_pfcp_session_establishment_response_s {
    ogs_pfcp_tlv_node_id_t node_id;
    ogs_pfcp_tlv_cause_t cause;
    ogs_pfcp_tlv_offending_ie_t offending_ie;
    ogs_pfcp_tlv_f_seid_t up_f_seid;
    ogs_pfcp_tlv_created_pdr_t created_pdr[16];
    ogs_pfcp_tlv_load_control_information_t load_control_information;
    ogs_pfcp_tlv_overload_control_information_t overload_control_information;
    ogs_pfcp_tlv_fq_csid_t pgw_u_sgw_u__upf_fq_csid;
    ogs_pfcp_tlv_failed_rule_id_t failed_rule_id;
    ogs_pfcp_tlv_created_traffic_endpoint_t created_traffic_endpoint;
    ogs_pfcp_tlv_created_bridge_info_for_tsc_t created_bridge_info_for_tsc;
    ogs_pfcp_tlv_atsss_control_parameters_t atsss_control_parameters;
    ogs_pfcp_tlv_rds_configuration_information_t rds_configuration_information;
    ogs_pfcp_tlv_partial_failure_information_t partial_failure_information;
    ogs_pfcp_tlv_created_l2tp_session_t created_l2tp_session;
    ogs_pfcp_tlv_mbs_session_n4mb_information_t mbs_session_n4mb_information;
    ogs_pfcp_tlv_mbs_session_n4_information_t mbs_session_n4_information;
} ogs_pfcp_session_establishment_response_t;

typedef struct ogs_pfcp_session_modification_request_s {
    ogs_pfcp_tlv_f_seid_t cp_f_seid;
    ogs_pfcp_tlv_remove_pdr_t remove_pdr[16];
    ogs_pfcp_tlv_remove_far_t remove_far[16];
    ogs_pfcp_tlv_remove_urr_t remove_urr[16];
    ogs_pfcp_tlv_remove_qer_t remove_qer[4];
    ogs_pfcp_tlv_remove_bar_t remove_bar;
    ogs_pfcp_tlv_remove_traffic_endpoint_t remove_traffic_endpoint;
    ogs_pfcp_tlv_create_pdr_t create_pdr[16];
    ogs_pfcp_tlv_create_far_t create_far[16];
    ogs_pfcp_tlv_create_urr_t create_urr[16];
    ogs_pfcp_tlv_create_qer_t create_qer[4];
    ogs_pfcp_tlv_create_bar_t create_bar;
    ogs_pfcp_tlv_create_traffic_endpoint_t create_traffic_endpoint;
    ogs_pfcp_tlv_update_pdr_t update_pdr[16];
    ogs_pfcp_tlv_update_far_t update_far[16];
    ogs_pfcp_tlv_update_urr_t update_urr[16];
    ogs_pfcp_tlv_update_qer_t update_qer[4];
    ogs_pfcp_tlv_update_bar_session_modification_request_t update_bar;
    ogs_pfcp_tlv_update_traffic_endpoint_t update_traffic_endpoint;
    ogs_pfcp_tlv_pfcpsmreq_flags_t pfcpsmreq_flags;
    ogs_pfcp_tlv_query_urr_t query_urr;
    ogs_pfcp_tlv_fq_csid_t pgw_c_smf_fq_csid;
    ogs_pfcp_tlv_fq_csid_t sgw_c_fq_csid;
    ogs_pfcp_tlv_fq_csid_t mme_fq_csid;
    ogs_pfcp_tlv_fq_csid_t epdg_fq_csid;
    ogs_pfcp_tlv_fq_csid_t twan_fq_csid;
    ogs_pfcp_tlv_user_plane_inactivity_timer_t user_plane_inactivity_timer;
    ogs_pfcp_tlv_query_urr_reference_t query_urr_reference;
    ogs_pfcp_tlv_trace_information_t trace_information;
    ogs_pfcp_tlv_remove_mar_t remove_mar;
    ogs_pfcp_tlv_update_mar_t update_mar;
    ogs_pfcp_tlv_create_mar_t create_mar;
    ogs_pfcp_tlv_node_id_t node_id;
    ogs_pfcp_tlv_tsc_management_information_ie_within_pfcp_session_modification_request_t tsc_management_information;
    ogs_pfcp_tlv_remove_srr_t remove_srr;
    ogs_pfcp_tlv_create_srr_t create_srr;
    ogs_pfcp_tlv_update_srr_t update_srr;
    ogs_pfcp_tlv_provide_atsss_control_information_t provide_atsss_control_information;
    ogs_pfcp_tlv_ethernet_context_information_t ethernet_context_information;
    ogs_pfcp_tlv_access_availability_information_t access_availability_information;
    ogs_pfcp_tlv_query_packet_rate_status_ie_within_pfcp_session_modification_request_t query_packet_rate_status;
    ogs_pfcp_tlv_s_nssai_t s_nssai;
    ogs_pfcp_tlv_rat_type_t rat_type;
    ogs_pfcp_tlv_group_id_t group_id;
    ogs_pfcp_tlv_mbs_session_n4_control_information_t mbs_session_n4_control_information;
    ogs_pfcp_tlv_dscp_to_ppi_control_information_t dscp_to_ppi_control_information;
} ogs_pfcp_session_modification_request_t;

typedef struct ogs_pfcp_session_modification_response_s {
    ogs_pfcp_tlv_cause_t cause;
    ogs_pfcp_tlv_offending_ie_t offending_ie;
    ogs_pfcp_tlv_created_pdr_t created_pdr[16];
    ogs_pfcp_tlv_load_control_information_t load_control_information;
    ogs_pfcp_tlv_overload_control_information_t overload_control_information;
    ogs_pfcp_tlv_usage_report_session_modification_response_t usage_report[8];
    ogs_pfcp_tlv_failed_rule_id_t failed_rule_id;
    ogs_pfcp_tlv_additional_usage_reports_information_t additional_usage_reports_information;
    ogs_pfcp_tlv_created_traffic_endpoint_t created_updated_traffic_endpoint;
    ogs_pfcp_tlv_tsc_management_information_ie_within_pfcp_session_modification_request_t tsc_management_information;
    ogs_pfcp_tlv_atsss_control_parameters_t atsss_control_parameters;
    ogs_pfcp_tlv_updated_pdr_t updated_pdr;
    ogs_pfcp_tlv_packet_rate_status_report_t packet_rate_status_report;
    ogs_pfcp_tlv_partial_failure_information_t partial_failure_information;
    ogs_pfcp_tlv_mbs_session_n4_information_t mbs_session_n4_information;
} ogs_pfcp_session_modification_response_t;

typedef struct ogs_pfcp_session_deletion_request_s {
} ogs_pfcp_session_deletion_request_t;

typedef struct ogs_pfcp_session_deletion_response_s {
    ogs_pfcp_tlv_cause_t cause;
    ogs_pfcp_tlv_offending_ie_t offending_ie;
    ogs_pfcp_tlv_load_control_information_t load_control_information;
    ogs_pfcp_tlv_overload_control_information_t overload_control_information;
    ogs_pfcp_tlv_usage_report_session_deletion_response_t usage_report[8];
    ogs_pfcp_tlv_additional_usage_reports_information_t additional_usage_reports_information;
    ogs_pfcp_tlv_packet_rate_status_report_t packet_rate_status_report;
    ogs_pfcp_tlv_session_report_t session_report;
    ogs_pfcp_tlv_mbs_session_n4_information_t mbs_session_n4_information;
    ogs_pfcp_tlv_pfcpsdrsp_flags_t pfcpsdrsp_flags;
} ogs_pfcp_session_deletion_response_t;

typedef struct ogs_pfcp_session_report_request_s {
    ogs_pfcp_tlv_report_type_t report_type;
    ogs_pfcp_tlv_downlink_data_report_t downlink_data_report;
    ogs_pfcp_tlv_usage_report_session_report_request_t usage_report[8];
    ogs_pfcp_tlv_error_indication_report_t error_indication_report;
    ogs_pfcp_tlv_load_control_information_t load_control_information;
    ogs_pfcp_tlv_overload_control_information_t overload_control_information;
    ogs_pfcp_tlv_additional_usage_reports_information_t additional_usage_reports_information;
    ogs_pfcp_tlv_pfcpsrreq_flags_t pfcpsrreq_flags;
    ogs_pfcp_tlv_f_seid_t old_cp_f_seid;
    ogs_pfcp_tlv_packet_rate_status_report_t packet_rate_status_report;
    ogs_pfcp_tlv_tsc_management_information_ie_within_pfcp_session_modification_request_t tsc_management_information;
    ogs_pfcp_tlv_session_report_t session_report;
    ogs_pfcp_tlv_cause_t cause;
} ogs_pfcp_session_report_request_t;

typedef struct ogs_pfcp_session_report_response_s {
    ogs_pfcp_tlv_cause_t cause;
    ogs_pfcp_tlv_offending_ie_t offending_ie;
    ogs_pfcp_tlv_update_bar_pfcp_session_report_response_t update_bar;
    ogs_pfcp_tlv_pfcpsrrsp_flags_t pfcpsrrsp_flags;
    ogs_pfcp_tlv_f_seid_t cp_f_seid;
    ogs_pfcp_tlv_f_teid_t n4_u_f_teid;
    ogs_pfcp_tlv_alternative_smf_ip_address_t alternative_smf_ip_address;
    ogs_pfcp_tlv_fq_csid_t pgw_c_smf_fq_csid;
    ogs_pfcp_tlv_group_id_t group_id;
    ogs_pfcp_tlv_node_id_t node_id;
} ogs_pfcp_session_report_response_t;

typedef struct ogs_pfcp_message_s {
   ogs_pfcp_header_t h;
   union {
        ogs_pfcp_heartbeat_request_t pfcp_heartbeat_request;
        ogs_pfcp_heartbeat_response_t pfcp_heartbeat_response;
        ogs_pfcp_pfd_management_request_t pfcp_pfd_management_request;
        ogs_pfcp_pfd_management_response_t pfcp_pfd_management_response;
        ogs_pfcp_association_setup_request_t pfcp_association_setup_request;
        ogs_pfcp_association_setup_response_t pfcp_association_setup_response;
        ogs_pfcp_association_update_request_t pfcp_association_update_request;
        ogs_pfcp_association_update_response_t pfcp_association_update_response;
        ogs_pfcp_association_release_request_t pfcp_association_release_request;
        ogs_pfcp_association_release_response_t pfcp_association_release_response;
        ogs_pfcp_version_not_supported_response_t pfcp_version_not_supported_response;
        ogs_pfcp_node_report_request_t pfcp_node_report_request;
        ogs_pfcp_node_report_response_t pfcp_node_report_response;
        ogs_pfcp_session_set_deletion_request_t pfcp_session_set_deletion_request;
        ogs_pfcp_session_set_deletion_response_t pfcp_session_set_deletion_response;
        ogs_pfcp_session_set_modification_request_t pfcp_session_set_modification_request;
        ogs_pfcp_session_set_modification_response_t pfcp_session_set_modification_response;
        ogs_pfcp_session_establishment_request_t pfcp_session_establishment_request;
        ogs_pfcp_session_establishment_response_t pfcp_session_establishment_response;
        ogs_pfcp_session_modification_request_t pfcp_session_modification_request;
        ogs_pfcp_session_modification_response_t pfcp_session_modification_response;
        ogs_pfcp_session_deletion_request_t pfcp_session_deletion_request;
        ogs_pfcp_session_deletion_response_t pfcp_session_deletion_response;
        ogs_pfcp_session_report_request_t pfcp_session_report_request;
        ogs_pfcp_session_report_response_t pfcp_session_report_response;
   };
} ogs_pfcp_message_t;

ogs_pfcp_message_t *ogs_pfcp_parse_msg(ogs_pkbuf_t *pkbuf);
void ogs_pfcp_message_free(ogs_pfcp_message_t *pfcp_message);
ogs_pkbuf_t *ogs_pfcp_build_msg(ogs_pfcp_message_t *pfcp_message);

#ifdef __cplusplus
}
#endif

#endif /* OGS_PFCP_MESSAGE_H */
===== ogs-pfcp.h =====

#ifndef OGS_PFCP_H
#define OGS_PFCP_H

#include "pfcp/pfcp-config.h"

#include "gtp/ogs-gtp.h"

#define OGS_PFCP_UDP_PORT               8805

#define OGS_MAX_NUM_OF_PDR              16
#define OGS_MAX_NUM_OF_FAR              16
#define OGS_MAX_NUM_OF_URR              16
#define OGS_MAX_NUM_OF_QER              4
#define OGS_MAX_NUM_OF_BAR              1

#define OGS_PFCP_INSIDE

#include "pfcp/message.h"
#include "pfcp/types.h"
#include "pfcp/conv.h"
#include "pfcp/context.h"
#include "pfcp/rule-match.h"
#include "pfcp/build.h"
#include "pfcp/path.h"
#include "pfcp/xact.h"
#include "pfcp/handler.h"
#include "pfcp/util.h"

#ifdef __cplusplus
extern "C" {
#endif

#undef OGS_PFCP_INSIDE

extern int __ogs_pfcp_domain;

#undef OGS_LOG_DOMAIN
#define OGS_LOG_DOMAIN __ogs_pfcp_domain

#ifdef __cplusplus
}
#endif

#endif /* OGS_PFCP_H */
===== path.c =====

#include "ogs-pfcp.h"

ogs_sock_t *ogs_pfcp_server(ogs_socknode_t *node)
{
    char buf[OGS_ADDRSTRLEN];
    ogs_sock_t *pfcp;
    ogs_assert(node);

    pfcp = ogs_udp_server(node->addr, node->option);
    if (pfcp) {
        ogs_info("pfcp_server() [%s]:%d",
                OGS_ADDR(node->addr, buf), OGS_PORT(node->addr));

        node->sock = pfcp;
    }

    return pfcp;
}

/* Minimum PFCP header length (e.g., 12 bytes) */
#define MIN_PFCP_HEADER_LENGTH 12

/*
 * ogs_pfcp_recvfrom
 *
 * Receives a PFCP message from the socket 'fd'. It allocates a pkbuf,
 * receives the message, trims the pkbuf, and verifies the header.
 * If any error occurs (e.g., too short message, unsupported version, or
 * incomplete message), the function frees the pkbuf and returns NULL.
 *
 * The sender's address is stored in 'from'.
 *
 * Returns a pointer to ogs_pkbuf_t on success, or NULL on failure.
 */
ogs_pkbuf_t *ogs_pfcp_recvfrom(ogs_socket_t fd, ogs_sockaddr_t *from)
{
    ogs_pkbuf_t *pkbuf;
    ssize_t size;
    ogs_pfcp_header_t *h;
    uint16_t pfcp_body_length;
    size_t expected_total_length;

    ogs_assert(fd != INVALID_SOCKET);
    ogs_assert(from);

    /* Allocate buffer for maximum SDU length */
    pkbuf = ogs_pkbuf_alloc(NULL, OGS_MAX_SDU_LEN);
    if (pkbuf == NULL) {
        ogs_error("ogs_pkbuf_alloc() failed");
        return NULL;
    }
    ogs_pkbuf_put(pkbuf, OGS_MAX_SDU_LEN);

    size = ogs_recvfrom(fd, pkbuf->data, pkbuf->len, 0, from);
    if (size <= 0) {
        ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,
            "ogs_recvfrom() failed");
        ogs_pkbuf_free(pkbuf);
        return NULL;
    }
    ogs_pkbuf_trim(pkbuf, size);

    /* Check that the data is at least as long as the header */
    if (size < MIN_PFCP_HEADER_LENGTH) {
        ogs_error("Received PFCP message too short: %ld bytes (min %d)",
            (long)size, MIN_PFCP_HEADER_LENGTH);
        ogs_pkbuf_free(pkbuf);
        return NULL;
    }

    h = (ogs_pfcp_header_t *)pkbuf->data;

    /* Verify PFCP version */
    if (h->version != OGS_PFCP_VERSION) {
        ogs_pfcp_header_t rsp;
        memset(&rsp, 0, sizeof(rsp));
        ogs_error("Not supported version[%d]", h->version);
        rsp.flags = (OGS_PFCP_VERSION << 5);
        rsp.type = OGS_PFCP_VERSION_NOT_SUPPORTED_RESPONSE_TYPE;
        rsp.length = htobe16(4);
        rsp.sqn_only = h->sqn_only;
        if (ogs_sendto(fd, &rsp, 8, 0, from) < 0) {
            ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,
                "ogs_sendto() failed");
        }
        ogs_pkbuf_free(pkbuf);
        return NULL;
    }

    /* Check total PFCP message length.
       Assume the header's length field indicates the body length,
       excluding the first 4 bytes. */
    pfcp_body_length = be16toh(h->length);
    expected_total_length = pfcp_body_length + 4;
    if ((size_t)size != expected_total_length) {
        ogs_error("Invalid PFCP Header Length: expected %zu bytes, "
            "received %ld bytes", expected_total_length, (long)size);
        ogs_pkbuf_free(pkbuf);
        return NULL;
    }

    return pkbuf;
}

int ogs_pfcp_sendto(ogs_pfcp_node_t *node, ogs_pkbuf_t *pkbuf)
{
    ssize_t sent;
    ogs_sock_t *sock = NULL;
    ogs_sockaddr_t *addr = NULL;

    ogs_assert(node);
    ogs_assert(pkbuf);
    ogs_assert(node->addr_list);

    /* Initialize round-robin iterator if needed */
    if (node->current_addr == NULL) {
        node->current_addr = node->addr_list;
    }
    addr = node->current_addr;
    ogs_assert(addr);

    if (addr->ogs_sa_family == AF_INET) {
        sock = ogs_pfcp_self()->pfcp_sock;
        if (!sock) {
            ogs_error("IPv4 socket (pfcp_sock) is not available. "
                    "Ensure that 'pfcp.server.address: 127.0.0.1' "
                    "is set in the YAML configuration file.");
            return OGS_ERROR;
        }
    } else if (addr->ogs_sa_family == AF_INET6) {
        sock = ogs_pfcp_self()->pfcp_sock6;
        if (!sock) {
            ogs_error("IPv6 socket (pfcp_sock) is not available. "
                    "Ensure that 'pfcp.server.address: [::1]' "
                    "is set in the YAML configuration file.");
            return OGS_ERROR;
        }
    } else
        ogs_assert_if_reached();

    sent = ogs_sendto(sock->fd, pkbuf->data, pkbuf->len, 0, addr);
    if (sent < 0 || sent != pkbuf->len) {
        if (ogs_socket_errno != OGS_EAGAIN) {
            char buf[OGS_ADDRSTRLEN];
            int err = ogs_socket_errno;
            ogs_log_message(OGS_LOG_ERROR, err,
                    "ogs_sendto(%u, %p, %u, 0, %s:%u) failed",
                    sock->fd, pkbuf->data, pkbuf->len,
                    OGS_ADDR(addr, buf), OGS_PORT(addr));
        }
        return OGS_ERROR;
    }

    /* Move to next address in round-robin sequence */
    if (node->current_addr->next)
        node->current_addr = node->current_addr->next;
    else
        /* If end of list reached, wrap around to the start */
        node->current_addr = node->addr_list;

    return OGS_OK;
}

int ogs_pfcp_send_heartbeat_request(ogs_pfcp_node_t *node,
        void (*cb)(ogs_pfcp_xact_t *xact, void *data))
{
    int rv;
    ogs_pkbuf_t *pkbuf = NULL;
    ogs_pfcp_header_t h;
    ogs_pfcp_xact_t *xact = NULL;

    ogs_assert(node);

    memset(&h, 0, sizeof(ogs_pfcp_header_t));
    h.type = OGS_PFCP_HEARTBEAT_REQUEST_TYPE;
    h.seid = 0;

    xact = ogs_pfcp_xact_local_create(node, cb, node);
    if (!xact) {
        ogs_error("ogs_pfcp_xact_local_create() failed");
        return OGS_ERROR;
    }

    pkbuf = ogs_pfcp_build_heartbeat_request(h.type);
    if (!pkbuf) {
        ogs_error("ogs_pfcp_build_heartbeat_request() failed");
        return OGS_ERROR;
    }

    rv = ogs_pfcp_xact_update_tx(xact, &h, pkbuf);
    if (rv != OGS_OK) {
        ogs_error("ogs_pfcp_xact_update_tx() failed");
        return OGS_ERROR;
    }

    rv = ogs_pfcp_xact_commit(xact);
    ogs_expect(rv == OGS_OK);

    return rv;
}

int ogs_pfcp_send_heartbeat_response(ogs_pfcp_xact_t *xact)
{
    int rv;
    ogs_pkbuf_t *pkbuf = NULL;
    ogs_pfcp_header_t h;

    ogs_assert(xact);

    memset(&h, 0, sizeof(ogs_pfcp_header_t));
    h.type = OGS_PFCP_HEARTBEAT_RESPONSE_TYPE;
    h.seid = 0;

    pkbuf = ogs_pfcp_build_heartbeat_response(h.type);
    if (!pkbuf) {
        ogs_error("ogs_pfcp_build_heartbeat_response() failed");
        return OGS_ERROR;
    }

    rv = ogs_pfcp_xact_update_tx(xact, &h, pkbuf);
    if (rv != OGS_OK) {
        ogs_error("ogs_pfcp_xact_update_tx() failed");
        return OGS_ERROR;
    }

    rv = ogs_pfcp_xact_commit(xact);
    ogs_expect(rv == OGS_OK);

    /*
     * Force delete the PFCP transaction to check the PFCP recovery timestamp.
     *
     * Otherwise, duplicated request (lib/pfcp/xact.c:384) prevents the message
     * from being passed to the state machine, so the PFCP recovery timestamp
     * cannot be delivered in the handler routine.
     */
    ogs_pfcp_xact_delete(xact);

    return rv;
}

int ogs_pfcp_cp_send_association_setup_request(ogs_pfcp_node_t *node,
        void (*cb)(ogs_pfcp_xact_t *xact, void *data))
{
    int rv;
    ogs_pkbuf_t *pkbuf = NULL;
    ogs_pfcp_header_t h;
    ogs_pfcp_xact_t *xact = NULL;

    ogs_assert(node);

    memset(&h, 0, sizeof(ogs_pfcp_header_t));
    h.type = OGS_PFCP_ASSOCIATION_SETUP_REQUEST_TYPE;
    h.seid = 0;

    xact = ogs_pfcp_xact_local_create(node, cb, node);
    if (!xact) {
        ogs_error("ogs_pfcp_xact_local_create() failed");
        return OGS_ERROR;
    }

    pkbuf = ogs_pfcp_cp_build_association_setup_request(h.type);
    if (!pkbuf) {
        ogs_error("ogs_pfcp_cp_build_association_setup_request() failed");
        return OGS_ERROR;
    }

    rv = ogs_pfcp_xact_update_tx(xact, &h, pkbuf);
    if (rv != OGS_OK) {
        ogs_error("ogs_pfcp_xact_update_tx() failed");
        return OGS_ERROR;
    }

    rv = ogs_pfcp_xact_commit(xact);
    ogs_expect(rv == OGS_OK);

    return rv;
}

int ogs_pfcp_cp_send_association_setup_response(ogs_pfcp_xact_t *xact,
        uint8_t cause)
{
    int rv;
    ogs_pkbuf_t *pkbuf = NULL;
    ogs_pfcp_header_t h;

    ogs_assert(xact);

    memset(&h, 0, sizeof(ogs_pfcp_header_t));
    h.type = OGS_PFCP_ASSOCIATION_SETUP_RESPONSE_TYPE;
    h.seid = 0;

    pkbuf = ogs_pfcp_cp_build_association_setup_response(h.type, cause);
    if (!pkbuf) {
        ogs_error("ogs_pfcp_cp_build_association_setup_response() failed");
        return OGS_ERROR;
    }

    rv = ogs_pfcp_xact_update_tx(xact, &h, pkbuf);
    if (rv != OGS_OK) {
        ogs_error("ogs_pfcp_xact_update_tx() failed");
        return OGS_ERROR;
    }

    rv = ogs_pfcp_xact_commit(xact);
    ogs_expect(rv == OGS_OK);

    return rv;
}

int ogs_pfcp_up_send_association_setup_request(ogs_pfcp_node_t *node,
        void (*cb)(ogs_pfcp_xact_t *xact, void *data))
{
    int rv;
    ogs_pkbuf_t *pkbuf = NULL;
    ogs_pfcp_header_t h;
    ogs_pfcp_xact_t *xact = NULL;

    ogs_assert(node);

    memset(&h, 0, sizeof(ogs_pfcp_header_t));
    h.type = OGS_PFCP_ASSOCIATION_SETUP_REQUEST_TYPE;
    h.seid = 0;

    xact = ogs_pfcp_xact_local_create(node, cb, node);
    if (!xact) {
        ogs_error("ogs_pfcp_xact_local_create() failed");
        return OGS_ERROR;
    }

    pkbuf = ogs_pfcp_up_build_association_setup_request(h.type);
    if (!pkbuf) {
        ogs_error("ogs_pfcp_build_heartbeat_request() failed");
        return OGS_ERROR;
    }

    rv = ogs_pfcp_xact_update_tx(xact, &h, pkbuf);
    if (rv != OGS_OK) {
        ogs_error("ogs_pfcp_xact_update_tx() failed");
        return OGS_ERROR;
    }

    rv = ogs_pfcp_xact_commit(xact);
    ogs_expect(rv == OGS_OK);

    return rv;
}

int ogs_pfcp_up_send_association_setup_response(ogs_pfcp_xact_t *xact,
        uint8_t cause)
{
    int rv;
    ogs_pkbuf_t *pkbuf = NULL;
    ogs_pfcp_header_t h;

    ogs_assert(xact);

    memset(&h, 0, sizeof(ogs_pfcp_header_t));
    h.type = OGS_PFCP_ASSOCIATION_SETUP_RESPONSE_TYPE;
    h.seid = 0;

    pkbuf = ogs_pfcp_up_build_association_setup_response(h.type, cause);
    if (!pkbuf) {
        ogs_error("ogs_pfcp_up_build_association_setup_response() failed");
        return OGS_ERROR;
    }

    rv = ogs_pfcp_xact_update_tx(xact, &h, pkbuf);
    if (rv != OGS_OK) {
        ogs_error("ogs_pfcp_xact_update_tx() failed");
        return OGS_ERROR;
    }

    rv = ogs_pfcp_xact_commit(xact);
    ogs_expect(rv == OGS_OK);

    return rv;
}

void ogs_pfcp_send_g_pdu(
        ogs_pfcp_pdr_t *pdr,
        ogs_gtp2_header_desc_t *sendhdr, ogs_pkbuf_t *sendbuf)
{
    ogs_gtp_node_t *gnode = NULL;
    ogs_pfcp_far_t *far = NULL;

    ogs_gtp2_header_desc_t header_desc;

    ogs_assert(pdr);
    ogs_assert(sendhdr);
    ogs_assert(sendbuf);

    far = pdr->far;
    if (!far) {
        ogs_error("No FAR");
        ogs_pkbuf_free(sendbuf);
        return;
    }

    if (far->dst_if == OGS_PFCP_INTERFACE_UNKNOWN) {
        ogs_error("No Destination Interface");
        ogs_pkbuf_free(sendbuf);
        return;
    }

    gnode = far->gnode;
    ogs_assert(gnode);
    ogs_assert(gnode->sock);

    memset(&header_desc, 0, sizeof(header_desc));

    header_desc.type = sendhdr->type;
    header_desc.teid = far->outer_header_creation.teid;

    if (pdr->qer && pdr->qer->qfi) {
        header_desc.pdu_type =
            OGS_GTP2_EXTENSION_HEADER_PDU_TYPE_DL_PDU_SESSION_INFORMATION;
        header_desc.qos_flow_identifier = pdr->qer->qfi;
    }

    if (sendhdr->udp.presence == true) {
        header_desc.udp.presence = sendhdr->udp.presence;
        header_desc.udp.port = sendhdr->udp.port;
    }

    if (sendhdr->pdcp_number_presence == true) {
        header_desc.pdcp_number_presence = sendhdr->pdcp_number_presence;
        header_desc.pdcp_number = sendhdr->pdcp_number;
    }

    ogs_gtp2_send_user_plane(gnode, &header_desc, sendbuf);
}

int ogs_pfcp_send_end_marker(ogs_pfcp_pdr_t *pdr)
{
    ogs_gtp_node_t *gnode = NULL;
    ogs_pfcp_far_t *far = NULL;

    ogs_pkbuf_t *sendbuf = NULL;

    ogs_gtp2_header_desc_t header_desc;

    ogs_assert(pdr);
    far = pdr->far;
    ogs_assert(far);

    gnode = far->gnode;
    if (!gnode) {
        ogs_error("No GTP Node Setup");
        return OGS_DONE;
    }
    if (!gnode->sock) {
        ogs_error("No GTP Socket Setup");
        return OGS_DONE;
    }

    sendbuf = ogs_pkbuf_alloc(NULL, OGS_GTPV1U_5GC_HEADER_LEN);
    if (!sendbuf) {
        ogs_error("ogs_pkbuf_alloc() failed");
        return OGS_ERROR;
    }
    ogs_pkbuf_reserve(sendbuf, OGS_GTPV1U_5GC_HEADER_LEN);

    memset(&header_desc, 0, sizeof(header_desc));

    header_desc.type = OGS_GTPU_MSGTYPE_END_MARKER;
    header_desc.teid = far->outer_header_creation.teid;

    if (pdr->qer && pdr->qer->qfi) {
        header_desc.pdu_type =
            OGS_GTP2_EXTENSION_HEADER_PDU_TYPE_DL_PDU_SESSION_INFORMATION;
        header_desc.qos_flow_identifier = pdr->qer->qfi;
    }

    ogs_gtp2_send_user_plane(gnode, &header_desc, sendbuf);

    return OGS_OK;
}

void ogs_pfcp_send_buffered_packet(ogs_pfcp_pdr_t *pdr)
{
    ogs_pfcp_far_t *far = NULL;
    int i;

    ogs_assert(pdr);
    far = pdr->far;

    if (far && far->gnode) {
        if (far->apply_action & OGS_PFCP_APPLY_ACTION_FORW) {
            for (i = 0; i < far->num_of_buffered_packet; i++) {
                ogs_gtp2_header_desc_t sendhdr;

                memset(&sendhdr, 0, sizeof(sendhdr));
                sendhdr.type = OGS_GTPU_MSGTYPE_GPDU;

                ogs_pfcp_send_g_pdu(
                        pdr, &sendhdr, far->buffered_packet[i]);
            }
            far->num_of_buffered_packet = 0;
        }
    }
}

void ogs_pfcp_send_error_message(
    ogs_pfcp_xact_t *xact, uint64_t seid, uint8_t type,
    uint8_t cause_value, uint16_t offending_ie_value)
{
    int rv;
    ogs_pfcp_message_t errmsg;
    ogs_pfcp_tlv_cause_t *cause = NULL;
    ogs_pfcp_tlv_offending_ie_t *offending_ie = NULL;
    ogs_pkbuf_t *pkbuf = NULL;

    ogs_assert(xact);

    memset(&errmsg, 0, sizeof(ogs_pfcp_message_t));
    errmsg.h.seid = seid;
    errmsg.h.type = type;

    switch (type) {
    case OGS_PFCP_PFD_MANAGEMENT_RESPONSE_TYPE:
        cause = &errmsg.pfcp_pfd_management_response.cause;
        offending_ie = &errmsg.pfcp_pfd_management_response.offending_ie;
        break;
    case OGS_PFCP_ASSOCIATION_SETUP_RESPONSE_TYPE:
        cause = &errmsg.pfcp_association_setup_response.cause;
        break;
    case OGS_PFCP_ASSOCIATION_UPDATE_RESPONSE_TYPE:
        cause = &errmsg.pfcp_association_update_response.cause;
        break;
    case OGS_PFCP_ASSOCIATION_RELEASE_RESPONSE_TYPE:
        cause = &errmsg.pfcp_association_release_response.cause;
        break;
    case OGS_PFCP_NODE_REPORT_RESPONSE_TYPE:
        cause = &errmsg.pfcp_node_report_response.cause;
        offending_ie = &errmsg.pfcp_node_report_response.offending_ie;
        break;
    case OGS_PFCP_SESSION_SET_DELETION_RESPONSE_TYPE:
        cause = &errmsg.pfcp_session_set_deletion_response.cause;
        offending_ie = &errmsg.pfcp_session_set_deletion_response.offending_ie;
        break;
    case OGS_PFCP_SESSION_ESTABLISHMENT_RESPONSE_TYPE:
        cause = &errmsg.pfcp_session_establishment_response.cause;
        offending_ie = &errmsg.pfcp_session_establishment_response.offending_ie;
        break;
    case OGS_PFCP_SESSION_MODIFICATION_RESPONSE_TYPE:
        cause = &errmsg.pfcp_session_modification_response.cause;
        offending_ie = &errmsg.pfcp_session_modification_response.offending_ie;
        break;
    case OGS_PFCP_SESSION_DELETION_RESPONSE_TYPE:
        cause = &errmsg.pfcp_session_deletion_response.cause;
        offending_ie = &errmsg.pfcp_session_deletion_response.offending_ie;
        break;
    case OGS_PFCP_SESSION_REPORT_RESPONSE_TYPE:
        cause = &errmsg.pfcp_session_report_response.cause;
        offending_ie = &errmsg.pfcp_session_report_response.offending_ie;
        break;
    default:
        ogs_assert_if_reached();
        return;
    }

    ogs_assert(cause);

    cause->presence = 1;
    cause->u8 = cause_value;

    if (offending_ie && offending_ie_value) {
        offending_ie->presence = 1;
        offending_ie->u16 = offending_ie_value;
    }

    pkbuf = ogs_pfcp_build_msg(&errmsg);
    if (!pkbuf) {
        ogs_error("ogs_pfcp_build_msg() failed");
        return;
    }

    rv = ogs_pfcp_xact_update_tx(xact, &errmsg.h, pkbuf);
    if (rv != OGS_OK) {
        ogs_error("ogs_pfcp_xact_update_tx() failed");
        return;
    }

    rv = ogs_pfcp_xact_commit(xact);
    ogs_expect(rv == OGS_OK);
}
===== path.h =====

#if !defined(OGS_PFCP_INSIDE) && !defined(OGS_PFCP_COMPILATION)
#error "This header cannot be included directly."
#endif

#ifndef OGS_PFCP_PATH_H
#define OGS_PFCP_PATH_H

#ifdef __cplusplus
extern "C" {
#endif

#define OGS_SETUP_PFCP_SERVER \
    do { \
        ogs_pfcp_node_t *pfcp_node = NULL; \
        \
        ogs_pfcp_self()->pfcp_sock = \
            ogs_socknode_sock_first(&ogs_pfcp_self()->pfcp_list); \
        ogs_pfcp_self()->pfcp_sock6 = \
            ogs_socknode_sock_first(&ogs_pfcp_self()->pfcp_list6); \
        \
        ogs_assert(ogs_pfcp_self()->pfcp_sock || ogs_pfcp_self()->pfcp_sock6); \
        \
        if (ogs_pfcp_self()->pfcp_sock) \
            ogs_pfcp_self()->pfcp_addr = \
                &ogs_pfcp_self()->pfcp_sock->local_addr; \
        if (ogs_pfcp_self()->pfcp_sock6) \
            ogs_pfcp_self()->pfcp_addr6 = \
                &ogs_pfcp_self()->pfcp_sock6->local_addr; \
        \
        ogs_assert(ogs_pfcp_self()->pfcp_addr || ogs_pfcp_self()->pfcp_addr6); \
        \
        ogs_list_for_each(&ogs_pfcp_self()->pfcp_peer_list, pfcp_node) \
            pfcp_node_fsm_init(pfcp_node, true); \
        \
    } while(0)

typedef struct ogs_pfcp_xact_s ogs_pfcp_xact_t;

ogs_sock_t *ogs_pfcp_server(ogs_socknode_t *node);
int ogs_pfcp_sendto(ogs_pfcp_node_t *node, ogs_pkbuf_t *pkbuf);

ogs_pkbuf_t *ogs_pfcp_recvfrom(ogs_socket_t fd, ogs_sockaddr_t *from);

ogs_pkbuf_t *ogs_pfcp_handle_echo_req(ogs_pkbuf_t *pkt);

int ogs_pfcp_send_heartbeat_request(ogs_pfcp_node_t *node,
        void (*cb)(ogs_pfcp_xact_t *xact, void *data));
int ogs_pfcp_send_heartbeat_response(ogs_pfcp_xact_t *xact);

int ogs_pfcp_cp_send_association_setup_request(ogs_pfcp_node_t *node,
        void (*cb)(ogs_pfcp_xact_t *xact, void *data));
int ogs_pfcp_cp_send_association_setup_response(ogs_pfcp_xact_t *xact,
        uint8_t cause);

int ogs_pfcp_up_send_association_setup_request(ogs_pfcp_node_t *node,
        void (*cb)(ogs_pfcp_xact_t *xact, void *data));
int ogs_pfcp_up_send_association_setup_response(ogs_pfcp_xact_t *xact,
        uint8_t cause);

void ogs_pfcp_send_g_pdu(
        ogs_pfcp_pdr_t *pdr,
        ogs_gtp2_header_desc_t *sendhdr, ogs_pkbuf_t *sendbuf);
int ogs_pfcp_send_end_marker(ogs_pfcp_pdr_t *pdr);

void ogs_pfcp_send_buffered_packet(ogs_pfcp_pdr_t *pdr);

void ogs_pfcp_send_error_message(
    ogs_pfcp_xact_t *xact, uint64_t seid, uint8_t type,
    uint8_t cause_value, uint16_t offending_ie_value);

#ifdef __cplusplus
}
#endif

#endif /* OGS_PFCP_PATH_H */
===== rule-match.c =====

#include "ogs-pfcp.h"

#if HAVE_NETINET_IP_H
#include <netinet/ip.h>
#endif

#if HAVE_NETINET_IP6_H
#include <netinet/ip6.h>
#endif

#if HAVE_NETINET_UDP_H
#include <netinet/udp.h>
#endif

#if HAVE_NETINET_TCP_H
#include <netinet/tcp.h>
#endif

static int decode_ipv6_header(
        struct ip6_hdr *ip6_h, uint8_t *proto, uint16_t *hlen)
{
    int done = 0;
    uint8_t *p, *jp, *endp;
    uint8_t nxt;          /* Next Header */

    ogs_assert(ip6_h);
    ogs_assert(proto);
    ogs_assert(hlen);

    nxt = ip6_h->ip6_nxt;
    p = (uint8_t *)ip6_h + sizeof(*ip6_h);
    endp = p + be16toh(ip6_h->ip6_plen);

    jp = p + sizeof(struct ip6_hbh);
    while (p == endp) { /* Jumbo Frame */
        uint32_t jp_len = 0;
        struct ip6_opt_jumbo *jumbo = NULL;

        ogs_assert(nxt == 0);

        jumbo = (struct ip6_opt_jumbo *)jp;
        memcpy(&jp_len, jumbo->ip6oj_jumbo_len, sizeof(jp_len));
        jp_len = be32toh(jp_len);
        switch (jumbo->ip6oj_type) {
        case IP6OPT_JUMBO:
            endp = p + jp_len;
            break;
        case 0:
            jp++;
            break;
        default:
            jp += (sizeof(struct ip6_opt) + jp_len);
            break;
        }
    }

    while (p < endp) {
        struct ip6_ext *ext = (struct ip6_ext *)p;
        switch (nxt) {
        case IPPROTO_HOPOPTS:
        case IPPROTO_ROUTING:
        case IPPROTO_DSTOPTS:
        case 135: /* mobility */
        case 139: /* host identity, experimental */
        case 140: /* shim6 */
        case 253: /* testing, experimental */
        case 254: /* testing, experimental */
            p += ((ext->ip6e_len << 3) + 8);
            break;
        case IPPROTO_FRAGMENT:
            p += sizeof(struct ip6_frag);
            break;
        case IPPROTO_AH:
            p += ((ext->ip6e_len + 2) << 2);
            break;
        default: /* Upper Layer */
            done = 1;
            break;

        }
        if (done)
            break;

        nxt = ext->ip6e_nxt;
    }

    *proto = nxt;
    *hlen = p - (uint8_t *)ip6_h;

    return OGS_OK;
}

ogs_pfcp_rule_t *ogs_pfcp_pdr_rule_find_by_packet(
                    ogs_pfcp_pdr_t *pdr, ogs_pkbuf_t *pkbuf)
{
    struct ip *ip_h =  NULL;
    struct ip6_hdr *ip6_h = NULL;
    uint32_t *src_addr = NULL;
    uint32_t *dst_addr = NULL;
    int addr_len = 0;
    uint8_t proto = 0;
    uint16_t ip_hlen = 0;

    ogs_pfcp_rule_t *rule = NULL;

    ogs_assert(pkbuf);
    ogs_assert(pkbuf->len);
    ogs_assert(pkbuf->data);

    ogs_list_for_each(&pdr->rule_list, rule) {
        int k;
        uint32_t src_mask[4];
        uint32_t dst_mask[4];
        ogs_ipfw_rule_t *ipfw = NULL;

        ipfw = &rule->ipfw;
        ogs_assert(ipfw);

        ip_h = (struct ip *)pkbuf->data;
        if (ip_h->ip_v == 4) {
            ip_h = (struct ip *)pkbuf->data;
            ip6_h = NULL;

            proto = ip_h->ip_p;
            ip_hlen = (ip_h->ip_hl)*4;

            src_addr = (void *)&ip_h->ip_src.s_addr;
            dst_addr = (void *)&ip_h->ip_dst.s_addr;
            addr_len = OGS_IPV4_LEN;
        } else if (ip_h->ip_v == 6) {
            ip_h = NULL;
            ip6_h = (struct ip6_hdr *)pkbuf->data;

            decode_ipv6_header(ip6_h, &proto, &ip_hlen);

            src_addr = (void *)ip6_h->ip6_src.s6_addr;
            dst_addr = (void *)ip6_h->ip6_dst.s6_addr;
            addr_len = OGS_IPV6_LEN;
        } else {
            ogs_error("Invalid packet [IP version:%d, Packet Length:%d]",
                    ip_h->ip_v, pkbuf->len);
            ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);
            continue;
        }

        ogs_trace("PROTO:%d SRC:%08x %08x %08x %08x",
                proto, be32toh(src_addr[0]), be32toh(src_addr[1]),
                be32toh(src_addr[2]), be32toh(src_addr[3]));
        ogs_trace("HLEN:%d  DST:%08x %08x %08x %08x",
                ip_hlen, be32toh(dst_addr[0]), be32toh(dst_addr[1]),
                be32toh(dst_addr[2]), be32toh(dst_addr[3]));

        ogs_trace("PROTO:%d SRC:%d-%d DST:%d-%d",
                ipfw->proto,
                ipfw->port.src.low,
                ipfw->port.src.high,
                ipfw->port.dst.low,
                ipfw->port.dst.high);
        ogs_trace("SRC:%08x %08x %08x %08x/%08x %08x %08x %08x",
                be32toh(ipfw->ip.src.addr[0]),
                be32toh(ipfw->ip.src.addr[1]),
                be32toh(ipfw->ip.src.addr[2]),
                be32toh(ipfw->ip.src.addr[3]),
                be32toh(ipfw->ip.src.mask[0]),
                be32toh(ipfw->ip.src.mask[1]),
                be32toh(ipfw->ip.src.mask[2]),
                be32toh(ipfw->ip.src.mask[3]));
        ogs_trace("DST:%08x %08x %08x %08x/%08x %08x %08x %08x",
                be32toh(ipfw->ip.dst.addr[0]),
                be32toh(ipfw->ip.dst.addr[1]),
                be32toh(ipfw->ip.dst.addr[2]),
                be32toh(ipfw->ip.dst.addr[3]),
                be32toh(ipfw->ip.dst.mask[0]),
                be32toh(ipfw->ip.dst.mask[1]),
                be32toh(ipfw->ip.dst.mask[2]),
                be32toh(ipfw->ip.dst.mask[3]));

        for (k = 0; k < 4; k++) {
            src_mask[k] = src_addr[k] & ipfw->ip.src.mask[k];
            dst_mask[k] = dst_addr[k] & ipfw->ip.dst.mask[k];
        }

        if (memcmp(src_mask, ipfw->ip.src.addr, addr_len) == 0 &&
            memcmp(dst_mask, ipfw->ip.dst.addr, addr_len) == 0) {
            /* Protocol match */
            if (ipfw->proto == 0) { /* IP */
                /* No need to match port */
                return rule;
            }

            if (ipfw->proto == proto) {
                if (ipfw->proto == IPPROTO_TCP) {
                    struct tcphdr *tcph =
                        (struct tcphdr *)((char *)pkbuf->data + ip_hlen);

                    /* Source port */
                    if (ipfw->port.src.low &&
                          be16toh(tcph->th_sport) < ipfw->port.src.low) {
                        continue;
                    }

                    if (ipfw->port.src.high &&
                          be16toh(tcph->th_sport) > ipfw->port.src.high) {
                        continue;
                    }

                    /* Dst Port*/
                    if (ipfw->port.dst.low &&
                          be16toh(tcph->th_dport) < ipfw->port.dst.low) {
                        continue;
                    }

                    if (ipfw->port.dst.high &&
                          be16toh(tcph->th_dport) > ipfw->port.dst.high) {
                        continue;
                    }

                    /* Matched */
                    return rule;

                } else if (ipfw->proto == IPPROTO_UDP) {
                    struct udphdr *udph =
                        (struct udphdr *)((char *)pkbuf->data + ip_hlen);

                    /* Source port */
                    if (ipfw->port.src.low &&
                          be16toh(udph->uh_sport) < ipfw->port.src.low) {
                        continue;
                    }

                    if (ipfw->port.src.high &&
                          be16toh(udph->uh_sport) > ipfw->port.src.high) {
                        continue;
                    }

                    /* Dst Port*/
                    if (ipfw->port.dst.low &&
                          be16toh(udph->uh_dport) < ipfw->port.dst.low) {
                        continue;
                    }

                    if (ipfw->port.dst.high &&
                          be16toh(udph->uh_dport) > ipfw->port.dst.high) {
                        continue;
                    }

                    /* Matched */
                    return rule;

                } else {

                    /* No need to match port */
                    return rule;

                }
            }
        }
    }

    return NULL;
}
===== rule-match.h =====

#if !defined(OGS_PFCP_INSIDE) && !defined(OGS_PFCP_COMPILATION)
#error "This header cannot be included directly."
#endif

#ifndef OGS_PFCP_RULE_MATCH_H
#define OGS_PFCP_RULE_MATCH_H

#ifdef __cplusplus
extern "C" {
#endif

ogs_pfcp_rule_t *ogs_pfcp_pdr_rule_find_by_packet(
                    ogs_pfcp_pdr_t *pdr, ogs_pkbuf_t *pkbuf);

#ifdef __cplusplus
}
#endif

#endif /* OGS_PFCP_RULE_MATCH_H */
===== types.c =====

#include "ogs-pfcp.h"

const char *ogs_pfcp_cause_get_name(uint8_t cause)
{
    switch(cause) {
    case OGS_PFCP_CAUSE_REQUEST_ACCEPTED:
        return "OGS_PFCP_CAUSE_REQUEST_ACCEPTED";
        break;
    case OGS_PFCP_CAUSE_REQUEST_REJECTED:
        return "OGS_PFCP_CAUSE_REQUEST_REJECTED";
        break;
    case OGS_PFCP_CAUSE_SESSION_CONTEXT_NOT_FOUND:
        return "OGS_PFCP_CAUSE_SESSION_CONTEXT_NOT_FOUND";
        break;
    case OGS_PFCP_CAUSE_MANDATORY_IE_MISSING:
        return "OGS_PFCP_CAUSE_MANDATORY_IE_MISSING";
        break;
    case OGS_PFCP_CAUSE_CONDITIONAL_IE_MISSING:
        return "OGS_PFCP_CAUSE_CONDITIONAL_IE_MISSING";
        break;
    case OGS_PFCP_CAUSE_INVALID_LENGTH:
        return "OGS_PFCP_CAUSE_INVALID_LENGTH";
        break;
    case OGS_PFCP_CAUSE_MANDATORY_IE_INCORRECT:
        return "OGS_PFCP_CAUSE_MANDATORY_IE_INCORRECT";
        break;
    case OGS_PFCP_CAUSE_INVALID_FORWARDING_POLICY:
        return "OGS_PFCP_CAUSE_INVALID_FORWARDING_POLICY";
        break;
    case OGS_PFCP_CAUSE_INVALID_F_TEID_ALLOCATION_OPTION:
        return "OGS_PFCP_CAUSE_INVALID_F_TEID_ALLOCATION_OPTION";
        break;
    case OGS_PFCP_CAUSE_NO_ESTABLISHED_PFCP_ASSOCIATION:
        return "OGS_PFCP_CAUSE_NO_ESTABLISHED_PFCP_ASSOCIATION";
        break;
    case OGS_PFCP_CAUSE_RULE_CREATION_MODIFICATION_FAILURE:
        return "OGS_PFCP_CAUSE_RULE_CREATION_MODIFICATION_FAILURE";
        break;
    case OGS_PFCP_CAUSE_PFCP_ENTITY_IN_CONGESTION:
        return "OGS_PFCP_CAUSE_PFCP_ENTITY_IN_CONGESTION";
        break;
    case OGS_PFCP_CAUSE_NO_RESOURCES_AVAILABLE:
        return "OGS_PFCP_CAUSE_NO_RESOURCES_AVAILABLE";
        break;
    case OGS_PFCP_CAUSE_SERVICE_NOT_SUPPORTED:
        return "OGS_PFCP_CAUSE_SERVICE_NOT_SUPPORTED";
        break;
    case OGS_PFCP_CAUSE_SYSTEM_FAILURE:
        return "OGS_PFCP_CAUSE_SYSTEM_FAILURE";
        break;
    default:
        break;
    }
    return "OGS_PFCP_CAUSE_UNKNOWN";
}

int16_t ogs_pfcp_build_user_plane_ip_resource_info(
        ogs_tlv_octet_t *octet,
        ogs_user_plane_ip_resource_info_t *info,
        void *data, int data_len)
{
    ogs_user_plane_ip_resource_info_t target;
    int16_t size = 0;

    ogs_assert(info);
    ogs_assert(octet);
    ogs_assert(data);
    ogs_assert(data_len);

    octet->data = data;
    memcpy(&target, info, sizeof(ogs_user_plane_ip_resource_info_t));

    ogs_assert(size + sizeof(target.flags) <= data_len);
    memcpy((unsigned char *)octet->data + size,
            &target.flags, sizeof(target.flags));
    size += sizeof(target.flags);

    if (target.teidri) {
        ogs_assert(size + sizeof(target.teid_range) <= data_len);
        memcpy((unsigned char *)octet->data + size,
                &target.teid_range, sizeof(target.teid_range));
        size += sizeof(target.teid_range);
    }

    if (target.v4) {
        ogs_assert(size + sizeof(target.addr) <= data_len);
        memcpy((unsigned char *)octet->data + size,
                &target.addr, sizeof(target.addr));
        size += sizeof(target.addr);
    }

    if (target.v6) {
        ogs_assert(size + OGS_IPV6_LEN <= data_len);
        memcpy((unsigned char *)octet->data + size,
                &target.addr6, OGS_IPV6_LEN);
        size += OGS_IPV6_LEN;
    }

    if (target.assoni) {
        int len = ogs_fqdn_build((char *)octet->data + size,
                target.network_instance, strlen(target.network_instance));
        size += len;
    }

    if (target.assosi) {
        ogs_assert(size + sizeof(target.source_interface) <= data_len);
        memcpy((unsigned char *)octet->data + size,
                &target.source_interface, sizeof(target.source_interface));
        size += sizeof(target.source_interface);
    }

    octet->len = size;

    return octet->len;
}

int16_t ogs_pfcp_parse_user_plane_ip_resource_info(
        ogs_user_plane_ip_resource_info_t *info,
        ogs_tlv_octet_t *octet)
{
    int16_t size = 0;

    ogs_assert(info);
    ogs_assert(octet);

    memset(info, 0, sizeof(ogs_user_plane_ip_resource_info_t));

    memcpy(&info->flags,
            (unsigned char *)octet->data + size, sizeof(info->flags));
    size++;

    if (info->teidri) {
        if (size + sizeof(info->teid_range) > octet->len) {
            ogs_error("size[%d]+sizeof(info->teid_range)[%d] > IE Length[%d]",
                    size, (int)sizeof(info->teid_range), octet->len);
            return 0;
        }
        memcpy(&info->teid_range, (unsigned char *)octet->data + size,
                sizeof(info->teid_range));
        size += sizeof(info->teid_range);
    }

    if (info->v4) {
        if (size + sizeof(info->addr) > octet->len) {
            ogs_error("size[%d]+sizeof(info->addr)[%d] > IE Length[%d]",
                    size, (int)sizeof(info->addr), octet->len);
            return 0;
        }
        memcpy(&info->addr,
                (unsigned char *)octet->data + size,
                sizeof(info->addr));
        size += sizeof(info->addr);
    }

    if (info->v6) {
        if (size + OGS_IPV6_LEN > octet->len) {
            ogs_error("size[%d]+OGS_IPV6_LEN[%d] > IE Length[%d]",
                    size, (int)OGS_IPV6_LEN, octet->len);
            return 0;
        }
        memcpy(&info->addr6, (unsigned char *)octet->data + size, OGS_IPV6_LEN);
        size += OGS_IPV6_LEN;
    }

    if (info->assoni) {
        int len = octet->len - size;
        if (len <= 0) {
            ogs_error("len[%d] octect->len[%d] size[%d]", len, octet->len, size);
            return 0;
        }

        if (info->assosi) len--;
        if (len <= 0) {
            ogs_error("info->assosi[%d] len[%d] octect->len[%d] size[%d]",
                    info->assosi, len, octet->len, size);
            return 0;
        }

        if (ogs_fqdn_parse(info->network_instance, (char *)octet->data + size,
            ogs_min(len, OGS_MAX_APN_LEN)) <= 0) {
            ogs_error("Invalid info->network_instance");
            info->network_instance[0] = 0;
        }
        size += len;
    }

    if (info->assosi) {
        if (size + sizeof(info->source_interface) > octet->len) {
            ogs_error("size[%d]+sizeof(info->source_interface)[%d] > "
                    "IE Length[%d]",
                    size, (int)sizeof(info->source_interface), octet->len);
            return 0;
        }
        memcpy(&info->source_interface, (unsigned char *)octet->data + size,
                sizeof(info->source_interface));
        size += sizeof(info->source_interface);
    }

    if (size != octet->len)
        ogs_error("Mismatch IE Length[%d] != Decoded[%d]", octet->len, size);

    return size;
}

int16_t ogs_pfcp_build_sdf_filter(
        ogs_tlv_octet_t *octet, ogs_pfcp_sdf_filter_t *filter,
        void *data, int data_len)
{
    ogs_pfcp_sdf_filter_t target;
    int16_t size = 0;

    ogs_assert(filter);
    ogs_assert(octet);
    ogs_assert(data);
    ogs_assert(data_len);

    octet->data = data;
    memcpy(&target, filter, sizeof(ogs_pfcp_sdf_filter_t));

    ogs_assert(size + sizeof(target.flags) <= data_len);
    memcpy((unsigned char *)octet->data + size,
            &target.flags, sizeof(target.flags));
    size += sizeof(target.flags);

    ogs_assert(size + sizeof(target.spare2) <= data_len);
    memcpy((unsigned char *)octet->data + size,
            &target.spare2, sizeof(target.spare2));
    size += sizeof(target.spare2);

    if (target.fd) {
        ogs_assert(size + sizeof(target.flow_description_len) <= data_len);
        target.flow_description_len = htobe16(target.flow_description_len);
        memcpy((unsigned char *)octet->data + size,
                &target.flow_description_len,
                sizeof(target.flow_description_len));
        size += sizeof(target.flow_description_len);

        ogs_assert(size + filter->flow_description_len <= data_len);
        memcpy((char *)octet->data + size,
                filter->flow_description, filter->flow_description_len);
        size += filter->flow_description_len;
    }

    if (target.ttc) {
        ogs_assert(size + sizeof(target.tos_traffic_class) <= data_len);
        target.tos_traffic_class = htobe16(target.tos_traffic_class);
        memcpy((unsigned char *)octet->data + size,
                &target.tos_traffic_class, sizeof(target.tos_traffic_class));
        size += sizeof(target.tos_traffic_class);
    }

    if (target.spi) {
        ogs_assert(size + sizeof(target.security_parameter_index) <= data_len);
        target.security_parameter_index =
            htobe32(target.security_parameter_index);
        memcpy((unsigned char *)octet->data + size,
                &target.security_parameter_index,
                sizeof(target.security_parameter_index));
        size += sizeof(target.security_parameter_index);
    }

    if (target.fl) {
        int bit24_len = 3;
        ogs_assert(size + bit24_len <= data_len);
        target.flow_label = htobe32(target.flow_label);
        memcpy((unsigned char *)octet->data + size,
                &target.flow_label, bit24_len);
        size += bit24_len;
    }

    if (target.bid) {
        ogs_assert(size + sizeof(target.sdf_filter_id) <= data_len);
        target.sdf_filter_id =
            htobe32(target.sdf_filter_id);
        memcpy((unsigned char *)octet->data + size,
                &target.sdf_filter_id, sizeof(target.sdf_filter_id));
        size += sizeof(target.sdf_filter_id);
    }

    octet->len = size;

    return octet->len;
}

int16_t ogs_pfcp_parse_sdf_filter(
        ogs_pfcp_sdf_filter_t *filter, ogs_tlv_octet_t *octet)
{
    int16_t size = 0;

    ogs_assert(filter);
    ogs_assert(octet);

    memset(filter, 0, sizeof(ogs_pfcp_sdf_filter_t));

    if (size + sizeof(filter->flags) > octet->len) {
        ogs_error("size[%d]+sizeof(filter->flags)[%d] > IE Length[%d]",
                size, (int)sizeof(filter->flags), octet->len);
        return 0;
    }
    memcpy(&filter->flags,
            (unsigned char *)octet->data + size, sizeof(filter->flags));
    size++;

    if (size + sizeof(filter->spare2) > octet->len) {
        ogs_error("size[%d]+sizeof(filter->spare2)[%d] > IE Length[%d]",
                size, (int)sizeof(filter->spare2), octet->len);
        return 0;
    }
    memcpy(&filter->spare2,
            (unsigned char *)octet->data + size, sizeof(filter->flags));
    size++;

    if (filter->fd) {
        if (size + sizeof(filter->flow_description_len) > octet->len) {
            ogs_error("size[%d]+sizeof(filter->flow_description_len)[%d] "
                    "> IE Length[%d]",
                    size, (int)sizeof(filter->flow_description_len),
                    octet->len);
            return 0;
        }
        memcpy(&filter->flow_description_len,
                (unsigned char *)octet->data + size,
                sizeof(filter->flow_description_len));
        filter->flow_description_len = be16toh(filter->flow_description_len);
        size += sizeof(filter->flow_description_len);

        filter->flow_description = (char *)octet->data + size;
        size += filter->flow_description_len;
    }

    if (filter->ttc) {
        if (size + sizeof(filter->tos_traffic_class) > octet->len) {
            ogs_error("size[%d]+sizeof(filter->tos_traffic_class)[%d] "
                    "> IE Length[%d]",
                    size, (int)sizeof(filter->tos_traffic_class), octet->len);
            return 0;
        }
        memcpy(&filter->tos_traffic_class,
                (unsigned char *)octet->data + size,
                sizeof(filter->tos_traffic_class));
        filter->tos_traffic_class = be32toh(filter->tos_traffic_class);
        size += sizeof(filter->tos_traffic_class);
    }

    if (filter->spi) {
        if (size + sizeof(filter->security_parameter_index) > octet->len) {
            ogs_error("size[%d]+sizeof(filter->security_parameter_index)[%d] "
                    "> IE Length[%d]",
                    size, (int)sizeof(filter->security_parameter_index),
                    octet->len);
            return 0;
        }
        memcpy(&filter->security_parameter_index,
                (unsigned char *)octet->data + size,
                sizeof(filter->security_parameter_index));
        filter->security_parameter_index =
            be32toh(filter->security_parameter_index);
        size += sizeof(filter->security_parameter_index);
    }

    if (filter->fl) {
        int bit24_len = 3;
        if (size + bit24_len > octet->len) {
            ogs_error("size[%d]+bit24_len[%d] > IE Length[%d]",
                    size, bit24_len, octet->len);
            return 0;
        }
        memcpy(&filter->flow_label,
                (unsigned char *)octet->data + size, bit24_len);
        filter->flow_label = be32toh(filter->flow_label);
        size += bit24_len;
    }

    if (filter->bid) {
        if (size + sizeof(filter->sdf_filter_id) > octet->len) {
            ogs_error("size[%d]+sizeof(filter->sdf_filter_id)[%d]"
                    "> IE Length[%d]",
                    size, (int)sizeof(filter->sdf_filter_id), octet->len);
            return 0;
        }
        memcpy(&filter->sdf_filter_id, (unsigned char *)octet->data + size,
                sizeof(filter->sdf_filter_id));
        filter->sdf_filter_id = be32toh(filter->sdf_filter_id);
        size += sizeof(filter->sdf_filter_id);
    }

    if (size != octet->len)
        ogs_error("Mismatch IE Length[%d] != Decoded[%d]", octet->len, size);

    return size;
}

int16_t ogs_pfcp_build_bitrate(ogs_tlv_octet_t *octet,
        ogs_pfcp_bitrate_t *bitrate, void *data, int data_len)
{
    uint64_t target;
    int16_t size = 0;

    ogs_assert(bitrate);
    ogs_assert(octet);
    ogs_assert(data);
    ogs_assert(data_len >= OGS_PFCP_BITRATE_LEN);

    octet->data = data;

    /*
     * Ch 8.15 Bearer QoS in TS 29.274 v15.9.0
     *
     * The UL/DL MBR and GBR fields are encoded as kilobits
     * per second (1 kbps = 1000 bps) in binary value.
     * The UL/DL MBR and GBR fields may require converting values
     * in bits per second to kilobits per second when the UL/DL MBR
     * and GBR values are received from an interface other than GTPv2
     * interface. If such conversions result in fractions, then
     * the value of UL/DL MBR and GBR fields shall be rounded upwards.
     */
    target = (bitrate->uplink / 1000) + ((bitrate->uplink % 1000) ? 1 : 0);
    ogs_uint64_to_buffer(target, 5,
            (unsigned char *)octet->data + size);
    size += 5;

    target = (bitrate->downlink / 1000) + ((bitrate->downlink % 1000) ? 1 : 0);
    ogs_uint64_to_buffer(target, 5,
            (unsigned char *)octet->data + size);
    size += 5;

    octet->len = size;

    return octet->len;
}
int16_t ogs_pfcp_parse_bitrate(
        ogs_pfcp_bitrate_t *bitrate, ogs_tlv_octet_t *octet)
{
    int16_t size = 0;

    ogs_assert(bitrate);
    ogs_assert(octet);
    ogs_assert(octet->len == OGS_PFCP_BITRATE_LEN);

    memset(bitrate, 0, sizeof(ogs_pfcp_bitrate_t));

    /*
     * Ch 8.15 Bearer QoS in TS 29.274 v15.9.0
     *
     * The UL/DL MBR and GBR fields are encoded as kilobits
     * per second (1 kbps = 1000 bps) in binary value.
     */
    bitrate->uplink = ogs_buffer_to_uint64(
            (unsigned char *)octet->data + size, 5) * 1000;
    size += 5;
    bitrate->downlink = ogs_buffer_to_uint64(
            (unsigned char *)octet->data + size, 5) * 1000;
    size += 5;

    ogs_assert(size == octet->len);

    return size;
}

int16_t ogs_pfcp_build_volume(ogs_tlv_octet_t *octet,
        ogs_pfcp_volume_threshold_t *volume, void *data, int data_len)
{
    ogs_pfcp_volume_threshold_t target;
    int16_t size = 0;

    ogs_assert(volume);
    ogs_assert(octet);
    ogs_assert(data);
    ogs_assert(data_len >= sizeof(ogs_pfcp_volume_threshold_t));

    ogs_assert(volume->flags);

    octet->data = data;
    memcpy(&target, volume, sizeof(ogs_pfcp_volume_threshold_t));

    ((unsigned char *)octet->data)[size] = target.flags;
    size += sizeof(target.flags);

    if (target.tovol) {
        target.total_volume = htobe64(target.total_volume);
        memcpy((unsigned char *)octet->data + size,
                &target.total_volume, sizeof(target.total_volume));
        size += sizeof(target.total_volume);
    }
    if (target.ulvol) {
        target.uplink_volume = htobe64(target.uplink_volume);
        memcpy((unsigned char *)octet->data + size,
                &target.uplink_volume, sizeof(target.uplink_volume));
        size += sizeof(target.uplink_volume);
    }
    if (target.dlvol) {
        target.downlink_volume = htobe64(target.downlink_volume);
        memcpy((unsigned char *)octet->data + size,
                &target.downlink_volume, sizeof(target.downlink_volume));
        size += sizeof(target.downlink_volume);
    }

    octet->len = size;

    return octet->len;
}

void ogs_pfcp_parse_usage_report_trigger(
        ogs_pfcp_usage_report_trigger_t *rep_trig,
        ogs_pfcp_tlv_usage_report_trigger_t *tlv)
{
    rep_trig->reptri_5 = (tlv->u24 >> 16) & 0xff;
    rep_trig->reptri_6 = (tlv->u24 >> 8) & 0xff;
    rep_trig->reptri_7 = (tlv->u24) & 0xff;
}

int16_t ogs_pfcp_parse_volume(
        ogs_pfcp_volume_threshold_t *volume, ogs_tlv_octet_t *octet)
{
    int16_t size = 0;

    ogs_assert(volume);
    ogs_assert(octet);

    memset(volume, 0, sizeof(ogs_pfcp_volume_threshold_t));

    volume->flags = ((unsigned char *)octet->data)[size];
    size += sizeof(volume->flags);

    if (volume->tovol) {
        if (size + sizeof(volume->total_volume) > octet->len) {
            ogs_error("size[%d]+sizeof(volume->total_volume)[%d] "
                    "> IE Length[%d]",
                    size, (int)sizeof(volume->total_volume), octet->len);
            return 0;
        }
        memcpy(&volume->total_volume, (unsigned char *)octet->data + size,
                sizeof(volume->total_volume));
        volume->total_volume = be64toh(volume->total_volume);
        size += sizeof(volume->total_volume);
    }
    if (volume->ulvol) {
        if (size + sizeof(volume->uplink_volume) > octet->len) {
            ogs_error("size[%d]+sizeof(volume->uplink_volume)[%d] "
                    "> IE Length[%d]",
                    size, (int)sizeof(volume->uplink_volume), octet->len);
            return 0;
        }
        memcpy(&volume->uplink_volume, (unsigned char *)octet->data + size,
                sizeof(volume->uplink_volume));
        volume->uplink_volume = be64toh(volume->uplink_volume);
        size += sizeof(volume->uplink_volume);
    }
    if (volume->dlvol) {
        if (size + sizeof(volume->downlink_volume) > octet->len) {
            ogs_error("size[%d]+sizeof(volume->downlink_volume)[%d] "
                    "> IE Length[%d]",
                    size, (int)sizeof(volume->downlink_volume), octet->len);
            return 0;
        }
        memcpy(&volume->downlink_volume, (unsigned char *)octet->data + size,
                sizeof(volume->downlink_volume));
        volume->downlink_volume = be64toh(volume->downlink_volume);
        size += sizeof(volume->downlink_volume);
    }

    if (size != octet->len)
        ogs_error("Mismatch IE Length[%d] != Decoded[%d]", octet->len, size);

    return size;
}

int16_t ogs_pfcp_build_dropped_dl_traffic_threshold(
        ogs_tlv_octet_t *octet,
        ogs_pfcp_dropped_dl_traffic_threshold_t *threshold,
        void *data, int data_len)
{
    ogs_pfcp_dropped_dl_traffic_threshold_t target;
    int16_t size = 0;

    ogs_assert(threshold);
    ogs_assert(octet);
    ogs_assert(data);
    ogs_assert(data_len >= sizeof(ogs_pfcp_dropped_dl_traffic_threshold_t));

    ogs_assert(threshold->flags);

    octet->data = data;
    memcpy(&target, threshold, sizeof(ogs_pfcp_dropped_dl_traffic_threshold_t));

    ((unsigned char *)octet->data)[size] = target.flags;
    size += sizeof(target.flags);

    if (target.dlpa) {
        target.downlink_packets = htobe64(target.downlink_packets);
        memcpy((unsigned char *)octet->data + size,
                &target.downlink_packets, sizeof(target.downlink_packets));
        size += sizeof(target.downlink_packets);
    }

    if (target.dlby) {
        target.number_of_bytes_of_downlink_data =
            htobe64(target.number_of_bytes_of_downlink_data);
        memcpy((unsigned char *)octet->data + size,
                &target.number_of_bytes_of_downlink_data,
                sizeof(target.number_of_bytes_of_downlink_data));
        size += sizeof(target.number_of_bytes_of_downlink_data);
    }

    octet->len = size;

    return octet->len;
}
int16_t ogs_pfcp_parse_dropped_dl_traffic_threshold(
        ogs_pfcp_dropped_dl_traffic_threshold_t *threshold,
        ogs_tlv_octet_t *octet)
{
    int16_t size = 0;

    ogs_assert(threshold);
    ogs_assert(octet);

    memset(threshold, 0, sizeof(ogs_pfcp_dropped_dl_traffic_threshold_t));

    threshold->flags = ((unsigned char *)octet->data)[size];
    size += sizeof(threshold->flags);

    if (threshold->dlpa) {
        memcpy(&threshold->downlink_packets,
                (unsigned char *)octet->data + size,
                sizeof(threshold->downlink_packets));
        threshold->downlink_packets = be64toh(threshold->downlink_packets);
        size += sizeof(threshold->downlink_packets);
    }
    if (threshold->dlby) {
        memcpy(&threshold->number_of_bytes_of_downlink_data,
                (unsigned char *)octet->data + size,
                sizeof(threshold->number_of_bytes_of_downlink_data));
        threshold->number_of_bytes_of_downlink_data =
            be64toh(threshold->number_of_bytes_of_downlink_data);
        size += sizeof(threshold->number_of_bytes_of_downlink_data);
    }

    ogs_assert(size == octet->len);

    return size;
}

int16_t ogs_pfcp_build_volume_measurement(ogs_tlv_octet_t *octet,
        ogs_pfcp_volume_measurement_t *volume, void *data, int data_len)
{
    ogs_pfcp_volume_measurement_t target;
    int16_t size = 0;

    ogs_assert(volume);
    ogs_assert(octet);
    ogs_assert(data);
    ogs_assert(data_len >= sizeof(ogs_pfcp_volume_measurement_t));

    ogs_assert(volume->flags);

    octet->data = data;
    memcpy(&target, volume, sizeof(ogs_pfcp_volume_measurement_t));

    ((unsigned char *)octet->data)[size] = target.flags;
    size += sizeof(target.flags);

    if (target.tovol) {
        target.total_volume = htobe64(target.total_volume);
        memcpy((unsigned char *)octet->data + size,
                &target.total_volume, sizeof(target.total_volume));
        size += sizeof(target.total_volume);
    }
    if (target.ulvol) {
        target.uplink_volume = htobe64(target.uplink_volume);
        memcpy((unsigned char *)octet->data + size,
                &target.uplink_volume, sizeof(target.uplink_volume));
        size += sizeof(target.uplink_volume);
    }
    if (target.dlvol) {
        target.downlink_volume = htobe64(target.downlink_volume);
        memcpy((unsigned char *)octet->data + size,
                &target.downlink_volume, sizeof(target.downlink_volume));
        size += sizeof(target.downlink_volume);
    }
    if (target.tonop) {
        target.total_n_packets = htobe64(target.total_n_packets);
        memcpy((unsigned char *)octet->data + size,
                &target.total_n_packets, sizeof(target.total_n_packets));
        size += sizeof(target.total_n_packets);
    }
    if (target.ulnop) {
        target.uplink_n_packets = htobe64(target.uplink_n_packets);
        memcpy((unsigned char *)octet->data + size,
                &target.uplink_n_packets, sizeof(target.uplink_n_packets));
        size += sizeof(target.uplink_n_packets);
    }
    if (target.dlnop) {
        target.downlink_n_packets = htobe64(target.downlink_n_packets);
        memcpy((unsigned char *)octet->data + size,
                &target.downlink_n_packets, sizeof(target.downlink_n_packets));
        size += sizeof(target.downlink_n_packets);
    }

    octet->len = size;

    return octet->len;
}

int16_t ogs_pfcp_parse_volume_measurement(
        ogs_pfcp_volume_measurement_t *volume, ogs_tlv_octet_t *octet)
{
    int16_t size = 0;

    ogs_assert(volume);
    ogs_assert(octet);

    memset(volume, 0, sizeof(ogs_pfcp_volume_measurement_t));

    volume->flags = ((unsigned char *)octet->data)[size];
    size += sizeof(volume->flags);

    if (volume->tovol) {
        memcpy(&volume->total_volume, (unsigned char *)octet->data + size,
                sizeof(volume->total_volume));
        volume->total_volume = be64toh(volume->total_volume);
        size += sizeof(volume->total_volume);
    }
    if (volume->ulvol) {
        memcpy(&volume->uplink_volume, (unsigned char *)octet->data + size,
                sizeof(volume->uplink_volume));
        volume->uplink_volume = be64toh(volume->uplink_volume);
        size += sizeof(volume->uplink_volume);
    }
    if (volume->dlvol) {
        memcpy(&volume->downlink_volume, (unsigned char *)octet->data + size,
                sizeof(volume->downlink_volume));
        volume->downlink_volume = be64toh(volume->downlink_volume);
        size += sizeof(volume->downlink_volume);
    }
    if (volume->tonop) {
        memcpy(&volume->total_n_packets, (unsigned char *)octet->data + size,
                sizeof(volume->total_n_packets));
        volume->total_n_packets = be64toh(volume->total_n_packets);
        size += sizeof(volume->total_n_packets);
    }
    if (volume->ulnop) {
        memcpy(&volume->uplink_n_packets, (unsigned char *)octet->data + size,
                sizeof(volume->uplink_n_packets));
        volume->uplink_n_packets = be64toh(volume->uplink_n_packets);
        size += sizeof(volume->uplink_n_packets);
    }
    if (volume->dlnop) {
        memcpy(&volume->downlink_n_packets, (unsigned char *)octet->data + size,
                sizeof(volume->downlink_n_packets));
        volume->downlink_n_packets = be64toh(volume->downlink_n_packets);
        size += sizeof(volume->downlink_n_packets);
    }

    ogs_assert(size == octet->len);

    return size;
}

int16_t ogs_pfcp_build_user_id(
        ogs_tlv_octet_t *octet, ogs_pfcp_user_id_t *user_id,
        void *data, int data_len)
{
    ogs_pfcp_user_id_t target;
    int16_t size = 0;

    ogs_assert(user_id);
    ogs_assert(octet);
    ogs_assert(data);
    ogs_assert(data_len);

    octet->data = data;
    memcpy(&target, user_id, sizeof(ogs_pfcp_user_id_t));

    ogs_assert(size + sizeof(target.flags) <= data_len);
    memcpy((unsigned char *)octet->data + size,
            &target.flags, sizeof(target.flags));
    size += sizeof(target.flags);

    if (target.imsif) {
        ogs_assert(size + sizeof(target.imsi_len) <= data_len);
        memcpy((unsigned char *)octet->data + size,
                &target.imsi_len, sizeof(target.imsi_len));
        size += sizeof(target.imsi_len);

        ogs_assert(size + user_id->imsi_len <= data_len);
        memcpy((char *)octet->data + size, user_id->imsi, user_id->imsi_len);
        size += user_id->imsi_len;
    }
    if (target.imeif) {
        ogs_assert(size + sizeof(target.imeisv_len) <= data_len);
        memcpy((unsigned char *)octet->data + size,
                &target.imeisv_len, sizeof(target.imeisv_len));
        size += sizeof(target.imeisv_len);

        ogs_assert(size + user_id->imeisv_len <= data_len);
        memcpy((char *)octet->data + size,
                user_id->imeisv, user_id->imeisv_len);
        size += user_id->imeisv_len;
    }
    if (target.msisdnf) {
        ogs_assert(size + sizeof(target.msisdn_len) <= data_len);
        memcpy((unsigned char *)octet->data + size,
                &target.msisdn_len, sizeof(target.msisdn_len));
        size += sizeof(target.msisdn_len);

        ogs_assert(size + user_id->msisdn_len <= data_len);
        memcpy((char *)octet->data + size,
                user_id->msisdn, user_id->msisdn_len);
        size += user_id->msisdn_len;
    }

    octet->len = size;

    return octet->len;
}
===== types.h =====

#if !defined(OGS_PFCP_INSIDE) && !defined(OGS_PFCP_COMPILATION)
#error "This header cannot be included directly."
#endif

#ifndef OGS_PFCP_TYPES_H
#define OGS_PFCP_TYPES_H

#ifdef __cplusplus
extern "C" {
#endif

#define OGS_PFCP_VERSION                                    1

typedef uint16_t ogs_pfcp_pdr_id_t;
typedef uint32_t ogs_pfcp_far_id_t;
typedef uint32_t ogs_pfcp_urr_id_t;
typedef uint32_t ogs_pfcp_qer_id_t;
typedef uint8_t  ogs_pfcp_bar_id_t;

#define OGS_PFCP_CAUSE_REQUEST_ACCEPTED                     1
#define OGS_PFCP_CAUSE_MORE_USAGE_REPORT_TO_SEND            2
#define OGS_PFCP_CAUSE_REQUEST_REJECTED                     64
#define OGS_PFCP_CAUSE_SESSION_CONTEXT_NOT_FOUND            65
#define OGS_PFCP_CAUSE_MANDATORY_IE_MISSING                 66
#define OGS_PFCP_CAUSE_CONDITIONAL_IE_MISSING               67
#define OGS_PFCP_CAUSE_INVALID_LENGTH                       68
#define OGS_PFCP_CAUSE_MANDATORY_IE_INCORRECT               69
#define OGS_PFCP_CAUSE_INVALID_FORWARDING_POLICY            70
#define OGS_PFCP_CAUSE_INVALID_F_TEID_ALLOCATION_OPTION     71
#define OGS_PFCP_CAUSE_NO_ESTABLISHED_PFCP_ASSOCIATION      72
#define OGS_PFCP_CAUSE_RULE_CREATION_MODIFICATION_FAILURE   73
#define OGS_PFCP_CAUSE_PFCP_ENTITY_IN_CONGESTION            74
#define OGS_PFCP_CAUSE_NO_RESOURCES_AVAILABLE               75
#define OGS_PFCP_CAUSE_SERVICE_NOT_SUPPORTED                76
#define OGS_PFCP_CAUSE_SYSTEM_FAILURE                       77
#define OGS_PFCP_CAUSE_REDIRECTION_REQUESTED                78
#define OGS_PFCP_CAUSE_ALL_DYNAMIC_ADDRESS_ARE_OCCUPIED     79

const char *ogs_pfcp_cause_get_name(uint8_t cause);

/*
 * 8.2.11 Precedence
 *
 * The Precedence value shall be encoded as an Unsigned32 binary integer value. The lower precedence values
 * indicate higher precedence of the PDR, and the higher precedence values
 * indicate lower precedence of the PDR when matching a packet.
 */
typedef uint32_t ogs_pfcp_precedence_t;

/*
 * 8.2.2 Source Interface
 * NOTE 1: The "Access" and "Core" values denote an uplink and downlink
 * traffic direction respectively.
 * NOTE 2: For indirect data forwarding, the Source Interface in the PDR and
 * the Destination Interface in the FAR shall both be set to "Access",
 * in the forwarding SGW(s). The Interface value does not infer any
 * traffic direction, in PDRs and FARs set up for indirect data
 * forwarding, i.e. with both the Source and Destination Interfaces set
 * to Access.
 *
 * 8.2.24 Destination Interface
 * NOTE 1: The "Access" and "Core" values denote a downlink and uplink
 * traffic direction respectively.
 * NOTE 2: LI Function may denote an SX3LIF or an LMISF. See clause 5.7.
 * NOTE 3: For indirect data forwarding, the Source Interface in the PDR and
 * the Destination Interface in the FAR shall both be set to "Access",
 * in the forwarding SGW(s). The Interface value does not infer any
 * traffic direction, in PDRs and FARs set up for indirect data
 * forwarding, i.e. with both the Source and Destination Interfaces set
 * to Access.
 * NOTE 4: For a HTTP redirection, the Source Interface in the PDR to match
 * the uplink packets to be redirected and the Destination Interface in
 * the FAR to enable the HTTP redirection shall both be set to "Access".
 */
#define OGS_PFCP_INTERFACE_ACCESS                           0
#define OGS_PFCP_INTERFACE_CORE                             1
#define OGS_PFCP_INTERFACE_SGI_N6_LAN                       2
#define OGS_PFCP_INTERFACE_CP_FUNCTION                      3
#define OGS_PFCP_INTERFACE_LI_FUNCTION                      4
#define OGS_PFCP_INTERFACE_UNKNOWN                          0xff
typedef uint8_t  ogs_pfcp_interface_t;

/* 8.2.25 UP Function Features */

typedef struct ogs_pfcp_up_function_features_s {
    union {
        struct {
/*
 * 5/8 TREU Sxb, Sxc, N4
 *   Traffic Redirection Enforcement in the UP function is supported
 *   by the UP function.
 * 5/7 HEEU Sxb, Sxc, N4
 *   Header Enrichment of Uplink traffic is supported by the UP function.
 * 5/6 PFDM Sxb, Sxc, N4
 *   The PFD Management procedure is supported by the UP function.
 * 5/5 FTUP Sxa, Sxb, N4
 *   F-TEID allocation / release in the UP function is supported
 *   by the UP function.
 * 5/4 TRST Sxb, Sxc, N4
 *   Traffic Steering is supported by the UP function.
 * 5/3 DLBD Sxa, N4
 *   The buffering parameter 'DL Buffering Duration' is supported
 *   by the UP function.
 * 5/2 DDND Sxa, N4
 *   The buffering parameter 'Downlink Data Notification Delay' is supported
 *   by the UP function.
 * 5/1 BUCP Sxa, N4
 *   Downlink Data Buffering in CP function is supported by the UP function.
 */
ED8(uint8_t treu:1;,
    uint8_t heeu:1;,
    uint8_t pfdm:1;,
    uint8_t ftup:1;,
    uint8_t trst:1;,
    uint8_t dldb:1;,
    uint8_t ddnd:1;,
    uint8_t bucp:1;)
        };
        uint8_t octet5;
    };
    union {
        struct {
/*
 * 6/8 EPFAR Sxa, Sxb, Sxc, N4
 *   The UP function supports the Enhanced PFCP Association Release feature
 *   (see clause 5.18).
 * 6/7 PFDE Sxb, N4
 *   The UP function supports a PFD Contents including a property
 *   with multiple values.
 * 6/6 FRRT Sxb, N4
 *   The UP function supports Framed Routing
 *   (see IETF RFC 2865 [37] and IETF RFC 3162 [38]).
 * 6/5 TRACE Sxa, Sxb, Sxc, N4
 *   The UP function supports Trace (see clause 5.15).
 * 6/4 QUOAC Sxb, Sxc, N4
 *   The UP function supports being provisioned with the Quota Action
 *   to apply when reaching quotas.
 * 6/3 UDBC Sxb, Sxc, N4
 *   Support of UL/DL Buffering Control
 * 6/2 PDIU Sxa, Sxb, Sxc, N4
 *   Support of PDI optimised signalling in UP function (see clause 5.2.1A.2).
 * 6/1 EMPU Sxa, Sxb, N4
 *   Sending of End Marker packets supported by the UP function.
 */
ED8(uint8_t epfar:1;,
    uint8_t pfde:1;,
    uint8_t frrt:1;,
    uint8_t trace:1;,
    uint8_t quoac:1;,
    uint8_t udbc:1;,
    uint8_t pdiu:1;,
    uint8_t empu:1;)
        };
        uint8_t octet6;
    };
    union {
        struct {
/*
 * 7/8 GCOM N4
 *   UPF support of 5G VN Group Communication.(See clause 5.23)
 * 7/7 BUNDL Sxa, Sxb, Sxc, N4
 *   PFCP messages bunding (see clause 6.5) is supported by the UP function.
 * 7/6 MTE N4
 *   UPF supports multiple instances of Traffic Endpoint IDs in a PDI.
 * 7/5 MNOP Sxa, Sxb, Sxc, N4
 *   The UP function supports measurement of number of packets
 *   which is instructed with the flag 'Measurement of Number of Packets'
 *   in a URR.See also clause 5.2.2.2.1.
 * 7/4 SSET N4
 *   UPF support of PFCP sessions successively controlled
 *   by different SMFs of a same SMF Set (see clause 5.22).
 * 7/3 UEIP Sxb, N4
 *   The UP function supports allocating UE IP addresses or prefixes
 *   (see clause 5.21).
 * 7/2 ADPDP Sxa, Sxb, Sxc, N4
 *   The UP function supports the Activation and Deactivation
 *   of Pre-defined PDRs (see clause 5.19).
 * 7/1 DPDRA Sxb, Sxc, N4
 *   The UP function supports Deferred PDR Activation or Deactivation.
 */
ED8(uint8_t gcom:1;,
    uint8_t bundl:1;,
    uint8_t mte:1;,
    uint8_t mnop:1;,
    uint8_t sset:1;,
    uint8_t ueip:1;,
    uint8_t adpdp:1;,
    uint8_t dpdra:1;)
        };
        uint8_t octet7;
    };
    union {
        struct {
/*
 * 8/8 MPTCP N4
 *   UPF support of MPTCP Proxy functionality (see clause 5.20)
 * 8/7 TSCU N4
 *   Time Sensitive Communication is supported by the UPF (see clause 5.26).
 * 8/6 IP6PL N4
 *   UPF supports:
 *     - UE IPv6 address(es) allocation with IPv6 prefix length other than
 *       default /64 (including allocating /128 individual IPv6 addresses),
 *       as specified in clause 4.6.2.2 of of 3GPP TS 23.316 [57]; and
 *     - multiple UE IPv6 addresses allocation using multiple instances
 *       of the UE IP Address IE in a same PDI or Traffic Endpoint,
 *       or using multiple PDIs or Traffic Endpoints
 *       with a different UE IP Address as specified in clause 5.21.1.
 * 8/5 IPTV N4
 *   UPF support of IPTV service (see clause 5.25)
 * 8/4 NORP Sxa, Sxb, Sxc, N4
 *   UP function support of Number of Reports as specified in clause 5.2.2.2.
 * 8/3 VTIME Sxb,N4
 *   UP function support of quota validity time feature.
 * 8/2 RTTL N4
 *   UPF supports redundant transmission at transport layer.
 * 8/1 MPAS N4
 *   UPF support for multiple PFCP associations to the SMFs in an SMF set
 *   (see clause 5.22.3).
 */
ED8(uint8_t mptcp:1;,
    uint8_t tscu:1;,
    uint8_t ip6pl:1;,
    uint8_t iptv:1;,
    uint8_t norp:1;,
    uint8_t vtime:1;,
    uint8_t rttl:1;,
    uint8_t mpas:1;)
        };
        uint8_t octet8;
    };
    union {
        struct {
/*
 * 9/8 RDS Sxb, N4
 *   UP function support of Reliable Data Service (see clause 5.29).
 * 9/7 DDDS N4
 *   UPF support of reporting the first buffered / discarded downlink data
 *   for downlink data delivery status notification.
 * 9/6 ETHAR N4
 *   UPF support of Ethernet PDU Session Anchor Relocation (see clause 5.13.6).
 * 9/5 CIOT Sxb, N4
 *   UP function support of CIoT feature,
 *   e.g.small data packet rate enforcement.(see 5.4.15)
 * 9/4 MT-EDT Sxa
 *   SGW-U support of reporting the size of DL Data Packets.
 *   (see clause 5.2.4.1).
 * 9/3 GPQM N4
 *   UPF support of per GTP-U Path QoS monitoring (see clause 5.24.5).
 * 9/2 QFQM N4
 *   UPF support of per QoS flow per UE QoS monitoring (see clause 5.24.4).
 * 9/1 ATSSS-LL N4
 *   UPF support of ATSSS-LLL steering functionality (see clause 5.20)
 */
ED8(uint8_t rds:1;,
    uint8_t ddds:1;,
    uint8_t ethar:1;,
    uint8_t ciot:1;,
    uint8_t mt_edt:1;,
    uint8_t gpqm:1;,
    uint8_t qfqm:1;,
    uint8_t atsss_ll:1;)
        };
        uint8_t octet9;
    };
    union {
        struct {
/*
 * 10/8 DNSTS N4
 *   UP function support DNS Traffic Steering based on
 *   FQDN in the DNS Query message (see
 *   clause 5.33.4)
 * 10/7 IPREP N4
 *   UP function supports IP Address and Port number
 *   replacement (see clause 5.33.3).
 * 10/6 RESPS Sxb, N4
 *   UP function supports Restoration of PFCP Sessions
 *   associated with one or more PGW-C/SMF FQ-
 *   CSID(s), Group Id(s) or CP IP address(es) (see
 *   clause 5.22.4)
 * 10/5 UPBER N4
 *   UP function supports the uplink packets buffering
 *   during EAS relocation.
 * 10/4 L2TP Sxb, N4
 *   UP function supports the L2TP feature as described
 *   in clause 5.31.
 * 10/3 NSPOC Sxa, Sxb, N4
 *   UP function supports notifying start of Pause of
 *   Charging via user plane.
 * 10/2 QUASF Sxb, Sxc, N4
 *   The UP function supports being provisioned in a
 *   URR with an Exempted Application ID for Quota
 *   Action or an Exempted SDF Filter for Quota Action
 *   which is to be used when the quota is exhausted.
 *   See also clauses 5.2.2.2.1 and 5.2.2.3.1.
 * 10/1 RTTWP N4
 *   UPF support of RTT measurements towards the UE Without PMF.
 */
ED8(uint8_t dnsts:1;,
    uint8_t iprep:1;,
    uint8_t resps:1;,
    uint8_t upber:1;,
    uint8_t l2tp:1;,
    uint8_t nspoc:1;,
    uint8_t quasf:1;,
    uint8_t rttwp:1;)
        };
        uint8_t octet10;
    };
    union {
        struct {

/*
 * 11/6 UPIDP N4
 *   UP function supports User Plane Inactivity Detection
 *   and reporting per PDR feature as specified in
 *   clause 5.11.3.
 * 11/5 RATP Sxb, N4
 *   UP function supports Redirection Address Types set
 *   to "Port", "IPv4 address and Port", "IPv6 address
 *   and Port", or "IPv4 and IPv6 addresses and Port".
 * 11/4 EPPPI N4
 *   UP function supports Enhanced Provisioning of
 *   Paging Policy Indicator feature as specified in
 *   clause 5.36.2.
 * 11/3 PSUPRM N4, N4mb
 *   UP function supports Per Slice UP Resource
 *   Management (see clause 5.35).3GPP TS 29.244 version 17.7.1 Release 17
 * 11/2 MBSN4 N4
 *   UPF supports sending MBS multicast session data
 *   to associated PDU sessions using 5GC individual
 *   delivery.
 * 11/1 DRQOS N4
 *   UP function supports Direct Reporting of QoS
 *   monitoring events to Local NEF or AF (see
 *   clause 5.33.5).
 */
ED7(uint8_t spare:2;,
    uint8_t upidp:1;,
    uint8_t ratp:1;,
    uint8_t epppi:1;,
    uint8_t psuprm:1;,
    uint8_t mbsn4:1;,
    uint8_t drqos:1;)
        };
        uint8_t octet11;
    };
} __attribute__ ((packed)) ogs_pfcp_up_function_features_t;

/*
 * 8.2.26 Apply Action
 *
 * The octet 5 shall be encoded as follows:
 *
 * Bit 1 – DROP (Drop): when set to 1, this indicates a request
 * to drop the packets.
 * Bit 2 – FORW (Forward): when set to 1, this indicates a request
 * to forward the packets.
 * Bit 3 – BUFF (Buffer): when set to 1, this indicates a request
 * to buffer the packets.
 * Bit 4 – NOCP (Notify the CP function): when set to 1,
 * this indicates a request to notify the CP function about the
 * arrival of a first downlink packet being buffered.
 * Bit 5 – DUPL (Duplicate): when set to 1, this indicates a request
 * to duplicate the packets.
 * Bit 6 – IPMA (IP Multicast Accept): when set to "1", this indicates
 * a request to accept UE requests to join an IP multicast group.
 * Bit 7 – IPMD (IP Multicast Deny): when set to "1", this indicates
 * a request to deny UE requests to join an IP multicast group.
 * Bit 8 – DFRT (Duplicate for Redundant Transmission): when set to "1",
 * this indicates a request to duplicate the packets
 * for redundant transmission (see clause 5.24.2).
 *
 * The octet 6 shall be encoded as follows:
 *
 * Bit 1 – EDRT (Eliminate Duplicate Packets for Redundant Transmission):
 * when set to "1", this indicates a request to eliminate duplicate packets
 * used for redundant transmission (see clause 5.24.2).
 * Bit 2 – BDPN (Buffered Downlink Packet Notification): when set to "1",
 * this indicates a request to notify the CP function about the first buffered
 * DL packet for downlink data delivery status notification.
 * Bit 3 – DDPN (Discarded Downlink Packet Notification): when set to "1",
 * this indicates a request to notify the CP function about the first discarded
 * DL packet for downlink data delivery status notification if the DL Buffering
 * Duration or DL Buffering Suggested Packet Count is exceeded or
 * it is discarded directly. See clause 5.2.3.1.
 *
 * Bit 4 - FSSM (Forward packets to lower layer SSM): when set to "1",
 * this indicates a request to the MB-UPF to forward MBS session data
 * towards a low layer SSM address allocated by the MB-UPF
 * using multicast transport.
 * Bit 5 – MBSU (Forward and replicate MBS data using Unicast transport):
 * when set to "1", this indicates a request to forward and replicate
 * MBS session data towards multiple remote GTP-U peers using unicast transport.
 * Bit 6 to 8 – Spare, for future use and seto to "0".

 *
 * One and only one of the DROP, FORW, BUFF, IPMA and IPMD flags shall be
 * set to "1".
 *
 * The NOCP flag and BDPN flag may only be set if the BUFF flag is set.
 * The DUPL flag may be set with any of the DROP, FORW, BUFF and NOCP flags.
 * The DFRN flag may only be set if the FORW flag is set.
 * The EDRT flag may be set if the FORW flag is set.
 * The DDPN flag may be set with any of the DROP and BUFF flags.
 *
 * Both the MBSU flag and the FSSM flag may be set
 * (to require the MB-UPF to forward MBS session data
 * using both multicast and unicast transports).
 */
#define OGS_PFCP_APPLY_ACTION_DROP                          (1<<8)
#define OGS_PFCP_APPLY_ACTION_FORW                          (1<<9)
#define OGS_PFCP_APPLY_ACTION_BUFF                          (1<<10)
#define OGS_PFCP_APPLY_ACTION_NOCP                          (1<<11)
#define OGS_PFCP_APPLY_ACTION_DUPL                          (1<<12)
#define OGS_PFCP_APPLY_ACTION_IPMA                          (1<<13)
#define OGS_PFCP_APPLY_ACTION_IPMD                          (1<<14)
#define OGS_PFCP_APPLY_ACTION_DFRT                          (1<<15)
#define OGS_PFCP_APPLY_ACTION_EDRT                          (1<<0)
#define OGS_PFCP_APPLY_ACTION_BDPN                          (1<<1)
#define OGS_PFCP_APPLY_ACTION_DDPN                          (1<<2)
#define OGS_PFCP_APPLY_ACTION_FSSM                          (1<<3)
#define OGS_PFCP_APPLY_ACTION_MBSU                          (1<<4)
typedef uint16_t  ogs_pfcp_apply_action_t;

/* 8.2.58 CP Function Features */
typedef struct ogs_pfcp_cp_function_features_s {
    union {
        struct {
/*
 * 5/8 UIAUR Sxb, N4
 *   CP function supports the UE IP Address Usage Reporting feature,
 *   i.e. receiving and handling of UE IP Address Usage Information IE
 *   (see clause 5.21.3.2).
 * 5/7 ARDR Sxb, N4
 *   CP function supports Additional Usage Reports
 *   in the PFCP Session Deletion Response (see clause 5.2.2.3.1).
 * 5/6 MPAS N4
 *   SMF support for multiple PFCP associations from an SMF set to a single UPF
 *   (see clause 5.22.3).
 * 5/5 BUNDL Sxa, Sxb, Sxc, N4
 *   PFCP messages bunding (see clause 6.5) is supported by the CP function.
 * 5/4 SSET N4
 *   SMF support of PFCP sessions successively controlled by different SMFs
 *   of a same SMF Set (see clause 5.22).
 * 5/3 EPFAR Sxa, Sxb, Sxc, N4
 *   The CP function supports the Enhanced PFCP Association Release feature
 *   (see clause 5.18).
 * 5/2 OVRL Sxa, Sxb, Sxc, N4
 *   Overload Control is supported by the CP function.
 * 5/1 LOAD Sxa, Sxb, Sxc, N4
 *   Load Control is supported by the CP function.
 */
ED8(uint8_t uiaur:1;,
    uint8_t apdr:1;,
    uint8_t mpas:1;,
    uint8_t bundl:1;,
    uint8_t sset:1;,
    uint8_t epfar:1;,
    uint8_t ovrl:1;,
    uint8_t load:1;)
        };
        uint8_t octet5;
    };
    union {
        struct {

/*
 * 6/2 RPGUR Sxa, Sxb, N4, N4mb
 *   CP function supports the Peer GTP-U Entity Restart
 *   Reporting as specified in clause 20.3.4a of
 *   3GPP TS 23.007 [24] and in clause 5.5 of 3GPP TS 23.527 [40].
 * 6/1 PSUCC Sxb, Sxc, N4, N4mb
 *   CP function supports PFCP session establishment
 *   or modification with Partial Success, i.e. with UP
 *   function reporting rules that cannot be activated.
 *   See clause 5.2.9.
 */
ED3(uint8_t spare:6;,
    uint8_t rpgur:1;,
    uint8_t psucc:1;)
        };
        uint8_t octet6;
    };
} __attribute__ ((packed)) ogs_pfcp_cp_function_features_t;


/*
 * 8.2.64 Outer Header Remaval
 *
 * NOTE 1: The SGW-U/I-UPF shall store GTP-U extension header(s) required
 * to be forwarded for this packet (as required by the comprehension rules
 * of Figure 5.2.1-2 of 3GPP TS 29.281 [3]) that are not requested
 * to be deleted by the GTP-U Extension Header Deletion field.
 * NOTE 2: The SGW-U/I-UPF shall store the GTP-U message type
 * for a GTP-U signalling message which is required to be forwarded,
 * e.g. for an End Marker message.
 * NOTE 3: This value may apply to DL packets received by a PGW-U
 * for non-IP PDN connections with SGi tunnelling based
 * on UDP/IP encapsulation (see clause 4.3.17.8.3.3.2 of 3GPP TS 23.401 [14]).
 * NOTE 4: The CP function shall use this value to instruct UP function
 * to remove the GTP-U/UDP/IP header regardless it is IPv4 or IPv6.
 * NOTE 5: This value may apply to DL packets received by a UPF over N6 for
 * Ethernet PDU sessions over (see clause 5.8.2.11.3 of 3GPP TS 23.501 [28]).
 * NOTE 6: This value may apply e.g. to DL packets received by a UPF
 * (PDU Session Anchor) over N6, when explicit N6 traffic routing information
 * is provided to the SMF (see clause 5.6.7 of 3GPP TS 23.501 [28]).
 *
 * The GTP-U Extension Header Deletion field (octet 6) shall be present
 * if it is required to delete GTP-U extension header(s) from incoming GTP-PDUs.
 * Octet 6 shall be absent if all GTP-U extension headers required
 * to be forwarded shall be stored as indicated in NOTE 1 of Table 8.2.64-1.
 *
 * The GTP-U Extension Header Deletion field, when present, shall be encoded
 * as specified in Table 8.2.64-2. It takes the form of a bitmask where each bit
 * provides instructions on the information to be deleted from the incoming
 * GTP-PDU packet. Spare bits shall be ignored by the receiver.
 */
typedef struct ogs_pfcp_outer_header_removal_s {
#define OGS_PFCP_OUTER_HEADER_REMOVAL_GTPU_UDP_IPV4         0
#define OGS_PFCP_OUTER_HEADER_REMOVAL_GTPU_UDP_IPV6         1
#define OGS_PFCP_OUTER_HEADER_REMOVAL_UDP_IPV4              2
#define OGS_PFCP_OUTER_HEADER_REMOVAL_UDP_IPV6              3
#define OGS_PFCP_OUTER_HEADER_REMOVAL_IPV4                  4
#define OGS_PFCP_OUTER_HEADER_REMOVAL_IPV6                  5
#define OGS_PFCP_OUTER_HEADER_REMOVAL_GTPU_UDP_IP           6
#define OGS_PFCP_OUTER_HEADER_REMOVAL_VLAN_STAG             7
#define OGS_PFCP_OUTER_HEADER_REMOVAL_SLAN_CTAG             8
    uint8_t description;

#define OGS_PFCP_PDU_SESSION_CONTAINER_TO_BE_DELETED        1
    uint8_t gtpu_extheader_deletion;
} ogs_pfcp_outer_header_removal_t;

/******************************************************************************
 * PFCP Node ID structure
 ******************************************************************************/
#define OGS_PFCP_NODE_ID_IPV4   0
#define OGS_PFCP_NODE_ID_IPV6   1
#define OGS_PFCP_NODE_ID_FQDN   2

/******************************************************************************
 * Add this line to define the UNKNOWN type. We use '3' since 0,1,2 are taken.
 ******************************************************************************/
#define OGS_PFCP_NODE_ID_UNKNOWN 0xf
typedef struct ogs_pfcp_node_id_s {
ED2(uint8_t     spare:4;,
    uint8_t     type:4;)
    union {
        uint32_t addr;
        uint8_t addr6[OGS_IPV6_LEN];
        char fqdn[OGS_MAX_FQDN_LEN];
    };
} __attribute__ ((packed)) ogs_pfcp_node_id_t;

typedef struct ogs_pfcp_f_seid_s {
ED3(uint8_t     spare:6;,
    uint8_t     ipv4:1;,
    uint8_t     ipv6:1;)
    uint64_t    seid;
    union {
        uint32_t addr;
        uint8_t addr6[OGS_IPV6_LEN];
        struct {
            uint32_t addr;
            uint8_t addr6[OGS_IPV6_LEN];
        } both;
    };
} __attribute__ ((packed)) ogs_pfcp_f_seid_t;

/*
 * 8.2.3 F-TEID
 *
 * The following flags are coded within Octet 5:
 *
 * - Bit 1 – V4: If this bit is set to "1" and the CH bit is not set,
 *   then the IPv4 address field shall be present,
 *   otherwise the IPv4 address field shall not be present.
 * - Bit 2 – V6: If this bit is set to "1" and the CH bit is not set,
 *   then the IPv6 address field shall be present,
 *   otherwise the IPv6 address field shall not be present.
 * - Bit 3 – CH (CHOOSE): If this bit is set to "1", then the TEID,
 *   IPv4 address and IPv6 address fields shall not be present and
 *   the UP function shall assign an F-TEID with an IP4 or an IPv6 address
 *   if the V4 or V6 bit is set respectively. This bit shall only be set
 *   by the CP function.
 * - Bit 4 – CHID (CHOOSE ID): If this bit is set to "1",
 *   then the UP function shall assign the same F-TEID to the PDRs requested
 *   to be created in a PFCP Session Establishment Request or
 *   PFCP Session Modification Request with the same CHOOSE ID value.
 *   This bit may only be set to "1" if the CH bit it set to "1".
 *   This bit shall only be set by the CP function.
 * - Bit 5 to 8: Spare, for future use and set to 0.
 *
 * At least one of the V4 and V6 flags shall be set to "1", and
 * both may be set to "1" for both scenarios:
 *
 * - when the CP function is allocating F-TEID, i.e. both IPv4 address field
 *   and IPv6 address field may be present;
 * - or when the UP function is requested to allocate the F-TEID,
 *   i.e. when CHOOSE bit is set to "1", and the IPv4 address and
 *   IPv6 address fields are not present.
 *
 * Octet 6 to 9 (TEID) shall be present and shall contain a GTP-U TEID,
 * if the CH bit in octet 5 is not set. When the TEID is present,
 * if both IPv4 and IPv6 addresses are present in the F-TEID IE,
 * then the TEID value shall be shared by both addresses.
 *
 * Octets "m to (m+3)" and/or "p to (p+15)"(IPv4 address / IPv6 address fields),
 * if present, it shall contain the respective IP address values.
 *
 * Octet q shall be present and shall contain a binary integer value
 * if the CHID bit in octet 5 is set to "1".
 */
typedef struct ogs_pfcp_f_teid_s {
ED5(uint8_t     spare1:4;,
    uint8_t     chid:1;,
    uint8_t     ch:1;,
    uint8_t     ipv6:1;,
    uint8_t     ipv4:1;)
    union {
        struct {
        ED4(uint8_t choose_id;,
            uint8_t spare2;,
            uint8_t spare3;,
            uint8_t spare4;)
        };
        struct {
            uint32_t teid;
            union {
                uint32_t addr;
                uint8_t addr6[OGS_IPV6_LEN];
                struct {
                    uint32_t addr;
                    uint8_t addr6[OGS_IPV6_LEN];
                } both;
            };
        };
    };
} __attribute__ ((packed)) ogs_pfcp_f_teid_t;

/*
 * 8.2.62 UE IP Address
 *
 * - Bit 1 – V6: If this bit is set to "1", then the IPv6 address field
 *   shall be present in the UE IP Address, otherwise the IPv6 address field
 *   shall not be present.
 * - Bit 2 – V4: If this bit is set to "1", then the IPv4 address field
 *   shall be present in the UE IP Address, otherwise the IPv4 address field
 *   shall not be present.
 * - Bit 3 – S/D: This bit is only applicable to the UE IP Address IE
 *   in the PDI IE. It shall be set to "0" and ignored by the receiver
 *   in IEs other than PDI IE. In the PDI IE, if this bit is set to "0",
 *   this indicates a Source IP address; if this bit is set to "1",
 *   this indicates a Destination IP address.
 * - Bit 4 – IPv6D: This bit is only applicable to the UE IP address IE
 *   in the PDI IE and whhen V6 bit is set to "1". If this bit is set to "1",
 *   then the IPv6 Prefix Delegation Bits field shall be present,
 *   otherwise the UP function shall consider IPv6 prefix is default /64.
 * - Bit 5 to 8 Spare, for future use and set to 0.
 *
 * Octets "m to (m+3)" or "p to (p+15)" (IPv4 address / IPv6 address fields),
 * if present, shall contain the address value.
 *
 * Octet r, if present, shall contain the number of bits is allocated
 * for IPv6 prefix delegation, e.g. if /60 prefix is used, the value
 * is set to "4". When using UE IP address IE in a PDI to match the packets,
 * the UP function shall only use the IPv6 prefix part and
 * ignore the interface identifier part.
 */
typedef struct ogs_pfcp_ue_ip_addr_s {
ED8(uint8_t     spare:1;,
    uint8_t     ip6pl:1;,
    uint8_t     chv6:1;,
    uint8_t     chv4:1;,
    uint8_t     ipv6d:1;,
#define OGS_PFCP_UE_IP_SRC     0
#define OGS_PFCP_UE_IP_DST     1
    uint8_t     sd:1;,
    uint8_t     ipv4:1;,
    uint8_t     ipv6:1;)
    union {
        uint32_t addr;
        uint8_t addr6[OGS_IPV6_LEN];
        struct {
            uint32_t addr;
            uint8_t addr6[OGS_IPV6_LEN];
        } both;
    };
} __attribute__ ((packed)) ogs_pfcp_ue_ip_addr_t;

/*
 * 8.2.56 Outer Header Creation
 *
 * NOTE 1: The SGW-U/I-UPF shall also create GTP-U extension header(s)
 * if any has been stored for this packet, during a previous outer header
 * removal (see clause 8.2.64).
 * NOTE 2: This value may apply to UL packets sent by a PGW-U
 * for non-IP PDN connections with SGi tunnelling based on UDP/IP encapsulation
 * (see clause 4.3.17.8.3.3.2 of 3GPP TS 23.401 [14]).
 * NOTE 3: The SGW-U/I-UPF shall set the GTP-U message type
 * to the value stored during the previous outer header removal.
 * NOTE 4: This value may apply to UL packets sent by a UPF
 * for Ethernet PDU sessions over N6
 * (see clause 5.8.2.11.6 of 3GPP TS 23.501 [28]).
 * NOTE 5: This value may apply e.g. to UL packets sent by a UPF
 * (PDU Session Anchor) over N6, when explicit N6 traffic routing information is provided to the SMF (see clause 5.6.7 of 3GPP TS 23.501 [28]).
 *
 * At least one bit of the Outer Header Creation Description field
 * shall be set to 1. Bits 5/1 and 5/2 may both be set to 1 if an F-TEID
 * with both an IPv4 and IPv6 addresses has been assigned by the GTP-U peer.
 * In this case, the UP function shall send the outgoing packet
 * towards the IPv4 or IPv6 address.
 *
 * The TEID field shall be present if the Outer Header Creation Description
 * requests the creation of a GTP-U header. Otherwise it shall not be present.
 * When present, it shall contain the destination GTP-U TEID to set
 * in the GTP-U header of the outgoing packet.
 *
 * The IPv4 Address field shall be present if the Outer Header Creation
 * Description requests the creation of an IPv4 header. Otherwise it shall
 * not be present. When present, it shall contain the destination IPv4 address
 * to set in the IPv4 header of the outgoing packet.
 *
 * The IPv6 Address field shall be present if the Outer Header Creation
 * Description requests the creation of an IPv6 header. Otherwise it shall
 * not be present. When present, it shall contain the destination IPv6 address
 * to set in the IPv6 header of the outgoing packet.
 *
 * The Port Number field shall be present if the Outer Header Creation
 * Description requests the creation of a UDP/IP header
 * (i.e. it is set to the value 4). Otherwise it shall not be present.
 * When present, it shall contain the destination Port Number to set
 * in the UDP header of the outgoing packet.
 *
 * The C-TAG field shall be present if the Outer Header Creation Description
 * requests the setting of the C-Tag in Ethernet packet. Otherwise it shall
 * not be present. When present, it shall contain the destination Customer-VLAN
 * tag to set in the Customer-VLAN tag header of the outgoing packet.
 *
 * The S-TAG field shall be present if the Outer Header Creation Description
 * requests the setting of the S-Tag in Ethernet packet. Otherwise it shall
 * not be present. When present, it shall contain the destination Service-VLAN
 * tag to set in the Service-VLAN tag header of the outgoing packet.
 */
typedef struct ogs_pfcp_outer_header_creation_s {
ED8(uint8_t     stag:1;,
    uint8_t     ctag:1;,
    uint8_t     ip6:1;,
    uint8_t     ip4:1;,
    uint8_t     udp6:1;,
    uint8_t     udp4:1;,
    uint8_t     gtpu6:1;,
    uint8_t     gtpu4:1;)
ED4(uint8_t     spare:5;,
    uint8_t     ssm_c_teid:1;,
    uint8_t     n6:1;,
    uint8_t     n19:1;)
    uint32_t    teid;
    union {
        uint32_t addr;
        uint8_t addr6[OGS_IPV6_LEN];
        struct {
            uint32_t addr;
            uint8_t addr6[OGS_IPV6_LEN];
        } both;
    };
} __attribute__ ((packed)) ogs_pfcp_outer_header_creation_t;

/*
 * 8.2.82 User Plane IP Resource Information
 *
 * The following flags are coded within Octet 5:
 * - Bit 1 – V4: If this bit is set to "1", then the IPv4 address field
 *   shall be present, otherwise the IPv4 address field shall not be present.
 * - Bit 2 – V6: If this bit is set to "1", then the IPv6 address field
 *   shall be present, otherwise the IPv6 address field shall not be present.
 * - Bit 3-5 – TEID Range Indication (TEIDRI): the value of this field
 *   indicates the number of bits in the most significant octet of a TEID
 *   that are used to partition the TEID range,
 *   e.g. if this field is set to "4", then the first 4 bits in the TEID
 *   are used to partition the TEID range.
 * - Bit 6 – Associated Network Instance (ASSONI): if this bit is set to "1",
 *   then the Network Instance field shall be present, otherwise the Network
 *   Instance field shall not be present.
 * - Bit 7 – Associated Source Interface (ASSOSI): if this bit is set to "1",
 *   then the Source Interface field shall be present,
 *   otherwise the Source Interface field shall not be present.
 * - Bit 8: Spare, for future use and set to 0.
 *
 * At least one of the V4 and V6 flags shall be set to "1",
 * and both may be set to "1".
 *
 * If both the ASSONI and ASSOSI flags are set to "0", this shall indicate
 * that the User Plane IP Resource Information provided can be used
 * by CP function for any Network Instance and any Source Interface
 * of GTP-U user plane in the UP function.  Octet 6 (TEID Range) shall be
 * present if the TEID Range Indication is not set to zero and
 * shall contain a value of the bits which are used to partition the TEID range.
 * E.g. if the TEID Range Indication is set to "4", then Octet 6 shall be
 * one of values between 0 and 15. When TEID Range Indication is set to zero,
 * the Octet 6 shall not be present, the TEID is not partitioned,
 * i.e. all TEID values are available for use by the CP function.
 *
 * Octets "m to (m+3)" and/or "p to (p+15)" (IPv4 address / IPv6 address fields)
 * , if present, shall contain the respective IP address values.
 *
 * Octets "k to l", if present, shall contain a Network Instance value
 * as encoded in octet "5 to n+4" of the Figure 8.2.4-1 in clause 8.2.4,
 * identifying a Network Instance with which the IP address or TEID Range
 * is associated.
 *
 * Octet r, if present, shall contain a Source Interface value as encoded
 * in octet 5 of the Figure 8.2.2-1 in clause 8.2.2,
 * identifying the Source Interface with which the IP address or TEID Range
 * is associated.
 */
int16_t ogs_pfcp_build_user_plane_ip_resource_info(
        ogs_tlv_octet_t *octet,
        ogs_user_plane_ip_resource_info_t *info,
        void *data, int data_len);
int16_t ogs_pfcp_parse_user_plane_ip_resource_info(
        ogs_user_plane_ip_resource_info_t *info,
        ogs_tlv_octet_t *octet);

/*
 * 8.2.5 SDF Filter
 *
 * The SDF Filter IE type shall be encoded as shown in Figure 8.2.5-1.
 * It contains an SDF Filter, i.e. a single IP flow packet filter.
 *
 * The following flags are coded within Octet 5:
 * - Bit 1 – FD (Flow Description): If this bit is set to "1",
 *   then the Length of Flow Description and the Flow Description fields
 *   shall be present, otherwise they shall not be present.
 * - Bit 2 – TTC (ToS Traffic Class): If this bit is set to "1",
 *   then the ToS Traffic Class field shall be present,
 *   otherwise the ToS Traffic Class field shall not be present.
 * - Bit 3 – SPI (Security Parameter Index): If this bit is set to "1",
 *   then the Security Parameter Index field shall be present,
 *   otherwise the Security Parameter Index field shall not be present.
 * - Bit 4 – FL (Flow Label): If this bit is set to "1",
 *   then the Flow Label field shall be present, otherwise the Flow Label field
 *   shall not be present.
 * - Bit 5 – BID (Bidirectional SDF Filter): If this bit is set to "1",
 *   then the SDF Filter ID shall be present, otherwise the SDF Filter ID
 *   shall not be present.
 * - Bit 6 to 8: Spare, for future use and set to 0.
 *
 * The Flow Description field, when present, shall be encoded as an OctetString
 * as specified in clause 5.4.2 of 3GPP TS 29.212 [8].
 *
 * The ToS Traffic Class field, when present, shall be encoded as an OctetString
 * on two octets as specified in clause 5.3.15 of 3GPP TS 29.212 [8].
 *
 * The Security Parameter Index field, when present, shall be encoded as
 * an OctetString on four octets and shall contain the IPsec security parameter
 * index (which is a 32-bit field), as specified in clause 5.3.51
 * of 3GPP TS 29.212 [8].
 *
 * The Flow Label field, when present, shall be encoded as an OctetString
 * on 3 octets as specified in clause 5.3.52 of 3GPP TS 29.212 [8] and
 * shall contain an IPv6 flow label (which is a 20-bit field).
 *
 * The bits 8 to 5 of the octet "v" shall be spare and set to zero, and
 * the remaining 20 bits shall contain the IPv6 flow label.
 *
 * An SDF Filter may:
 *
 * - be a pattern for matching the IP 5 tuple (source IP address or
 *   IPv6 network prefix, destination IP address or IPv6 network prefix,
 *   source port number, destination port number, protocol ID of the protocol
 *   above IP). In the pattern:
 *   - a value left unspecified in a filter matches any value of
 *     the corresponding information in a packet;
 *   - an IP address may be combined with a prefix mask;
 *   - port numbers may be specified as port ranges;
 *   - the pattern can be extended by the Type of Service (TOS) (IPv4) /
 *     Traffic class (IPv6) and Mask;
 *
 * - consist of the destination IP address and optional mask, protocol ID
 *   of the protocol above IP, the Type of Service (TOS) (IPv4) /
 *   Traffic class (IPv6) and Mask and the IPsec Security Parameter Index (SPI);
 *
 * - consist of the destination IP address and optional mask,
 *   the Type of Service (TOS) (IPv4) / Traffic class (IPv6) and Mask and
 *   the Flow Label (IPv6).
 *
 * NOTE 1: The details about the IPsec Security Parameter Index (SPI),
 *         the Type of Service (TOS) (IPv4) / Traffic class (IPv6) and Mask and
 *         the Flow Label (IPv6) are defined in 3GPP TS 23.060 [19] clause 15.3.
 *
 * - extend the packet inspection beyond the possibilities described above and
 *   look further into the packet. Such service data flow filters need
 *   to be predefined in the PGW-U, as specified in clause 5.11
 *   of 3GPP TS 23.214 [2].
 *
 * NOTE 2: Such filters may be used to support filtering with respect
 *         to a service data flow based on the transport and application
 *         protocols used above IP, e.g. for HTTP and WAP. Filtering
 *         for further application protocols and services can also be supported.
 *
 * The SDF Filter ID, when present, shall be encoded as
 * an Unsigned32 binary integer value. It shall uniquely identify
 * an SDF Filter among all the SDF Filters provisioned for a given PFCP Session.
 * The source/destination IP address and port information, in a bidirectional
 * SDF Filter, shall be set as for downlink IP flows. The SDF filter
 * for the opposite direction has the same parameters, but having
 * the source and destination address/port parameters swapped. When being
 * provisioned with a bidirectional SDF filter in a PDR,
 * the UP function shall apply the SDF filter as specified in clause 5.2.1A.2A.
 */

typedef struct ogs_pfcp_sdf_filter_s {
    union {
        struct {
ED6(uint8_t     spare1:3;,
    uint8_t     bid:1;,
    uint8_t     fl:1;,
    uint8_t     spi:1;,
    uint8_t     ttc:1;,
    uint8_t     fd:1;)
        };
        uint8_t flags;
    };

    uint8_t     spare2;
    uint16_t    flow_description_len;
    char        *flow_description;
    uint16_t    tos_traffic_class;
    uint32_t    security_parameter_index;
    uint32_t    flow_label;
    uint32_t    sdf_filter_id;
} __attribute__ ((packed)) ogs_pfcp_sdf_filter_t;

int16_t ogs_pfcp_build_sdf_filter(
        ogs_tlv_octet_t *octet, ogs_pfcp_sdf_filter_t *filter,
        void *data, int data_len);
int16_t ogs_pfcp_parse_sdf_filter(
        ogs_pfcp_sdf_filter_t *filter, ogs_tlv_octet_t *octet);

/*
 * 8.2.8 MBR
 *
 * The UL/DL MBR fields shall be encoded as kilobits per second
 * (1 kbps = 1000 bps) in binary value. The UL/DL MBR fields may require
 * converting values in bits per second to kilobits per second
 * when the UL/DL MBR values are received from an interface other than
 * GTPv2 interface. If such conversions result in fractions,
 * then the value of UL/DL MBR fields shall be rounded upwards.
 * The range of UL/DL MBR is specified in 3GPP TS 36.413 [10].
 *
 * NOTE: The encoding is aligned on the encoding specified
 * in 3GPP TS 29.274 [9].
 */

#define OGS_PFCP_BITRATE_LEN 10
typedef struct ogs_pfcp_bitrate_s {
    uint64_t    uplink;
    uint64_t    downlink;
} __attribute__ ((packed)) ogs_pfcp_bitrate_t;

int16_t ogs_pfcp_build_bitrate(ogs_tlv_octet_t *octet,
        ogs_pfcp_bitrate_t *bitrate, void *data, int data_len);
int16_t ogs_pfcp_parse_bitrate(
        ogs_pfcp_bitrate_t *bitrate, ogs_tlv_octet_t *octet);

#define OGS_PFCP_GATE_OPEN 0
#define OGS_PFCP_GATE_CLOSE 1
typedef struct ogs_pfcp_gate_status_s {
    union {
        struct {
ED3(uint8_t     spare:4;,
    uint8_t     uplink:2;,
    uint8_t     downlink:2;)
        };
        uint8_t value;
    };
} __attribute__ ((packed)) ogs_pfcp_gate_status_t;

/* 8.2.19 Reporting Triggers
 */
typedef struct ogs_pfcp_reporting_triggers_s {
    union {
        struct {
ED8(uint8_t linked_usage_reporting:1;,
    uint8_t dropped_dl_traffic_threshold:1;,
    uint8_t stop_of_traffic:1;,
    uint8_t start_of_traffic:1;,
    uint8_t quota_holding_time:1;,
    uint8_t time_threshold:1;,
    uint8_t volume_threshold:1;,
    uint8_t periodic_reporting:1;)
        };
        uint8_t reptri_5;
    };
    union {
        struct {
ED8(uint8_t quota_validity_time:1;,
    uint8_t ip_multicast_join_leave:1;,
    uint8_t event_quota:1;,
    uint8_t event_threshold:1;,
    uint8_t mac_addresses_reporting:1;,
    uint8_t envelope_closure:1;,
    uint8_t time_quota:1;,
    uint8_t volume_quota:1;)
        };
        uint8_t reptri_6;
    };
    union {
        struct {
ED3(uint8_t spare:6;,
    uint8_t user_plane_inactivity_timer:1;,
    uint8_t report_the_end_marker_reception:1;)
        };
        uint8_t reptri_7;
    };
} __attribute__ ((packed)) ogs_pfcp_reporting_triggers_t;

/*
 * 8.2.21 Report Type
 *
 * Octet 5 shall be encoded as follows:
 *
 * - Bit 1 – DLDR (Downlink Data Report): when set to 1,
 *           this indicates Downlink Data Report
 * - Bit 2 – USAR (Usage Report): when set to 1, this indicates a Usage Report
 * - Bit 3 – ERIR (Error Indication Report): when set to 1,
 *           this indicates an Error Indication Report.
 * - Bit 4 – UPIR (User Plane Inactivity Report): when set to 1,
 *           this indicates a User Plane Inactivity Report.
 * - Bit 5 – TMIR (TSC Management Information Report): when set to "1",
 *           this indicates a TSC Management Information Report.
 * - Bit 6 – Session Report (SESR): when set to "1",
 *           this indicates a Session Report.
 * - Bit 7 – UISR (UP Initiated Session Request): when set to "1",
 *           this indicates it is a UP function initiated request
 *           for a reason which is indicated by the PFCPSRReq-Flags,
 *           for the PFCP session.
 * - Bit 8 – Spare, for future use and set to "0".
 *
 * At least one bit shall be set to 1. Several bits may be set to 1.
 */
typedef struct ogs_pfcp_report_type_s {
    union {
        struct {
ED8(uint8_t     spare:1;,
    uint8_t     up_initiated_session_request:1;,
    uint8_t     session_report:1;,
    uint8_t     tsc_management_information_report:1;,
    uint8_t     user_plane_inactivity_report:1;,
    uint8_t     error_indication_report:1;,
    uint8_t     usage_report:1;,
    uint8_t     downlink_data_report:1;)
        };
        uint8_t value;
    };
} __attribute__ ((packed)) ogs_pfcp_report_type_t;

/*
 * 8.2.27 Downlink Data Service Information
 */
typedef struct ogs_pfcp_downlink_data_service_information_s {
    struct {
ED3(uint8_t     spare:6;,
    uint8_t     qfii:1;,
    uint8_t     ppi:1;)
    };
    union {
        uint8_t paging_policy_indication_value;
        uint8_t qfi;
        struct {
            uint8_t paging_policy_indication_value;
            uint8_t qfi;
        } both;
    };
} __attribute__ ((packed)) ogs_pfcp_downlink_data_service_information_t;

/*
 * 8.2.31 PFCPSMReq-Flags
 *
 * The following bits within Octet 5 shall indicate:
 * - Bit 1 – DROBU (Drop Buffered Packets): if this bit is set to 1,
 *   it indicates that the UP function shall drop all the packets currently
 *   buffered for the PFCP session, if any, prior to further applying
 *   the action specified in the Apply Action value of the FARs.
 * - Bit 2 – SNDEM (Send End Marker Packets): if this bit is set to 1,
 *   it indicates that the UP function shall construct and send End Marker
 *   packets towards the old F-TEID of the downstream node when switching
 *   to the new F- TEID.
 * - Bit 3 – QAURR (Query All URRs): if this bit is set to 1, it indicates
 *   that the UP function shall return immediate usage report(s)
 *   for all the URRs previously provisioned for this PFCP session.
 * - Bit 4 - SUMPC (Stop of Usage Measurement to Pause Charging):
 *   if this bit is set to "1", it indicates that the UP function
 *   shall stop the usage measurement for all URRs
 *   with the "ASPOC" flag set to "1".
 * - Bit 5 - RUMUC (Resume of Usage Measurement to Un-pause of Charging):
 *   if this bit is set to "1", it indicates that the UP function
 *   shall resume the usage measurement for all URRs
 *   with the "ASPOC" flag set to "1".
 * - Bit 6 - DETEID (Delete All DL N3mb and/or N19mb F-TEIDs):
 *   if this bit is set to "1", it indicates that the MB-UPF
 *   shall delete all NG-RAN N3mb DL F-TEIDs
 *   and all UPF N19mb DL F-TEIDs which were provisioned
 *   in Add MBS Unicast Parameters IEs for the MBS session
 *   (see clause 5.34.2.4).
 * - Bit 7 to 8 – Spare, for future use, shall be set to "0" by the sender
 *   and discarded by the receiver.
 */
typedef struct ogs_pfcp_smreq_flags_s {
    union {
        struct {
ED7(uint8_t     spare:2;,
    uint8_t     delete_all_dl_n3mb_and_or_n19mb_f_teids:1;,
    uint8_t     resume_of_usage_measurement_to_un_pause_of_charging:1;,
    uint8_t     stop_of_usage_measurement_to_pause_charging:1;,
    uint8_t     query_all_urrs:1;,
    uint8_t     send_end_marker_packets:1;,
    uint8_t     drop_buffered_packets:1;)
        };
        uint8_t value;
    };
} __attribute__ ((packed)) ogs_pfcp_smreq_flags_t;

/*
 * 8.2.40 Measurement Method
 *
 * Octet 5 shall be encoded as follows:
 * - Bit 1 – DURAT (Duration): when set to "1",
 *   this indicates a request for measuring the duration of the traffic.
 * - Bit 2 – VOLUM (Volume): when set to "1",
 *   this indicates a request for measuring the volume of the traffic.
 * - Bit 3 – EVENT (Event): when set to "1",
 *   this indicates a request for measuring the events.
 * - Bit 4 to 8: Spare, for future use and set to "0".
 *
 * At least one bit shall be set to "1". Several bits may be set to "1".
 */
#define OGS_PFCP_MEASUREMENT_METHOD_DURATION    1
#define OGS_PFCP_MEASUREMENT_METHOD_VOLUME      2
#define OGS_PFCP_MEASUREMENT_METHOD_EVENT       4
typedef uint8_t ogs_pfcp_measurement_method_t;

/*
 * 8.2.41 Usage Report Trigger
 *
 * The Usage Report Trigger IE shall be encoded as shown in Figure 8.2.41-1.
 * It indicates the trigger of the usage report.
 */
typedef struct ogs_pfcp_usage_report_trigger_s {
    union {
        struct {
ED8(uint8_t immediate_report:1;;,
    uint8_t dropped_dl_traffic_threshold:1;,
    uint8_t stop_of_traffic:1;,
    uint8_t start_of_traffic:1;,
    uint8_t quota_holding_time:1;,
    uint8_t time_threshold:1;,
    uint8_t volume_threshold:1;,
    uint8_t periodic_reporting:1;)
        };
        uint8_t reptri_5;
    };
    union {
        struct {
ED8(uint8_t event_threshold:1;,
    uint8_t mac_addresses_reporting:1;,
    uint8_t envelope_closure:1;,
    uint8_t monitoring_time:1;,
    uint8_t termination_report:1;,
    uint8_t linked_usage_reporting:1;,
    uint8_t time_quota:1;,
    uint8_t volume_quota:1;)
        };
        uint8_t reptri_6;
    };
    union {
        struct {
ED7(uint8_t spare:2;,
    uint8_t user_plane_inactivity_timer:1;,
    uint8_t report_the_end_marker_reception:1;,
    uint8_t quota_validity_time:1;,
    uint8_t ip_multicast_join_leave:1;,
    uint8_t termination_by_up_function_report:1;,
    uint8_t event_quota:1;)
        };
        uint8_t reptri_7;
    };
} __attribute__ ((packed)) ogs_pfcp_usage_report_trigger_t;

void ogs_pfcp_parse_usage_report_trigger(
        ogs_pfcp_usage_report_trigger_t *rep_trig,
        ogs_pfcp_tlv_usage_report_trigger_t *tlv);

/*
 * 8.2.42 Measurement Period
 *
 * The Measurement Period IE contains the period, in seconds,
 * for generating periodic usage reports or the periodic QoS monitoring reports.
 * It shall be encoded as shown in Figure 8.2.42-1.
 *
 * The Measurement Period field shall be encoded
 * as an Unsigned32 binary integer value.
 */
typedef uint32_t ogs_pfcp_measurement_period_t;

/*
 * 8.2.13 Volume Threshold
 */
typedef struct ogs_pfcp_volume_threshold_s {
    union {
        struct {
ED4(uint8_t spare:5;,
    uint8_t dlvol:1;,
    uint8_t ulvol:1;,
    uint8_t tovol:1;)
        };
    uint8_t flags;
    };

    uint64_t total_volume;
    uint64_t uplink_volume;
    uint64_t downlink_volume;

} __attribute__ ((packed)) ogs_pfcp_volume_threshold_t;

int16_t ogs_pfcp_build_volume(ogs_tlv_octet_t *octet,
        ogs_pfcp_volume_threshold_t *volume, void *data, int data_len);
int16_t ogs_pfcp_parse_volume(
        ogs_pfcp_volume_threshold_t *volume, ogs_tlv_octet_t *octet);

/*
 * 8.2.50 Volume Quota
 */
typedef ogs_pfcp_volume_threshold_t ogs_pfcp_volume_quota_t;

/*
 * 8.2.113 Event Threshold
 *
 * The Event Threshold IE contains the Number of events after
 * which the measurement report is to be generated by the UP function.
 *
 * It shall be encoded as shown in Figure 8.2.113-1.
 */
typedef uint32_t ogs_pfcp_event_threshold_t;

/*
 * 8.2.112 Event Quota
 *
 * The Event Quota IE type shall be encoded as shown in Figure 8.2.112-1.
 * It contains the event quota to be monitored by the UP function.
 */
typedef uint32_t ogs_pfcp_event_quota_t;

/*
 * 8.2.14 Time Threshold
 *
 * The Time Threshold IE contains the traffic duration threshold
 * to be monitored by the UP function. It shall be encoded as shown
 * in Figure 8.2.14-1.
 */
typedef uint32_t ogs_pfcp_time_threshold_t;

/*
 * 8.2.51 Time Quota
 *
 * The Time Quota IE type shall be encoded as shown in Figure 8.2.51-1.
 * It contains the time quota to be monitored by the UP function.
 */
typedef uint32_t ogs_pfcp_time_quota_t;

/*
 * 8.2.48 Quota Holding Time
 *
 * The Quota Holding Time IE type shall be encoded as shown in Figure 8.2.48-1.
 * It contains the quota holding time in seconds.
 *
 * The Quota Holding Time value shall be encoded as
 * an Unsigned32 binary integer value.
 */
typedef uint32_t ogs_pfcp_quota_holding_time_t;

/*
 * 8.2.132 Quota Validity Time
 *
 * The Quota Validity Time IE type shall be encoded as shown
 * in Figure 8.2.132-1. It contains the quota validity time in seconds.
 *
 * The Quota Validity Time value shall be encoded as
 * an Unsigned32 binary integer value.
 */
typedef uint32_t ogs_pfcp_quota_validity_time_t;

/*
 * 8.2.49 Dropped DL Traffic Threshold
 *
 * The Dropped DL Traffic Threshold IE type shall be encoded as shown
 * in Figure 8.2.49-1. It contains the dropped DL traffic volume thresholds
 * to be monitored by the UP function.
 *
 * The following flags are coded within Octet 5:
 * - Bit 1 – DLPA: If this bit is set to "1",
 *   then the Downlink Packets field shall be present,
 *   otherwise the Downlink Packets field shall not be present.
 * - Bit 2 – DLBY: If this bit is set to "1",
 *   then the Number of Bytes of Downlink Data field shall be present,
 *   otherwise the Number of Bytes of Downlink Data field shall not be present.
 * - Bit 3 to 8: Spare, for future use and set to "0".
 *
 *
 * The Downlink Packets fields shall be encoded as an Unsigned64 binary
 * integer value. It shall contain a number of downlink packets.
 *
 * The Number of Bytes of Downlink Data fields shall be encoded
 * as an Unsigned64 binary integer value. It shall contain the number
 * of bytes of the downlink data.
 */
typedef struct ogs_pfcp_dropped_dl_traffic_threshold_s {
    union {
        struct {
ED3(uint8_t spare:6;,
    uint8_t dlby:1;,
    uint8_t dlpa:1;)
        };
        uint8_t flags;
    };
    uint64_t downlink_packets;
    uint64_t number_of_bytes_of_downlink_data;
} __attribute__ ((packed)) ogs_pfcp_dropped_dl_traffic_threshold_t;

int16_t ogs_pfcp_build_dropped_dl_traffic_threshold(
        ogs_tlv_octet_t *octet,
        ogs_pfcp_dropped_dl_traffic_threshold_t *threshold,
        void *data, int data_len);
int16_t ogs_pfcp_parse_dropped_dl_traffic_threshold(
        ogs_pfcp_dropped_dl_traffic_threshold_t *threshold,
        ogs_tlv_octet_t *octet);

/** 8.2.71 UR-SEQN
 *
 * The UR-SEQN (Usage Report Sequence Number) IE identifies the order
 * in which a usage report is generated for a
 * given URR. It shall be encoded as shown in Figure 8.2.71-1.
 *
 * The UR-SEQN value shall be encoded as an Unsigned32 binary integer value.
*/
typedef uint32_t ogs_pfcp_urr_ur_seqn_t;

/** 8.2.52 Start Time
 *
 * The Start Time IE indicates the time at which the UP function started
 * to collect the charging information. It shall be encoded as shown
 * in Figure 8.2.52-1.
 *
 * The Start Time field shall contain a UTC time. Octets 5 to 8 shall
 * be encoded in the same format as the first four octets
 * of the 64-bit timestamp format as defined in clause 6 of IETF RFC 5905 [12].
 *
 * NOTE: The encoding is defined as the time in seconds relative to 00:00:00
 * on 1 January 1900.
 */
typedef uint32_t ogs_pfcp_start_time_t;

/** 8.2.53 End Time
 * The End Time IE indicates the time at which the UP function ended
 * to collect the charging information. It shall be encoded as shown
 * in Figure 8.2.53-1.
 *
 * The End Time field shall contain a UTC time. Octets 5 to 8 shall be
 * encoded in the same format as the first four octets of the 64-bit timestamp
 * format as defined in clause 6 of IETF RFC 5905 [12].
 *
 * NOTE: The encoding is defined as the time in seconds relative to 00:00:00
 * on 1 January 1900.
*/
typedef uint32_t ogs_pfcp_end_time_t;

/** 8.2.45 Duration Measurement
 *
 * The Duration Measurement IE type shall be encoded as shown
 * in Figure 8.2.45-1. It contains the used time in seconds
 *
 * The Duration value shall be encoded as an Unsigned32 binary integer value.
*/
typedef uint32_t ogs_pfcp_duration_measurement_t;

/** 8.2.46 Time of First Packet
 *
 * The Time of First Packet IE indicates the time stamp for the first
 * IP packet transmitted for a given usage report. It shall be encoded
 * as shown in Figure 8.2.46-1.
 *
 * The End Time field shall contain a UTC time. Octets 5 to 8 shall
 * be encoded in the same format as the first four octets
 * of the 64-bit timestamp format as defined in clause 6 of IETF RFC 5905 [12].
 *
 * NOTE: The encoding is defined as the time in seconds relative to 00:00:00
 * on 1 January 1900.
*/
typedef uint32_t ogs_pfcp_time_of_first_packet_t;

/** 8.2.47 Time of Last Packet
 *
 * The Time of Last Packet IE indicates the time stamp for the last
 * IP packet transmitted for a given usage report. It shall be encoded
 * as shown in Figure 8.2.47-1.
 *
 * The End Time field shall contain a UTC time. Octets 5 to 8 shall
 * be encoded in the same format as the first four octets
 * of the 64-bit timestamp format as defined in clause 6 of IETF RFC 5905 [12].
 *
 * NOTE: The encoding is defined as the time in seconds relative to 00:00:00
 * on 1 January 1900.
*/
typedef uint32_t ogs_pfcp_time_of_last_packet_t;

/** 8.2.44 Volume Measurement
 *
 * The Volume Measurement IE contains the measured traffic volumes.
 * It shall be encoded as shown in Figure 8.2.44-1.
 *
 * The following flags are coded within Octet 5:
 *
 * - Bit 1 – TOVOL: If this bit is set to "1", then the Total Volume field
 *   shall be present, otherwise the Total Volume field shall not be present.
 * - Bit 2 – ULVOL: If this bit is set to "1", then the Uplink Volume field
 *   shall be present, otherwise the Uplink Volume field shall not be present.
 * - Bit 3 – DLVOL: If this bit is set to "1", then the Downlink Volume field
 *   shall be present, otherwise the Downlink Volume field shall not be present.
 * - Bit 4 – TONOP: If this bit is set to "1", then the Total Number of Packets
 *   field shall be present, otherwise the Total Number of Packets field
 *   shall not be present.
 * - Bit 5 – ULNOP: If this bit is set to "1", then the Uplink Number
 *   of Packets field shall be present, otherwise the Uplink Number
 *   of Packets field shall not be present.
 * - Bit 6 – DLNOP: If this bit is set to "1", then the Downlink Number
 *   of Packets field shall be present, otherwise the Downlink Number
 *   of Packets field shall not be present.
 * - Bit 7 to bit 8: Spare, for future use and set to "0".
 *
 * At least one bit shall be set to "1". Several bits may be set to "1".
 *
 * The Total Volume, Uplink Volume and Downlink Volume fields shall be encoded
 * as an Unsigned64 binary integer value. They shall contain the total,
 * uplink or downlink number of octets respectively
*/
typedef struct ogs_pfcp_volume_measurement_s {
    union {
        struct {
ED7(uint8_t spare:2;,
    uint8_t dlnop:1;,
    uint8_t ulnop:1;,
    uint8_t tonop:1;,
    uint8_t dlvol:1;,
    uint8_t ulvol:1;,
    uint8_t tovol:1;)
        };
    uint8_t flags;
    };

    uint64_t total_volume;
    uint64_t uplink_volume;
    uint64_t downlink_volume;
    uint64_t total_n_packets;
    uint64_t uplink_n_packets;
    uint64_t downlink_n_packets;
} __attribute__ ((packed)) ogs_pfcp_volume_measurement_t;

/*
 * 8.2.68 Measurement Information
 */
typedef struct ogs_pfcp_measurement_information_s {
    union {
        struct {
ED6(uint8_t spare:3;,
    uint8_t mnop:1;,
    uint8_t istm:1;,
    uint8_t radi:1;,
    uint8_t inam:1;,
    uint8_t mbqe:1;)
        };
    uint8_t octet5;
    };
} __attribute__ ((packed)) ogs_pfcp_measurement_information_t;

/*
 * 8.2.179 Data Status
 *
 * The following flags are coded within Octet 5:
 *
 * Bit 1 – DROP: when set to "1", this indicates first DL packet is
 * discarded by the UP function.
 * Bit 2 – BUFF: when set to "1", this indicates first DL packet is
 * received and buffered by the UP function.
 * Bit 3 to 8 Spare, for future use and set to "0".
 */
#define OGS_PFCP_DATA_STATUS_DROP                          (1<<0)
#define OGS_PFCP_DATA_STATUS_BUFF                          (1<<1)
typedef uint8_t  ogs_pfcp_data_status_t;

typedef struct ogs_pfcp_user_plane_report_s {
    ogs_pfcp_report_type_t type;
    struct {
        uint8_t pdr_id;
        uint8_t paging_policy_indication_value;
        uint8_t qfi;
    } downlink_data;
    struct {
        ogs_pfcp_urr_id_t id;
        ogs_pfcp_urr_ur_seqn_t seqn;
        ogs_pfcp_usage_report_trigger_t rep_trigger;
        ogs_pfcp_start_time_t start_time;
        ogs_pfcp_end_time_t end_time;
        ogs_pfcp_volume_measurement_t vol_measurement;
        ogs_pfcp_duration_measurement_t dur_measurement;
        ogs_pfcp_time_of_first_packet_t time_of_first_packet;
        ogs_pfcp_time_of_last_packet_t time_of_last_packet;
    } usage_report [OGS_MAX_NUM_OF_URR];
    unsigned int num_of_usage_report;
    struct {
        ogs_pfcp_f_teid_t remote_f_teid;
        int remote_f_teid_len;
    } error_indication;
} ogs_pfcp_user_plane_report_t;

int16_t ogs_pfcp_build_volume_measurement(ogs_tlv_octet_t *octet,
        ogs_pfcp_volume_measurement_t *volume, void *data, int data_len);
int16_t ogs_pfcp_parse_volume_measurement(
        ogs_pfcp_volume_measurement_t *volume, ogs_tlv_octet_t *octet);

/*
 * 8.2.101 User ID
 *
 * The User ID IE type shall be encoded as shown in Figure 8.2.101-1.
 *
 * The following flags are coded within Octet 5:
 *
 * - Bit 1 – IMSIF: If this bit is set to "1",
 *   then the Length of IMSI and IMSI fields shall be present,
 *   otherwise these fields shall not be present.
 * - Bit 2 – IMEIF: If this bit is set to "1",
 *   then the Length of IMEI and IMEI fields shall be present,
 *   otherwise these fields shall not be present.
 * - Bit 3 – MSISDNF: If this bit is set to "1",
 *   then the Length of MSISDN and MSISDN fields shall be present,
 *   otherwise these fields shall not be present.
 * - Bit 4 – NAIF: If this bit is set to "1",
 *   then the Length of NAI and NAI fields shall be present,
 *   otherwise these fields shall not be present.
 * - Bit 5 – SUPIF: If this bit is set to "1",
 *   then the Length of SUPI and SUPI fields shall be present,
 *   otherwise these fields shall not be present.
 * - Bit 6 – GPSIF: If this bit is set to "1",
 *   then the Length of GPSI and GPSI fields shall be present,
 *   otherwise these fields shall not be present.
 * - Bit 7 – PEIF: If this bit is set to "1",
 *   then the Length of PEI and PEI fields shall be present,
 *   otherwise these fields shall not be present.
 * - Bit 8: Spare, for future use and set to "0".
 *
 * One or more flags may be set to "1".
 *
 * For 5GS User Identities:
 * -The SUPI field shall only be used for carrying a Global Cable Identifier
 *  (GCI) or a Global Line Identifier (GLI). The IMSI and NAI, if received
 *  by the SMF in the SUPI, shall be included in the IMSI and NAI field respectively.
 * -The GPSI field shall only be used for carrying an External Identifier.
 *  The MSISDN, if received by the SMF in the SUPI, shall be included
 *  in the MSISDN field.
 * -The PEI field shall only be used for carrying an MAC address or
 *  an Extended Unique Identifier. The IMEI, if received by the SMF in the PEI,
 *  shall be included in the IMEI field.
 *
 * The coding of IMSI field, from octets 7 to 'a' shall be encoded
 * as the octets 5 to n+4 of the IMSI IE type
 * specified in clause 8.3 of 3GPP TS 29.274 [9].
 *
 * The coding of IMEI field, in octets 'b+1' to 'c' shall be encoded
 * as the octets 5 to n+4 of the MEI IE type
 * specified in clause 8.10 of 3GPP TS 29.274 [9].
 *
 * The coding of MSISDN field, in octets 'd+1' to 'e' shall be encoded
 * as the octets 5 to n+4 of the MSISDN IE type
 * specified in clause 8.11 of 3GPP TS 29.274 [9].
 *
 * The coding of the SUPI field, in octets 'h+1' to 'i' shall be encoded
 * as the Supi data type specified in clause 5.3.2 of 3GPP TS 29.571 [61].
 *
 * The coding of the GPSI field, in octets 'j+1' to 'k' shall be encoded
 * as the Gpsi data type specified in clause 5.3.2 of 3GPP TS 29.571 [61].
 *
 * The coding of the PEI field, in octets 'l+1' to 'm' shall be encoded
 * as the Pei data type specified in clause 5.3.2 of 3GPP TS 29.571 [61].
 *
 * The NAI field, in octets 'f+1' to 'g' shall be encoded as an Octet String
 * (see IETF RFC 4282 [36]).
 */
typedef struct ogs_pfcp_user_id_flags_s {
    union {
        struct {
ED8(uint8_t spare:1;,
    uint8_t peif:1;,
    uint8_t gpsif:1;,
    uint8_t supif:1;,
    uint8_t naif:1;,
    uint8_t msisdnf:1;,
    uint8_t imeif:1;,
    uint8_t imsif:1;)
        };
    uint8_t flags;
    };
} ogs_pfcp_user_id_flags_t;

typedef struct ogs_pfcp_user_id_s {
    union {
        struct {
ED8(uint8_t spare:1;,
    uint8_t peif:1;,
    uint8_t gpsif:1;,
    uint8_t supif:1;,
    uint8_t naif:1;,
    uint8_t msisdnf:1;,
    uint8_t imeif:1;,
    uint8_t imsif:1;)
        };
    uint8_t flags;
    };

    uint8_t imsi_len;
    uint8_t imsi[OGS_MAX_IMSI_LEN];
    uint8_t imeisv_len;
    uint8_t imeisv[OGS_MAX_IMEISV_LEN];
    uint8_t msisdn_len;
    uint8_t msisdn[OGS_MAX_MSISDN_LEN];
} ogs_pfcp_user_id_t;

int16_t ogs_pfcp_build_user_id(
        ogs_tlv_octet_t *octet, ogs_pfcp_user_id_t *user_id,
        void *data, int data_len);

/*
 * 8.2.118 3GPP Interface Type
 *
 * NOTE 1: If separation of roaming and non-roaming traffic is desired
 * this value should only be used for the S5-U interface
 * and "S8-U" (decimal 19) should be used for the S8-U interface.
 * NOTE 2: If separation of roaming and non-roaming traffic is desired
 * this value should only be used for the Gn-U interface
 * and "Gp-U" (decimal 20) should be used for the Gp-U interface.
 * NOTE 3: If separation of roaming and non-roaming traffic is desired,
 * this value should only be used for N9 non-roaming interfaces
 * and (decimal value "21") should be used for N9 roaming interfaces.
 */
#define OGS_PFCP_3GPP_INTERFACE_TYPE_S1_U       0
#define OGS_PFCP_3GPP_INTERFACE_TYPE_S5_S8_U    1  /* NOTE 1 */
#define OGS_PFCP_3GPP_INTERFACE_TYPE_S4_U       2
#define OGS_PFCP_3GPP_INTERFACE_TYPE_S11_U      3
#define OGS_PFCP_3GPP_INTERFACE_TYPE_S12        4
#define OGS_PFCP_3GPP_INTERFACE_TYPE_GN_GP_U    5  /* NOTE 2 */
#define OGS_PFCP_3GPP_INTERFACE_TYPE_S2A_U      6
#define OGS_PFCP_3GPP_INTERFACE_TYPE_S2B_U      7
#define OGS_PFCP_3GPP_INTERFACE_TYPE_ENB_GTP_U_FOR_DL_DATA_FORWARDING 8
#define OGS_PFCP_3GPP_INTERFACE_TYPE_ENB_GTP_U_FOR_UL_DATA_FORWARDING 9
#define OGS_PFCP_3GPP_INTERFACE_TYPE_SGW_UPF_GTP_U_FOR_DL_DATA_FORWARDING 10
#define OGS_PFCP_3GPP_INTERFACE_TYPE_N3_3GPP_ACCESS 11
#define OGS_PFCP_3GPP_INTERFACE_TYPE_N3_TRUSTED_NON_3GPP_ACCESS 12
#define OGS_PFCP_3GPP_INTERFACE_TYPE_N3_UNTRUSTED_NON_3GPP_ACCESS 13
#define OGS_PFCP_3GPP_INTERFACE_TYPE_N3_FOR_DATA_FORWARDING 14
#define OGS_PFCP_3GPP_INTERFACE_TYPE_N9         15 /* NOTE 3 */
#define OGS_PFCP_3GPP_INTERFACE_TYPE_SGI        16
#define OGS_PFCP_3GPP_INTERFACE_TYPE_N6         17
#define OGS_PFCP_3GPP_INTERFACE_TYPE_N19        18
#define OGS_PFCP_3GPP_INTERFACE_TYPE_S8_U       19
#define OGS_PFCP_3GPP_INTERFACE_TYPE_GP_U       20
#define OGS_PFCP_3GPP_INTERFACE_TYPE_N9_FOR_ROAMING 21
#define OGS_PFCP_3GPP_INTERFACE_TYPE_IU_U       22
#define OGS_PFCP_3GPP_INTERFACE_TYPE_N9_FOR_DATA_FORWARDING 23
#define OGS_PFCP_3GPP_INTERFACE_TYPE_SXA_U      24
#define OGS_PFCP_3GPP_INTERFACE_TYPE_SXB_U      25
#define OGS_PFCP_3GPP_INTERFACE_TYPE_SXC_U      26
#define OGS_PFCP_3GPP_INTERFACE_TYPE_N4_U       27
#define OGS_PFCP_3GPP_INTERFACE_TYPE_SGW_UPF_GTP_U_FOR_UL_DATA_FORWARDING 28
#define OGS_PFCP_3GPP_INTERFACE_TYPE_N6MB_NMB9  29
#define OGS_PFCP_3GPP_INTERFACE_TYPE_N3MB       30
#define OGS_PFCP_3GPP_INTERFACE_TYPE_N19MB      31
#define OGS_PFCP_3GPP_INTERFACE_TYPE_UNKNOWN    0xff
typedef uint8_t ogs_pfcp_3gpp_interface_type_t;

/*
 * 8.2.136 PFCPSEReq-Flags
 *
 * The following bits within Octet 5 shall indicate:
 * - Bit 1 – RESTI (Restoration Indication): if this bit is set to "1",
 *   it indicates to the UP function that the PFCP session to be established is
 *   to restore an existing PFCP session.
 * - Bit 2 – SUMPC (Stop of Usage Measurement to Pause Charging):
 *   if this bit is set to "1", it indicates that the UP function shall
 *   stop the usage measurement for all URRs with the "ASPOC" flag set to "1".
 */
typedef struct ogs_pfcp_sereq_flags_s {
    union {
        struct {
ED3(uint8_t     spare:6;,
    uint8_t     stop_of_usage_measurement_to_pause_charging:1;,
    uint8_t     restoration_indication:1;)
        };
        uint8_t value;
    };
} __attribute__ ((packed)) ogs_pfcp_sereq_flags_t;

#ifdef __cplusplus
}
#endif

#endif /* OGS_PFCP_TYPES_H */
===== util.c =====
/*
 * Copyright (C) 2025 by Sukchan Lee <acetcom@gmail.com>
 *
 * This file is part of Open5GS.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "ogs-pfcp.h"

/*
 * Requirements of Node ID:
 * NONE      : Node ID must not be present
 * OPTIONAL  : Node ID may or may not be present
 * MANDATORY : Node ID must be present
 */
#define OGS_PFCP_NODE_ID_NONE      0
#define OGS_PFCP_NODE_ID_OPTIONAL  1
#define OGS_PFCP_NODE_ID_MANDATORY 2

/*
 * This function extracts the PFCP Node ID from the given PFCP message.
 * It determines the Node ID field location and requirement based on
 * the message type. Then it validates presence and copies data into
 * 'node_id'. If Node ID is not consistent with the requirement, an
 * error status is returned.
 */
ogs_pfcp_status_e
ogs_pfcp_extract_node_id(ogs_pfcp_message_t *message,
                         ogs_pfcp_node_id_t *node_id)
{

    /* For C89 compliance, all variables are declared upfront. */
    ogs_pfcp_tlv_node_id_t *tlv_node_id = NULL;
    int requirement = OGS_PFCP_NODE_ID_NONE;
    ogs_pfcp_status_e status = OGS_PFCP_STATUS_SUCCESS;

    /* Validate input pointers */
    ogs_assert(message);
    ogs_assert(node_id);

    /* Initialize the output structure */
    memset(node_id, 0, sizeof(*node_id));

    /* Determine the location of node_id TLV and requirement */
    switch (message->h.type) {
    case OGS_PFCP_PFD_MANAGEMENT_REQUEST_TYPE:
        tlv_node_id = &message->pfcp_pfd_management_request.node_id;
        requirement = OGS_PFCP_NODE_ID_OPTIONAL;
        break;

    case OGS_PFCP_PFD_MANAGEMENT_RESPONSE_TYPE:
        tlv_node_id = &message->pfcp_pfd_management_response.node_id;
        requirement = OGS_PFCP_NODE_ID_OPTIONAL;
        break;

    case OGS_PFCP_ASSOCIATION_SETUP_REQUEST_TYPE:
        tlv_node_id = &message->pfcp_association_setup_request.node_id;
        requirement = OGS_PFCP_NODE_ID_MANDATORY;
        break;

    case OGS_PFCP_ASSOCIATION_SETUP_RESPONSE_TYPE:
        tlv_node_id = &message->pfcp_association_setup_response.node_id;
        requirement = OGS_PFCP_NODE_ID_MANDATORY;
        break;

    case OGS_PFCP_ASSOCIATION_UPDATE_REQUEST_TYPE:
        tlv_node_id = &message->pfcp_association_update_request.node_id;
        requirement = OGS_PFCP_NODE_ID_MANDATORY;
        break;

    case OGS_PFCP_ASSOCIATION_UPDATE_RESPONSE_TYPE:
        tlv_node_id = &message->pfcp_association_update_response.node_id;
        requirement = OGS_PFCP_NODE_ID_MANDATORY;
        break;

    case OGS_PFCP_ASSOCIATION_RELEASE_REQUEST_TYPE:
        tlv_node_id = &message->pfcp_association_release_request.node_id;
        requirement = OGS_PFCP_NODE_ID_MANDATORY;
        break;

    case OGS_PFCP_ASSOCIATION_RELEASE_RESPONSE_TYPE:
        tlv_node_id = &message->pfcp_association_release_response.node_id;
        requirement = OGS_PFCP_NODE_ID_MANDATORY;
        break;

    case OGS_PFCP_NODE_REPORT_REQUEST_TYPE:
        tlv_node_id = &message->pfcp_node_report_request.node_id;
        requirement = OGS_PFCP_NODE_ID_MANDATORY;
        break;

    case OGS_PFCP_NODE_REPORT_RESPONSE_TYPE:
        tlv_node_id = &message->pfcp_node_report_response.node_id;
        requirement = OGS_PFCP_NODE_ID_MANDATORY;
        break;

    case OGS_PFCP_SESSION_SET_DELETION_REQUEST_TYPE:
        tlv_node_id = &message->pfcp_session_set_deletion_request.node_id;
        requirement = OGS_PFCP_NODE_ID_MANDATORY;
        break;

    case OGS_PFCP_SESSION_SET_DELETION_RESPONSE_TYPE:
        tlv_node_id = &message->pfcp_session_set_deletion_response.node_id;
        requirement = OGS_PFCP_NODE_ID_MANDATORY;
        break;

    case OGS_PFCP_SESSION_SET_MODIFICATION_REQUEST_TYPE:
        tlv_node_id = &message->pfcp_session_set_modification_request.node_id;
        requirement = OGS_PFCP_NODE_ID_MANDATORY;
        break;

    case OGS_PFCP_SESSION_SET_MODIFICATION_RESPONSE_TYPE:
        tlv_node_id = &message->pfcp_session_set_modification_response.node_id;
        requirement = OGS_PFCP_NODE_ID_MANDATORY;
        break;

    case OGS_PFCP_SESSION_ESTABLISHMENT_REQUEST_TYPE:
        tlv_node_id = &message->pfcp_session_establishment_request.node_id;
        requirement = OGS_PFCP_NODE_ID_MANDATORY;
        break;

    case OGS_PFCP_SESSION_ESTABLISHMENT_RESPONSE_TYPE:
        tlv_node_id = &message->pfcp_session_establishment_response.node_id;
        requirement = OGS_PFCP_NODE_ID_MANDATORY;
        break;

    case OGS_PFCP_SESSION_MODIFICATION_REQUEST_TYPE:
        tlv_node_id = &message->pfcp_session_modification_request.node_id;
        requirement = OGS_PFCP_NODE_ID_OPTIONAL;
        break;

    /* Add other message types with node_id here as needed */

    case OGS_PFCP_HEARTBEAT_REQUEST_TYPE:
    case OGS_PFCP_HEARTBEAT_RESPONSE_TYPE:
    case OGS_PFCP_VERSION_NOT_SUPPORTED_RESPONSE_TYPE:
    case OGS_PFCP_SESSION_MODIFICATION_RESPONSE_TYPE:
    case OGS_PFCP_SESSION_DELETION_REQUEST_TYPE:
    case OGS_PFCP_SESSION_DELETION_RESPONSE_TYPE:
    case OGS_PFCP_SESSION_REPORT_REQUEST_TYPE:
    case OGS_PFCP_SESSION_REPORT_RESPONSE_TYPE:
        /* Node ID must not be present for these messages */
        requirement = OGS_PFCP_NODE_ID_NONE;
        break;

    default:
        /* Unknown message type */
        ogs_error("Unknown message type %d", message->h.type);
        return OGS_PFCP_ERROR_UNKNOWN_MESSAGE;
    }

    /* Check requirement vs. tlv_node_id existence */
    switch (requirement) {
    case OGS_PFCP_NODE_ID_MANDATORY:
        /* Must have tlv_node_id. presence must be 1. */
        ogs_assert(tlv_node_id);
        if (!tlv_node_id->presence) {
            status = OGS_PFCP_ERROR_NODE_ID_NOT_PRESENT;
            goto done;
        }
        break;

    case OGS_PFCP_NODE_ID_OPTIONAL:
        /*
         * Must have tlv_node_id. presence=1 => real Node ID
         * presence=0 => no Node ID
         */
        ogs_assert(tlv_node_id);
        if (!tlv_node_id->presence) {
            status = OGS_PFCP_STATUS_NODE_ID_OPTIONAL_ABSENT;
            goto done;
        }
        break;

    case OGS_PFCP_NODE_ID_NONE:
        /* Must be NULL => no Node ID field */
        ogs_assert(tlv_node_id == NULL);
        status = OGS_PFCP_STATUS_NODE_ID_NONE;
        goto done;

    default:
        status = OGS_PFCP_ERROR_UNKNOWN_MESSAGE;
        goto done;
    }

    memcpy(node_id, tlv_node_id->data, tlv_node_id->len);

    if (node_id->type != OGS_PFCP_NODE_ID_IPV4 &&
        node_id->type != OGS_PFCP_NODE_ID_IPV6 &&
        node_id->type != OGS_PFCP_NODE_ID_FQDN) {
        ogs_error("Semantic incorrect message[%d] type[%d]",
                message->h.type, node_id->type);
        return OGS_PFCP_ERROR_SEMANTIC_INCORRECT_MESSAGE;
    }

     /* Node ID is valid */
    status = OGS_PFCP_STATUS_SUCCESS;

done:
    return status;
}

ogs_sockaddr_t *ogs_pfcp_node_id_to_addrinfo(const ogs_pfcp_node_id_t *node_id)
{
    ogs_sockaddr_t *p;
    int ret;
    uint16_t port = ogs_pfcp_self()->pfcp_port;
    char fqdn[OGS_MAX_FQDN_LEN+1];

    ogs_assert(node_id);
    switch (node_id->type) {

    /*------------------------------------------------
     * 1) IPv4
     *-----------------------------------------------*/
    case OGS_PFCP_NODE_ID_IPV4:
        p = (ogs_sockaddr_t *)ogs_calloc(1, sizeof(*p));
        if (!p) {
            ogs_error("ogs_calloc() failed");
            return NULL;
        }
        p->sa.sa_family = AF_INET;
        p->sin.sin_port = htobe16(port);
        p->sin.sin_addr.s_addr = node_id->addr;
        p->next = NULL;
        return p;

    /*------------------------------------------------
     * 2) IPv6
     *-----------------------------------------------*/
    case OGS_PFCP_NODE_ID_IPV6:
        p = (ogs_sockaddr_t *)ogs_calloc(1, sizeof(*p));
        if (!p) {
            ogs_error("ogs_calloc() failed");
            return NULL;
        }
        p->sa.sa_family = AF_INET6;
        p->sin6.sin6_port = htobe16(port);
        /* Copy 16 bytes of IPv6 address */
        memcpy(&p->sin6.sin6_addr, node_id->addr6, 16);
        p->next = NULL;
        return p;

    /*------------------------------------------------
     * 3) FQDN
     *-----------------------------------------------*/
    case OGS_PFCP_NODE_ID_FQDN:
        /* If the FQDN is not empty, we attempt DNS resolution.
         *  ogs_addaddrinfo() is a placeholder for your actual
         *  DNS -> ogs_sockaddr_t function (often wraps getaddrinfo).
         */
        /* Port=0 or set as needed, family=AF_UNSPEC, flags=0. */
        if (ogs_fqdn_parse(fqdn, node_id->fqdn, strlen(node_id->fqdn)) <= 0) {
            ogs_error("ogs_fqdn_parse() error [%s]", node_id->fqdn);
            return NULL;
        }
        ret = ogs_getaddrinfo(&p, AF_UNSPEC, fqdn, port, 0);
        if (ret != 0) {
            /* DNS resolution failed => *out remains NULL */
            ogs_error("ogs_addaddrinfo() failed");
            return NULL;
        }
        /* If FQDN is empty, just return with no addresses. */
        return p;

    /*------------------------------------------------
     * 4) Unsupported type or default
     *-----------------------------------------------*/
    default:
        /* Optionally handle an error or just return success
         * with no addresses.
         */
        ogs_error("Unknown type [%d]", node_id->type);
        return NULL;
    }
}

/* Utility function to convert node_id to string for logging */
const char *ogs_pfcp_node_id_to_string_static(
        const ogs_pfcp_node_id_t *node_id)
{
    static char buffer[OGS_MAX_FQDN_LEN+1] = { 0, };

    if (node_id) {
        switch (node_id->type) {
        case OGS_PFCP_NODE_ID_IPV4:
            inet_ntop(AF_INET, &node_id->addr, buffer, sizeof(buffer));
            break;
        case OGS_PFCP_NODE_ID_IPV6:
            inet_ntop(AF_INET6, node_id->addr6, buffer, sizeof(buffer));
            break;
        case OGS_PFCP_NODE_ID_FQDN:
            if (ogs_fqdn_parse(buffer,
                               node_id->fqdn,
                               strlen(node_id->fqdn)) <= 0)
                snprintf(buffer, sizeof(buffer), "%s", node_id->fqdn);
            break;
        default:
            snprintf(buffer, sizeof(buffer), "Unknown");
            break;
        }
    }

    return buffer;
}
===== util.h =====
/*
 * Copyright (C) 2025 by Sukchan Lee <acetcom@gmail.com>
 *
 * This file is part of Open5GS.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#if !defined(OGS_PFCP_INSIDE) && !defined(OGS_PFCP_COMPILATION)
#error "This header cannot be included directly."
#endif

#ifndef OGS_PFCP_UTIL_H
#define OGS_PFCP_UTIL_H

#ifdef __cplusplus
extern "C" {
#endif

typedef enum {
    /* Success with actual Node ID */
    OGS_PFCP_STATUS_SUCCESS = 0,

    /* Success with no Node ID (NONE type) */
    OGS_PFCP_STATUS_NODE_ID_NONE,

    /* Success with OPTIONAL node_id_tlv, but presence=0 */
    OGS_PFCP_STATUS_NODE_ID_OPTIONAL_ABSENT,

    /* Error codes */
    OGS_PFCP_ERROR_SEMANTIC_INCORRECT_MESSAGE,
    OGS_PFCP_ERROR_NODE_ID_NOT_PRESENT,
    OGS_PFCP_ERROR_NODE_ID_NOT_FOUND,
    OGS_PFCP_ERROR_UNKNOWN_MESSAGE

} ogs_pfcp_status_e;

ogs_pfcp_status_e
ogs_pfcp_extract_node_id(ogs_pfcp_message_t *message,
                         ogs_pfcp_node_id_t *node_id);

ogs_sockaddr_t *ogs_pfcp_node_id_to_addrinfo(const ogs_pfcp_node_id_t *node_id);
const char *ogs_pfcp_node_id_to_string_static(
        const ogs_pfcp_node_id_t *node_id);

#ifdef __cplusplus
}
#endif

#endif /* OGS_PFCP_UTIL_H */
===== xact.c =====

#include "ogs-pfcp.h"
#include "ogs-app.h"

#define PFCP_MIN_XACT_ID             1
#define PFCP_MAX_XACT_ID             0x800000

typedef enum {
    PFCP_XACT_UNKNOWN_STAGE,
    PFCP_XACT_INITIAL_STAGE,
    PFCP_XACT_INTERMEDIATE_STAGE,
    PFCP_XACT_FINAL_STAGE,
} ogs_pfcp_xact_stage_t;

static int ogs_pfcp_xact_initialized = 0;
static uint32_t g_xact_id = 0;

static OGS_POOL(pool, ogs_pfcp_xact_t);

static ogs_pfcp_xact_t *ogs_pfcp_xact_remote_create(
        ogs_pfcp_node_t *node, uint32_t sqn);
static ogs_pfcp_xact_stage_t ogs_pfcp_xact_get_stage(
        uint8_t type, uint32_t xid);
static int ogs_pfcp_xact_update_rx(ogs_pfcp_xact_t *xact, uint8_t type);

static void response_timeout(void *data);
static void holding_timeout(void *data);
static void delayed_commit_timeout(void *data);

int ogs_pfcp_xact_init(void)
{
    ogs_assert(ogs_pfcp_xact_initialized == 0);

    ogs_pool_init(&pool, ogs_app()->pool.xact);

    g_xact_id = 0;

    ogs_pfcp_xact_initialized = 1;

    return OGS_OK;
}

void ogs_pfcp_xact_final(void)
{
    ogs_assert(ogs_pfcp_xact_initialized == 1);

    ogs_pool_final(&pool);

    ogs_pfcp_xact_initialized = 0;
}

ogs_pfcp_xact_t *ogs_pfcp_xact_local_create(ogs_pfcp_node_t *node,
        void (*cb)(ogs_pfcp_xact_t *xact, void *data), void *data)
{
    ogs_pfcp_xact_t *xact = NULL;

    ogs_assert(node);

    ogs_pool_id_calloc(&pool, &xact);
    ogs_assert(xact);
    xact->index = ogs_pool_index(&pool, xact);

    xact->org = OGS_PFCP_LOCAL_ORIGINATOR;
    xact->xid = OGS_NEXT_ID(g_xact_id, PFCP_MIN_XACT_ID, PFCP_MAX_XACT_ID);
    xact->node = node;
    xact->cb = cb;
    xact->data = data;

    xact->tm_response = ogs_timer_add(
            ogs_app()->timer_mgr, response_timeout,
            OGS_UINT_TO_POINTER(xact->id));
    ogs_assert(xact->tm_response);
    xact->response_rcount =
        ogs_local_conf()->time.message.pfcp.n1_response_rcount;

    xact->tm_holding = ogs_timer_add(
            ogs_app()->timer_mgr, holding_timeout,
            OGS_UINT_TO_POINTER(xact->id));
    ogs_assert(xact->tm_holding);
    xact->holding_rcount =
        ogs_local_conf()->time.message.pfcp.n1_holding_rcount;

    xact->tm_delayed_commit = ogs_timer_add(
            ogs_app()->timer_mgr, delayed_commit_timeout,
            OGS_UINT_TO_POINTER(xact->id));
    ogs_assert(xact->tm_delayed_commit);

    ogs_list_add(xact->org == OGS_PFCP_LOCAL_ORIGINATOR ?
            &xact->node->local_list : &xact->node->remote_list, xact);

    ogs_list_init(&xact->pdr_to_create_list);

    ogs_debug("[%d] %s Create  peer %s",
            xact->xid,
            xact->org == OGS_PFCP_LOCAL_ORIGINATOR ? "LOCAL " : "REMOTE",
            ogs_sockaddr_to_string_static(node->addr_list));

    return xact;
}

static ogs_pfcp_xact_t *ogs_pfcp_xact_remote_create(
        ogs_pfcp_node_t *node, uint32_t sqn)
{
    ogs_pfcp_xact_t *xact = NULL;

    ogs_assert(node);

    ogs_pool_id_calloc(&pool, &xact);
    ogs_assert(xact);
    xact->index = ogs_pool_index(&pool, xact);

    xact->org = OGS_PFCP_REMOTE_ORIGINATOR;
    xact->xid = OGS_PFCP_SQN_TO_XID(sqn);
    xact->node = node;

    xact->tm_response = ogs_timer_add(
            ogs_app()->timer_mgr, response_timeout,
            OGS_UINT_TO_POINTER(xact->id));
    ogs_assert(xact->tm_response);
    xact->response_rcount =
        ogs_local_conf()->time.message.pfcp.n1_response_rcount;

    xact->tm_holding = ogs_timer_add(
            ogs_app()->timer_mgr, holding_timeout,
            OGS_UINT_TO_POINTER(xact->id));
    ogs_assert(xact->tm_holding);
    xact->holding_rcount =
        ogs_local_conf()->time.message.pfcp.n1_holding_rcount;

    xact->tm_delayed_commit = ogs_timer_add(
            ogs_app()->timer_mgr, delayed_commit_timeout,
            OGS_UINT_TO_POINTER(xact->id));
    ogs_assert(xact->tm_delayed_commit);

    ogs_list_add(xact->org == OGS_PFCP_LOCAL_ORIGINATOR ?
            &xact->node->local_list : &xact->node->remote_list, xact);

    ogs_debug("[%d] %s Create  peer %s",
            xact->xid,
            xact->org == OGS_PFCP_LOCAL_ORIGINATOR ? "LOCAL " : "REMOTE",
            ogs_sockaddr_to_string_static(node->addr_list));

    return xact;
}

void ogs_pfcp_xact_delete_all(ogs_pfcp_node_t *node)
{
    ogs_pfcp_xact_t *xact = NULL, *next_xact = NULL;

    ogs_list_for_each_safe(&node->local_list, next_xact, xact)
        ogs_pfcp_xact_delete(xact);
    ogs_list_for_each_safe(&node->remote_list, next_xact, xact)
        ogs_pfcp_xact_delete(xact);
}

ogs_pfcp_xact_t *ogs_pfcp_xact_find_by_id(ogs_pool_id_t id)
{
    return ogs_pool_find_by_id(&pool, id);
}

int ogs_pfcp_xact_update_tx(ogs_pfcp_xact_t *xact,
        ogs_pfcp_header_t *hdesc, ogs_pkbuf_t *pkbuf)
{
    ogs_pfcp_xact_stage_t stage;
    ogs_pfcp_header_t *h = NULL;
    int pfcp_hlen = 0;

    ogs_assert(xact);
    ogs_assert(xact->node);
    ogs_assert(hdesc);
    ogs_assert(pkbuf);

    ogs_debug("[%d] %s UPD TX-%d  peer %s",
            xact->xid,
            xact->org == OGS_PFCP_LOCAL_ORIGINATOR ? "LOCAL " : "REMOTE",
            hdesc->type,
            ogs_sockaddr_to_string_static(xact->node->addr_list));

    stage = ogs_pfcp_xact_get_stage(hdesc->type, xact->xid);
    if (xact->org == OGS_PFCP_LOCAL_ORIGINATOR) {
        switch (stage) {
        case PFCP_XACT_INITIAL_STAGE:
            if (xact->step != 0) {
                ogs_error("invalid step[%d] type[%d]", xact->step, hdesc->type);
                ogs_pkbuf_free(pkbuf);
                return OGS_ERROR;
            }
            break;

        case PFCP_XACT_INTERMEDIATE_STAGE:
            ogs_expect(0);
            ogs_pkbuf_free(pkbuf);
            return OGS_ERROR;

        case PFCP_XACT_FINAL_STAGE:
            if (xact->step != 2) {
                ogs_error("invalid step[%d] type[%d]", xact->step, hdesc->type);
                ogs_pkbuf_free(pkbuf);
                return OGS_ERROR;
            }
            break;

        default:
            ogs_assert_if_reached();
            break;
        }
    } else if (xact->org == OGS_PFCP_REMOTE_ORIGINATOR) {
        switch (stage) {
        case PFCP_XACT_INITIAL_STAGE:
            ogs_expect(0);
            ogs_pkbuf_free(pkbuf);
            return OGS_ERROR;

        case PFCP_XACT_INTERMEDIATE_STAGE:
        case PFCP_XACT_FINAL_STAGE:
            if (xact->step != 1) {
                ogs_error("invalid step[%d] type[%d]", xact->step, hdesc->type);
                ogs_pkbuf_free(pkbuf);
                return OGS_ERROR;
            }
            break;

        default:
            ogs_error("invalid stage[%d] type[%d]", stage, hdesc->type);
            ogs_pkbuf_free(pkbuf);
            return OGS_ERROR;
        }
    } else {
        ogs_error("invalid org[%d] type[%d]", xact->org, hdesc->type);
        ogs_pkbuf_free(pkbuf);
        return OGS_ERROR;
    }

    if (hdesc->type >= OGS_PFCP_SESSION_ESTABLISHMENT_REQUEST_TYPE) {
        pfcp_hlen = OGS_PFCP_HEADER_LEN;
    } else {
        pfcp_hlen = OGS_PFCP_HEADER_LEN - OGS_PFCP_SEID_LEN;
    }

    ogs_pkbuf_push(pkbuf, pfcp_hlen);
    h = (ogs_pfcp_header_t *)pkbuf->data;
    memset(h, 0, pfcp_hlen);

    h->version = OGS_PFCP_VERSION;
    h->type = hdesc->type;

    if (h->type >= OGS_PFCP_SESSION_ESTABLISHMENT_REQUEST_TYPE) {
        h->seid_presence = 1;
        h->seid = htobe64(hdesc->seid);
        h->sqn = OGS_PFCP_XID_TO_SQN(xact->xid);
    } else {
        h->seid_presence = 0;
        h->sqn_only = OGS_PFCP_XID_TO_SQN(xact->xid);
    }
    h->length = htobe16(pkbuf->len - 4);

    /* Save Message type and packet of this step */
    xact->seq[xact->step].type = h->type;
    xact->seq[xact->step].pkbuf = pkbuf;

    /* Step */
    xact->step++;

    return OGS_OK;
}

static int ogs_pfcp_xact_update_rx(ogs_pfcp_xact_t *xact, uint8_t type)
{
    ogs_pfcp_xact_stage_t stage;

    ogs_debug("[%d] %s UPD RX-%d  peer %s",
            xact->xid,
            xact->org == OGS_PFCP_LOCAL_ORIGINATOR ? "LOCAL " : "REMOTE",
            type,
            ogs_sockaddr_to_string_static(xact->node->addr_list));

    stage = ogs_pfcp_xact_get_stage(type, xact->xid);
    if (xact->org == OGS_PFCP_LOCAL_ORIGINATOR) {
        switch (stage) {
        case PFCP_XACT_INITIAL_STAGE:
            ogs_expect(0);
            return OGS_ERROR;

        case PFCP_XACT_INTERMEDIATE_STAGE:
            if (xact->seq[1].type == type) {
                ogs_pkbuf_t *pkbuf = NULL;

                if (xact->step != 2 && xact->step != 3) {
                    ogs_error("invalid step[%d] type[%d]", xact->step, type);
                    ogs_pkbuf_free(pkbuf);
                    return OGS_ERROR;
                }

                pkbuf = xact->seq[2].pkbuf;
                if (pkbuf) {
                    if (xact->tm_holding)
                        ogs_timer_start(xact->tm_holding,
                                ogs_local_conf()->time.message.
                                    pfcp.t1_holding_duration);

                    ogs_warn("[%d] %s Request Duplicated. Retransmit!"
                            " for step %d type %d peer %s",
                            xact->xid,
                            xact->org == OGS_PFCP_LOCAL_ORIGINATOR ?
                                "LOCAL " : "REMOTE",
                            xact->step, type,
                            ogs_sockaddr_to_string_static(
                                xact->node->addr_list));
                    ogs_expect(OGS_OK == ogs_pfcp_sendto(xact->node, pkbuf));
                } else {
                    ogs_warn("[%d] %s Request Duplicated. Discard!"
                            " for step %d type %d peer %s",
                            xact->xid,
                            xact->org == OGS_PFCP_LOCAL_ORIGINATOR ?
                                "LOCAL " : "REMOTE",
                            xact->step, type,
                            ogs_sockaddr_to_string_static(
                                xact->node->addr_list));
                }

                return OGS_RETRY;
            }

            if (xact->step != 1) {
                ogs_error("invalid step[%d] type[%d]", xact->step, type);
                return OGS_ERROR;
            }

            if (xact->tm_holding)
                ogs_timer_start(xact->tm_holding,
                        ogs_local_conf()->time.message.pfcp.
                        t1_holding_duration);

            break;

        case PFCP_XACT_FINAL_STAGE:
            if (xact->step != 1) {
                ogs_error("invalid step[%d] type[%d]", xact->step, type);
                return OGS_ERROR;
            }
            break;

        default:
            ogs_error("invalid stage[%d]", stage);
            return OGS_ERROR;
        }
    } else if (xact->org == OGS_PFCP_REMOTE_ORIGINATOR) {
        switch (stage) {
        case PFCP_XACT_INITIAL_STAGE:
            if (xact->seq[0].type == type) {
                ogs_pkbuf_t *pkbuf = NULL;

                if (xact->step != 1 && xact->step != 2) {
                    ogs_error("invalid step[%d] type[%d]", xact->step, type);
                    return OGS_ERROR;
                }

                pkbuf = xact->seq[1].pkbuf;
                if (pkbuf) {
                    if (xact->tm_holding)
                        ogs_timer_start(xact->tm_holding,
                                ogs_local_conf()->time.message.
                                    pfcp.t1_holding_duration);

                    ogs_warn("[%d] %s Request Duplicated. Retransmit!"
                            " for step %d type %d peer %s",
                            xact->xid,
                            xact->org == OGS_PFCP_LOCAL_ORIGINATOR ?
                                "LOCAL " : "REMOTE",
                            xact->step, type,
                            ogs_sockaddr_to_string_static(
                                xact->node->addr_list));
                    ogs_expect(OGS_OK == ogs_pfcp_sendto(xact->node, pkbuf));
                } else {
                    ogs_warn("[%d] %s Request Duplicated. Discard!"
                            " for step %d type %d peer %s",
                            xact->xid,
                            xact->org == OGS_PFCP_LOCAL_ORIGINATOR ?
                                "LOCAL " : "REMOTE",
                            xact->step, type,
                            ogs_sockaddr_to_string_static(
                                xact->node->addr_list));
                }

                return OGS_RETRY;
            }

            if (xact->step != 0) {
                ogs_error("invalid step[%d] type[%d]", xact->step, type);
                return OGS_ERROR;
            }
            if (xact->tm_holding)
                ogs_timer_start(xact->tm_holding,
                        ogs_local_conf()->time.message.pfcp.
                        t1_holding_duration);

            break;

        case PFCP_XACT_INTERMEDIATE_STAGE:
            ogs_expect(0);
            return OGS_ERROR;

        case PFCP_XACT_FINAL_STAGE:
            if (xact->step != 2) {
                ogs_error("invalid step[%d] type[%d]", xact->step, type);
                return OGS_ERROR;
            }

            /* continue */
            break;

        default:
            ogs_error("invalid stage[%d]", stage);
            return OGS_ERROR;
        }
    } else {
        ogs_error("invalid org[%d]", xact->org);
        return OGS_ERROR;
    }

    if (xact->tm_response)
        ogs_timer_stop(xact->tm_response);

    /* Save Message type of this step */
    xact->seq[xact->step].type = type;

    /* Step */
    xact->step++;

    return OGS_OK;
}

int ogs_pfcp_xact_commit(ogs_pfcp_xact_t *xact)
{
    uint8_t type;
    ogs_pkbuf_t *pkbuf = NULL;
    ogs_pfcp_xact_stage_t stage;

    ogs_assert(xact);
    ogs_assert(xact->node);

    ogs_debug("[%d] %s Commit  peer %s",
            xact->xid,
            xact->org == OGS_PFCP_LOCAL_ORIGINATOR ? "LOCAL " : "REMOTE",
            ogs_sockaddr_to_string_static(xact->node->addr_list));

    type = xact->seq[xact->step-1].type;
    stage = ogs_pfcp_xact_get_stage(type, xact->xid);

    if (xact->org == OGS_PFCP_LOCAL_ORIGINATOR) {
        switch (stage) {
        case PFCP_XACT_INITIAL_STAGE:
            if (xact->step != 1) {
                ogs_error("invalid step[%d] type[%d]", xact->step, type);
                ogs_pfcp_xact_delete(xact);
                return OGS_ERROR;
            }

            if (xact->tm_response)
                ogs_timer_start(xact->tm_response,
                        ogs_local_conf()->time.message.pfcp.t1_response_duration);

            break;

        case PFCP_XACT_INTERMEDIATE_STAGE:
            ogs_expect(0);
            ogs_pfcp_xact_delete(xact);
            return OGS_ERROR;

        case PFCP_XACT_FINAL_STAGE:
            if (xact->step != 2 && xact->step != 3) {
                ogs_error("invalid step[%d] type[%d]", xact->step, type);
                ogs_pfcp_xact_delete(xact);
                return OGS_ERROR;
            }
            if (xact->step == 2) {
                ogs_pfcp_xact_delete(xact);
                return OGS_OK;
            }

            break;

        default:
            ogs_error("invalid stage[%d] type[%d]", stage, type);
            ogs_pfcp_xact_delete(xact);
            return OGS_ERROR;
        }
    } else if (xact->org == OGS_PFCP_REMOTE_ORIGINATOR) {
        switch (stage) {
        case PFCP_XACT_INITIAL_STAGE:
            ogs_expect(0);
            ogs_pfcp_xact_delete(xact);
            return OGS_ERROR;

        case PFCP_XACT_INTERMEDIATE_STAGE:
            if (xact->step != 2) {
                ogs_error("invalid step[%d] type[%d]", xact->step, type);
                ogs_pfcp_xact_delete(xact);
                return OGS_ERROR;
            }
            if (xact->tm_response)
                ogs_timer_start(xact->tm_response,
                        ogs_local_conf()->time.message.pfcp.
                        t1_response_duration);

            break;

        case PFCP_XACT_FINAL_STAGE:
            if (xact->step != 2 && xact->step != 3) {
                ogs_error("invalid step[%d] type[%d]", xact->step, type);
                ogs_pfcp_xact_delete(xact);
                return OGS_ERROR;
            }
            if (xact->step == 3) {
                ogs_pfcp_xact_delete(xact);
                return OGS_OK;
            }

            break;

        default:
            ogs_error("invalid stage[%d] type[%d]", stage, type);
            ogs_pfcp_xact_delete(xact);
            return OGS_ERROR;
        }
    } else {
        ogs_error("invalid org[%d] type[%d]", xact->org, type);
        ogs_pfcp_xact_delete(xact);
        return OGS_ERROR;
    }

    pkbuf = xact->seq[xact->step-1].pkbuf;
    ogs_assert(pkbuf);

    ogs_expect(OGS_OK == ogs_pfcp_sendto(xact->node, pkbuf));

    return OGS_OK;
}

void ogs_pfcp_xact_delayed_commit(ogs_pfcp_xact_t *xact, ogs_time_t duration)
{
    ogs_assert(xact);
    ogs_assert(duration);
    ogs_assert(xact->tm_delayed_commit);

    ogs_timer_start(xact->tm_delayed_commit, duration);
}

static void response_timeout(void *data)
{
    ogs_pool_id_t xact_id = OGS_INVALID_POOL_ID;
    ogs_pfcp_xact_t *xact = NULL;

    ogs_assert(data);
    xact_id = OGS_POINTER_TO_UINT(data);
    ogs_assert(xact_id >= OGS_MIN_POOL_ID && xact_id <= OGS_MAX_POOL_ID);

    xact = ogs_pfcp_xact_find_by_id(xact_id);
    if (!xact) {
        ogs_error("PFCP Transaction has already been removed [%d]", xact_id);
        return;;
    }
    ogs_assert(xact->node);

    ogs_debug("[%d] %s Response Timeout "
            "for step %d type %d peer %s",
            xact->xid,
            xact->org == OGS_PFCP_LOCAL_ORIGINATOR ? "LOCAL " : "REMOTE",
            xact->step, xact->seq[xact->step-1].type,
            ogs_sockaddr_to_string_static(xact->node->addr_list));

    if (--xact->response_rcount > 0) {
        ogs_pkbuf_t *pkbuf = NULL;

        if (xact->tm_response)
            ogs_timer_start(xact->tm_response,
                    ogs_local_conf()->time.message.pfcp.t1_response_duration);

        pkbuf = xact->seq[xact->step-1].pkbuf;
        ogs_assert(pkbuf);

        ogs_expect(OGS_OK == ogs_pfcp_sendto(xact->node, pkbuf));
    } else {
        ogs_warn("[%d] %s No Reponse. Give up! "
                "for step %d type %d peer %s",
                xact->xid,
                xact->org == OGS_PFCP_LOCAL_ORIGINATOR ? "LOCAL " : "REMOTE",
                xact->step, xact->seq[xact->step-1].type,
                ogs_sockaddr_to_string_static(xact->node->addr_list));

        if (xact->cb)
            xact->cb(xact, xact->data);

        ogs_pfcp_xact_delete(xact);
    }
}

static void holding_timeout(void *data)
{
    ogs_pool_id_t xact_id = OGS_INVALID_POOL_ID;
    ogs_pfcp_xact_t *xact = NULL;

    ogs_assert(data);
    xact_id = OGS_POINTER_TO_UINT(data);
    ogs_assert(xact_id >= OGS_MIN_POOL_ID && xact_id <= OGS_MAX_POOL_ID);

    xact = ogs_pfcp_xact_find_by_id(xact_id);
    if (!xact) {
        ogs_error("PFCP Transaction has already been removed [%d]", xact_id);
        return;;
    }
    ogs_assert(xact->node);

    ogs_debug("[%d] %s Holding Timeout "
            "for step %d type %d peer %s",
            xact->xid,
            xact->org == OGS_PFCP_LOCAL_ORIGINATOR ? "LOCAL " : "REMOTE",
            xact->step, xact->seq[xact->step-1].type,
            ogs_sockaddr_to_string_static(xact->node->addr_list));

    if (--xact->holding_rcount > 0) {
        if (xact->tm_holding)
            ogs_timer_start(xact->tm_holding,
                    ogs_local_conf()->time.message.pfcp.t1_holding_duration);
    } else {
        ogs_debug("[%d] %s Delete Transaction "
                "for step %d type %d peer %s",
                xact->xid,
                xact->org == OGS_PFCP_LOCAL_ORIGINATOR ? "LOCAL " : "REMOTE",
                xact->step, xact->seq[xact->step-1].type,
                ogs_sockaddr_to_string_static(xact->node->addr_list));
        ogs_pfcp_xact_delete(xact);
    }
}

static void delayed_commit_timeout(void *data)
{
    ogs_pool_id_t xact_id = OGS_INVALID_POOL_ID;
    ogs_pfcp_xact_t *xact = NULL;

    ogs_assert(data);
    xact_id = OGS_POINTER_TO_UINT(data);
    ogs_assert(xact_id >= OGS_MIN_POOL_ID && xact_id <= OGS_MAX_POOL_ID);

    xact = ogs_pfcp_xact_find_by_id(xact_id);
    if (!xact) {
        ogs_error("PFCP Transaction has already been removed [%d]", xact_id);
        return;;
    }
    ogs_assert(xact->node);

    ogs_debug("[%d] %s Delayed Send Timeout "
            "for step %d type %d peer %s",
            xact->xid,
            xact->org == OGS_PFCP_LOCAL_ORIGINATOR ? "LOCAL " : "REMOTE",
            xact->step, xact->seq[xact->step-1].type,
            ogs_sockaddr_to_string_static(xact->node->addr_list));

    ogs_pfcp_xact_commit(xact);
}

int ogs_pfcp_xact_receive(
        ogs_pfcp_node_t *node, ogs_pfcp_header_t *h, ogs_pfcp_xact_t **xact)
{
    int rv;

    uint8_t type;
    uint32_t sqn, xid;
    ogs_pfcp_xact_stage_t stage;
    ogs_list_t *list = NULL;
    ogs_pfcp_xact_t *new = NULL;

    ogs_assert(node);
    ogs_assert(h);

    type = h->type;
    sqn = h->sqn;
    xid = OGS_PFCP_SQN_TO_XID(sqn);
    stage = ogs_pfcp_xact_get_stage(type, xid);

    switch (stage) {
    case PFCP_XACT_INITIAL_STAGE:
        list = &node->remote_list;
        break;
    case PFCP_XACT_INTERMEDIATE_STAGE:
        list = &node->local_list;
        break;
    case PFCP_XACT_FINAL_STAGE:
        list = &node->local_list;
        break;
    default:
        ogs_error("[%d] Unexpected type %u from PFCP peer %s",
                xid, type, ogs_sockaddr_to_string_static(node->addr_list));
        return OGS_ERROR;
    }

    ogs_assert(list);
    ogs_list_for_each(list, new) {
        if (new->xid == xid) {
            ogs_debug("[%d] %s Find    peer %s",
                new->xid,
                new->org == OGS_PFCP_LOCAL_ORIGINATOR ? "LOCAL " : "REMOTE",
                ogs_sockaddr_to_string_static(node->addr_list));
            break;
        }
    }

    if (!new) {
        ogs_debug("[%d] Cannot find new type %u from PFCP peer %s",
                xid, type, ogs_sockaddr_to_string_static(node->addr_list));
        new = ogs_pfcp_xact_remote_create(node, sqn);
    }
    ogs_assert(new);

    ogs_debug("[%d] %s Receive peer %s",
            new->xid,
            new->org == OGS_PFCP_LOCAL_ORIGINATOR ? "LOCAL " : "REMOTE",
            ogs_sockaddr_to_string_static(node->addr_list));

    rv = ogs_pfcp_xact_update_rx(new, type);
    if (rv == OGS_ERROR) {
        ogs_error("ogs_pfcp_xact_update_rx() failed");
        ogs_pfcp_xact_delete(new);
        return rv;
    } else if (rv == OGS_RETRY) {
        return rv;
    }

    *xact = new;
    return rv;
}

static ogs_pfcp_xact_stage_t ogs_pfcp_xact_get_stage(uint8_t type, uint32_t xid)
{
    ogs_pfcp_xact_stage_t stage = PFCP_XACT_UNKNOWN_STAGE;

    switch (type) {
    case OGS_PFCP_HEARTBEAT_REQUEST_TYPE:
    case OGS_PFCP_ASSOCIATION_SETUP_REQUEST_TYPE:
    case OGS_PFCP_ASSOCIATION_UPDATE_REQUEST_TYPE:
    case OGS_PFCP_ASSOCIATION_RELEASE_REQUEST_TYPE:
    case OGS_PFCP_SESSION_ESTABLISHMENT_REQUEST_TYPE:
    case OGS_PFCP_SESSION_MODIFICATION_REQUEST_TYPE:
    case OGS_PFCP_SESSION_DELETION_REQUEST_TYPE:
    case OGS_PFCP_SESSION_REPORT_REQUEST_TYPE:
        stage = PFCP_XACT_INITIAL_STAGE;
        break;
    case OGS_PFCP_HEARTBEAT_RESPONSE_TYPE:
    case OGS_PFCP_ASSOCIATION_SETUP_RESPONSE_TYPE:
    case OGS_PFCP_ASSOCIATION_UPDATE_RESPONSE_TYPE:
    case OGS_PFCP_ASSOCIATION_RELEASE_RESPONSE_TYPE:
    case OGS_PFCP_VERSION_NOT_SUPPORTED_RESPONSE_TYPE:
    case OGS_PFCP_SESSION_ESTABLISHMENT_RESPONSE_TYPE:
    case OGS_PFCP_SESSION_MODIFICATION_RESPONSE_TYPE:
    case OGS_PFCP_SESSION_DELETION_RESPONSE_TYPE:
    case OGS_PFCP_SESSION_REPORT_RESPONSE_TYPE:
        stage = PFCP_XACT_FINAL_STAGE;
        break;

    default:
        ogs_error("Not implemented PFCPv2 Message Type(%d)", type);
        break;
    }

    return stage;
}

int ogs_pfcp_xact_delete(ogs_pfcp_xact_t *xact)
{
    ogs_assert(xact);
    ogs_assert(xact->node);

    ogs_debug("[%d] %s Delete  peer %s",
            xact->xid,
            xact->org == OGS_PFCP_LOCAL_ORIGINATOR ? "LOCAL " : "REMOTE",
            ogs_sockaddr_to_string_static(xact->node->addr_list));

    if (xact->seq[0].pkbuf)
        ogs_pkbuf_free(xact->seq[0].pkbuf);
    if (xact->seq[1].pkbuf)
        ogs_pkbuf_free(xact->seq[1].pkbuf);
    if (xact->seq[2].pkbuf)
        ogs_pkbuf_free(xact->seq[2].pkbuf);

    if (xact->tm_response)
        ogs_timer_delete(xact->tm_response);
    if (xact->tm_holding)
        ogs_timer_delete(xact->tm_holding);
    if (xact->tm_delayed_commit)
        ogs_timer_delete(xact->tm_delayed_commit);

    ogs_list_remove(xact->org == OGS_PFCP_LOCAL_ORIGINATOR ?
            &xact->node->local_list : &xact->node->remote_list, xact);
    ogs_pool_id_free(&pool, xact);

    return OGS_OK;
}
===== xact.h =====

#if !defined(OGS_PFCP_INSIDE) && !defined(OGS_PFCP_COMPILATION)
#error "This header cannot be included directly."
#endif

#ifndef OGS_PFCP_XACT_H
#define OGS_PFCP_XACT_H

#ifdef __cplusplus
extern "C" {
#endif

/**
 * Transaction context
 */
typedef struct ogs_pfcp_xact_s {
    ogs_lnode_t     lnode;          /**< A node of list */
    ogs_lnode_t     tmpnode;        /**< A node of temp-list */

    ogs_pool_id_t   id;

    ogs_pool_id_t   index;

#define OGS_PFCP_LOCAL_ORIGINATOR  0
#define OGS_PFCP_REMOTE_ORIGINATOR 1
    uint8_t         org;            /**< Transaction' originator.
                                         local or remote */

    uint32_t        xid;            /**< Transaction ID */
    ogs_pfcp_node_t *node;          /**< Relevant PFCP node context */

    /**< Local timer expiration handler & Data*/
    void (*cb)(ogs_pfcp_xact_t *, void *);
    void            *data;

    int             step;           /**< Current step in the sequence.
                                         1 : Initial
                                         2 : Triggered
                                         3 : Triggered-Reply */
    struct {
        uint8_t     type;           /**< Message type history */
        ogs_pkbuf_t *pkbuf;         /**< Packet history */
    } seq[3];                       /**< history for the each step */

    ogs_timer_t     *tm_response;   /**< Timer waiting for next message */
    uint8_t         response_rcount;
    ogs_timer_t     *tm_holding;    /**< Timer waiting for holding message */
    uint8_t         holding_rcount;

    ogs_timer_t     *tm_delayed_commit; /**< Timer waiting for commit xact */

    uint64_t        local_seid;     /**< Local SEID,
                                         expected in reply from peer */

    ogs_pool_id_t   assoc_xact_id;  /**< Associated GTP transaction ID */
    ogs_pkbuf_t     *gtpbuf;        /**< GTP packet buffer */

    uint8_t         gtp_pti;        /**< GTP Procedure transaction identity */
    uint8_t         gtp_cause;      /**< GTP Cause Value */

    ogs_pool_id_t   assoc_stream_id;  /**< Associated SBI session ID */

    bool            epc;            /**< EPC or 5GC */

#define OGS_PFCP_CREATE_RESTORATION_INDICATION ((uint64_t)1<<0)
    uint64_t        create_flags;

#define OGS_PFCP_MODIFY_SESSION ((uint64_t)1<<0)
#define OGS_PFCP_MODIFY_DL_ONLY ((uint64_t)1<<1)
#define OGS_PFCP_MODIFY_UL_ONLY ((uint64_t)1<<2)
#define OGS_PFCP_MODIFY_INDIRECT ((uint64_t)1<<3)
#define OGS_PFCP_MODIFY_UE_REQUESTED ((uint64_t)1<<4)
#define OGS_PFCP_MODIFY_NETWORK_REQUESTED ((uint64_t)1<<5)
#define OGS_PFCP_MODIFY_CREATE ((uint64_t)1<<6)
#define OGS_PFCP_MODIFY_REMOVE ((uint64_t)1<<7)
#define OGS_PFCP_MODIFY_EPC_TFT_UPDATE ((uint64_t)1<<8)
#define OGS_PFCP_MODIFY_EPC_QOS_UPDATE ((uint64_t)1<<9)
#define OGS_PFCP_MODIFY_TFT_NEW ((uint64_t)1<<10)
#define OGS_PFCP_MODIFY_TFT_ADD ((uint64_t)1<<11)
#define OGS_PFCP_MODIFY_TFT_REPLACE ((uint64_t)1<<12)
#define OGS_PFCP_MODIFY_TFT_DELETE ((uint64_t)1<<13)
#define OGS_PFCP_MODIFY_QOS_CREATE ((uint64_t)1<<14)
#define OGS_PFCP_MODIFY_QOS_MODIFY ((uint64_t)1<<15)
#define OGS_PFCP_MODIFY_QOS_DELETE ((uint64_t)1<<16)
#define OGS_PFCP_MODIFY_OUTER_HEADER_REMOVAL ((uint64_t)1<<17)
#define OGS_PFCP_MODIFY_ACTIVATE ((uint64_t)1<<18)
#define OGS_PFCP_MODIFY_DEACTIVATE ((uint64_t)1<<19)
#define OGS_PFCP_MODIFY_END_MARKER ((uint64_t)1<<20)
#define OGS_PFCP_MODIFY_ERROR_INDICATION ((uint64_t)1<<21)
#define OGS_PFCP_MODIFY_XN_HANDOVER ((uint64_t)1<<22)
#define OGS_PFCP_MODIFY_N2_HANDOVER ((uint64_t)1<<23)
#define OGS_PFCP_MODIFY_HANDOVER_CANCEL ((uint64_t)1<<24)
#define OGS_PFCP_MODIFY_HOME_ROUTED_ROAMING ((uint64_t)1<<25)
#define OGS_PFCP_MODIFY_URR  ((uint64_t)1<<26) /* type of trigger */
#define OGS_PFCP_MODIFY_URR_MEAS_METHOD ((uint64_t)1<<27)
#define OGS_PFCP_MODIFY_URR_REPORT_TRIGGER ((uint64_t)1<<28)
#define OGS_PFCP_MODIFY_URR_QUOTA_VALIDITY_TIME ((uint64_t)1<<29)
#define OGS_PFCP_MODIFY_URR_VOLUME_QUOTA ((uint64_t)1<<30)
#define OGS_PFCP_MODIFY_URR_TIME_QUOTA ((uint64_t)1<<31)
#define OGS_PFCP_MODIFY_URR_VOLUME_THRESH ((uint64_t)1<<32)
#define OGS_PFCP_MODIFY_URR_TIME_THRESH ((uint64_t)1<<33)
    uint64_t        modify_flags;

#define OGS_PFCP_DELETE_TRIGGER_LOCAL_INITIATED 1
#define OGS_PFCP_DELETE_TRIGGER_UE_REQUESTED 2
#define OGS_PFCP_DELETE_TRIGGER_PCF_INITIATED 3
#define OGS_PFCP_DELETE_TRIGGER_RAN_INITIATED 4
#define OGS_PFCP_DELETE_TRIGGER_SMF_INITIATED 5
#define OGS_PFCP_DELETE_TRIGGER_AMF_RELEASE_SM_CONTEXT 6
#define OGS_PFCP_DELETE_TRIGGER_AMF_UPDATE_SM_CONTEXT 7
    int             delete_trigger;

    ogs_list_t      pdr_to_create_list;
    ogs_list_t      bearer_to_modify_list;
} ogs_pfcp_xact_t;

int ogs_pfcp_xact_init(void);
void ogs_pfcp_xact_final(void);

ogs_pfcp_xact_t *ogs_pfcp_xact_local_create(ogs_pfcp_node_t *node,
        void (*cb)(ogs_pfcp_xact_t *xact, void *data), void *data);
void ogs_pfcp_xact_delete_all(ogs_pfcp_node_t *node);
ogs_pfcp_xact_t *ogs_pfcp_xact_find_by_id(ogs_pool_id_t id);

int ogs_pfcp_xact_update_tx(ogs_pfcp_xact_t *xact,
        ogs_pfcp_header_t *hdesc, ogs_pkbuf_t *pkbuf);

int ogs_pfcp_xact_commit(ogs_pfcp_xact_t *xact);
void ogs_pfcp_xact_delayed_commit(ogs_pfcp_xact_t *xact, ogs_time_t duration);

int ogs_pfcp_xact_delete(ogs_pfcp_xact_t *xact);

int ogs_pfcp_xact_receive(ogs_pfcp_node_t *node,
        ogs_pfcp_header_t *h, ogs_pfcp_xact_t **xact);

#ifdef __cplusplus
}
#endif

#endif /* OGS_PFCP_XACT_H */
